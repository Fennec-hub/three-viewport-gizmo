{"version":3,"file":"three-viewport-gizmo.js","sources":["../lib/utils/gizmoDomElement.ts","../lib/utils/getDomElement.ts","../node_modules/three/src/math/MathUtils.js","../lib/utils/updateAxis.ts","../lib/utils/isClick.ts","../lib/utils/intersectedObjects.ts","../lib/utils/constants.ts","../lib/utils/updateBackground.ts","../lib/utils/deepClone.ts","../lib/utils/optionsFallback.ts","../lib/utils/axesMap.ts","../lib/utils/roundedRectangleGeometry.ts","../lib/utils/axesFaces.ts","../lib/utils/axesCorners.ts","../lib/utils/axesEdges.ts","../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","../lib/utils/gizmoBackground.ts","../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../node_modules/three/examples/jsm/lines/LineMaterial.js","../node_modules/three/examples/jsm/lines/LineSegments2.js","../node_modules/three/examples/jsm/lines/LineGeometry.js","../node_modules/three/examples/jsm/lines/Line2.js","../lib/utils/axesLines.ts","../lib/utils/axesObjects.ts","../lib/utils/axisHover.ts","../lib/ViewportGizmo.ts"],"sourcesContent":["import { GizmoOptionsFallback } from \"../types\";\n\nexport const setDomPlacement = (\n  domElement: HTMLElement,\n  placement: GizmoOptionsFallback[\"placement\"]\n) => {\n  const [y, x] = placement.split(\"-\");\n  Object.assign(domElement.style, {\n    left: x === \"left\" ? \"0\" : x === \"center\" ? `50%` : \"\",\n    right: x === \"right\" ? \"0\" : \"\",\n    top: y === \"top\" ? \"0\" : y === \"bottom\" ? \"\" : \"50%\",\n    bottom: y === \"bottom\" ? \"0\" : \"\",\n    transform: `${x === \"center\" ? \"translateX(-50%)\" : \"\"} ${\n      y === \"center\" ? \"translateY(-50%)\" : \"\"\n    }`,\n  });\n\n  return placement;\n};\n\nexport const gizmoDomElement = ({\n  placement,\n  size,\n  offset,\n  id,\n  className,\n}: GizmoOptionsFallback) => {\n  const div = document.createElement(\"div\");\n\n  const { top, left, right, bottom } = offset;\n  Object.assign(div.style, {\n    id,\n    position: \"absolute\",\n    zIndex: \"1000\",\n    height: `${size}px`,\n    width: `${size}px`,\n    margin: `${top}px ${right}px ${bottom}px ${left}px`,\n    borderRadius: \"100%\",\n  });\n\n  setDomPlacement(div, placement);\n\n  if (id) div.id = id;\n  if (className) div.className = className;\n\n  return div;\n};\n","export const getDomElement = (\n  domElement: string | HTMLElement\n): HTMLElement => {\n  const element =\n    typeof domElement === \"string\"\n      ? document.querySelector<HTMLElement>(domElement)\n      : domElement;\n\n  if (!element) throw Error(`Invalid DOM element`);\n\n  return element;\n};\n","const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport { Camera, Vector3 } from \"three\";\nimport { clamp } from \"three/src/math/MathUtils.js\";\n\nconst axisMap: [\n  axis: \"x\" | \"y\" | \"z\",\n  positiveIndex: number,\n  negativeIndex: number\n][] = [\n  [\"x\", 0, 3],\n  [\"y\", 1, 4],\n  [\"z\", 2, 5],\n];\n\nconst point = /*@__PURE__*/ new Vector3();\nexport function updateAxis(\n  { isSphere }: GizmoOptionsFallback,\n  axes: GizmoAxisObject[],\n  camera: Camera\n): void {\n  if (!isSphere) return;\n\n  point.set(0, 0, 1).applyQuaternion(camera.quaternion);\n\n  axisMap.forEach(([axis, positiveIndex, negativeIndex]) => {\n    const value = point[axis];\n\n    let object = axes[positiveIndex];\n    let opacity = object.userData.opacity;\n\n    object.material.opacity = clamp(value >= 0 ? opacity : opacity / 2, 0, 1);\n\n    object = axes[negativeIndex];\n    opacity = object.userData.opacity;\n\n    object.material.opacity = clamp(value >= 0 ? opacity / 2 : opacity, 0, 1);\n  });\n}\n","import { Vector2 } from \"three\";\n\nexport const isClick = (\n  e: PointerEvent,\n  startCoords: Vector2,\n  threshold: number = 10\n) =>\n  Math.abs(e.clientX - startCoords.x) < threshold &&\n  Math.abs(e.clientY - startCoords.y) < threshold;\n","import { GizmoAxisObject } from \"@lib/types\";\nimport {\n  Vector2,\n  Raycaster,\n  type Object3D,\n  type Camera,\n  Intersection,\n} from \"three\";\n\nconst _raycaster = /*@__PURE__*/ new Raycaster();\nconst _mouse = /*@__PURE__*/ new Vector2();\n\nexport const intersectedObjects = (\n  event: PointerEvent,\n  domRect: DOMRect,\n  camera: Camera,\n  intersections: Object3D[]\n): Intersection<GizmoAxisObject> | null => {\n  _mouse.set(\n    ((event.clientX - domRect.left) / domRect.width) * 2 - 1,\n    -((event.clientY - domRect.top) / domRect.height) * 2 + 1\n  );\n\n  _raycaster.setFromCamera(_mouse, camera);\n\n  const intersects = _raycaster.intersectObjects<GizmoAxisObject>(\n    intersections,\n    false\n  );\n\n  const intersection = intersects.length ? intersects[0] : null;\n\n  return !intersection || !intersection.object.visible ? null : intersection;\n};\n","export const EPSILON = 1e-6;\nexport const GIZMO_TURN_RATE = 2 * Math.PI;\nexport const AXES = [\"x\", \"y\", \"z\"] as const;\nexport const GIZMO_AXES = [...AXES, \"nx\", \"ny\", \"nz\"] as const;\nexport const GIZMO_FACES = [\n  \"right\",\n  \"top\",\n  \"front\",\n  \"left\",\n  \"bottom\",\n  \"back\",\n] as const;\nexport const GIZMO_SPHERE_AXES_DISTANCE = 1.3;\n","import { BufferGeometry, Mesh, MeshBasicMaterial } from \"three\";\n\nexport const updateBackground = (\n  background: Mesh<BufferGeometry, MeshBasicMaterial>,\n  hovered: boolean = true\n) => {\n  const { material, userData } = background;\n  const { color, opacity } = hovered ? userData.hover : userData;\n\n  material.color.set(color);\n  material.opacity = opacity;\n};\n","export const deepClone = <T>(obj: T) => JSON.parse(JSON.stringify(obj));\n","import {\n  GizmoAxisOptions,\n  GizmoOptions,\n  GizmoOptionsFallback,\n} from \"@lib/types\";\nimport { AXES, GIZMO_AXES, GIZMO_FACES } from \"./constants\";\n\nimport { deepClone } from \"./deepClone\";\n\nexport const optionsFallback = (\n  options: GizmoOptions\n): GizmoOptionsFallback => {\n  const type = options.type || \"sphere\";\n  const isSphere = type === \"sphere\";\n  const resolution = options.resolution || isSphere ? 64 : 128;\n\n  const { container } = options;\n  options.container = undefined;\n  options = JSON.parse(JSON.stringify(options));\n  options.container = container;\n\n  // Convert face axis to regular axis\n  GIZMO_FACES.forEach((face, index) => {\n    if (options[face]) options[GIZMO_AXES[index]] = options[face];\n  });\n\n  // Positive Axes fallback options\n  const axesFallback: GizmoAxisOptions = {\n    enabled: true,\n    color: 0xffffff,\n    opacity: 1,\n    scale: isSphere ? 0.7 : 0.7,\n    labelColor: 0x222222,\n    line: false,\n    border: {\n      size: 0,\n      color: 0xdddddd,\n    },\n    hover: {\n      color: isSphere ? 0xffffff : 0x93d3eb,\n      labelColor: 0x222222,\n      opacity: 1,\n      scale: isSphere ? 0.7 : 0.7,\n      border: {\n        size: 0,\n        color: 0xdddddd,\n      },\n    },\n  };\n\n  // Negative Axes fallback options\n  const negativeAxesFallback = {\n    line: false,\n    scale: isSphere ? 0.45 : 0.7,\n    hover: {\n      scale: isSphere ? 0.5 : 0.7,\n    },\n  };\n\n  const optionsFallback: GizmoOptions = {\n    type,\n    container: document.body,\n    size: 128,\n    placement: \"top-right\",\n    resolution,\n    lineWidth: 20,\n    radius: isSphere ? 1 : 0.2,\n    smoothness: 18,\n    animated: true,\n    speed: 1,\n    background: {\n      enabled: true,\n      color: isSphere ? 0xffffff : 0xe0e6ec,\n      opacity: isSphere ? 0 : 1,\n      hover: {\n        color: isSphere ? 0xffffff : 0xe0e6ec,\n        opacity: isSphere ? 0.2 : 1,\n      },\n    },\n    font: {\n      family: \"sans-serif\",\n      weight: 900,\n    },\n    offset: {\n      top: 10,\n      left: 10,\n      bottom: 10,\n      right: 10,\n    },\n    corners: {\n      enabled: !isSphere,\n      color: isSphere ? 0xf2d962 : 0xffffff,\n      opacity: 1,\n      scale: isSphere ? 0.15 : 0.2,\n      radius: 1,\n      smoothness: 18,\n      hover: {\n        color: isSphere ? 0xffffff : 0x93d3eb,\n        opacity: 1,\n        scale: isSphere ? 0.2 : 0.225,\n      },\n    },\n    edges: {\n      enabled: !isSphere,\n      color: isSphere ? 0xf2d962 : 0xffffff,\n      opacity: isSphere ? 1 : 0,\n      radius: isSphere ? 1 : 0.125,\n      smoothness: 18,\n      scale: isSphere ? 0.15 : 1,\n      hover: {\n        color: isSphere ? 0xffffff : 0x93d3eb,\n        opacity: 1,\n        scale: isSphere ? 0.2 : 1,\n      },\n    },\n    x: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? {\n            label: \"X\",\n            color: 0xff3653,\n            line: true,\n          }\n        : {\n            label: \"Right\",\n          }),\n    },\n    y: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? {\n            label: \"Y\",\n            color: 0x8adb00,\n            line: true,\n          }\n        : {\n            label: \"Top\",\n          }),\n    },\n    z: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? {\n            label: \"Z\",\n            color: 0x2c8fff,\n            line: true,\n          }\n        : {\n            label: \"Front\",\n          }),\n    },\n    nx: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere ? \"\" : \"Left\",\n    },\n    ny: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere ? \"\" : \"Bottom\",\n    },\n    nz: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere ? \"\" : \"Back\",\n    },\n  };\n\n  assignNestedDefaults(options, optionsFallback);\n\n  // Negative axis fallback to positive axis\n  AXES.forEach((axis) =>\n    assignNestedDefaults(\n      (options as any)[`n${axis}`],\n      deepClone((options as any)[axis])\n    )\n  );\n\n  return { ...options, isSphere } as GizmoOptionsFallback;\n};\n\nfunction assignNestedDefaults<T>(target: T, ...defaultObjects: T[]) {\n  if (\n    target instanceof HTMLElement ||\n    typeof target !== \"object\" ||\n    target === null\n  )\n    return target;\n\n  for (const defaults of defaultObjects) {\n    for (const key in defaults) {\n      if (key === \"container\") continue;\n\n      if (key in (defaults as any)) {\n        if (target[key] === undefined) {\n          (target as any)[key] = defaults[key];\n        } else if (\n          typeof defaults[key] === \"object\" &&\n          !Array.isArray(defaults[key])\n        ) {\n          (target as any)[key] = assignNestedDefaults(\n            (target as any)[key] || {},\n            defaults[key]\n          );\n        }\n      }\n    }\n  }\n\n  return target as T;\n}\n","import {\n  CanvasTexture,\n  Color,\n  ColorRepresentation,\n  RepeatWrapping,\n  SRGBColorSpace,\n  Texture,\n} from \"three\";\nimport { GizmoAxisOptions, GizmoOptionsFallback } from \"@lib/types\";\nimport { GIZMO_AXES } from \"./constants\";\n\nexport const axesMap = (options: GizmoOptionsFallback, offset: number = 2) => {\n  const colorManager = new Color();\n  const doubleOffset = offset * 2;\n  const { isSphere, resolution, radius, font, corners, edges } = options;\n\n  const axes: (Required<GizmoAxisOptions> & { radius: number })[] =\n    GIZMO_AXES.map((axis) => ({ ...options[axis], radius }));\n\n  if (isSphere && corners.enabled) axes.push(corners as any);\n  if (isSphere && edges.enabled) axes.push(edges as any);\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n  canvas.width = resolution * 2 + doubleOffset * 2;\n  canvas.height = resolution * axes.length + doubleOffset * axes.length;\n\n  const [fontStyle, fontYFix] = getFontStyle(axes, resolution, font);\n\n  axes.forEach(\n    (\n      {\n        radius,\n        label,\n        color,\n        labelColor,\n        border,\n        hover: {\n          color: hoverColor,\n          labelColor: hoverLabel,\n          border: hoverBorder,\n        },\n      },\n      index\n    ) => {\n      const y = resolution * index + index * doubleOffset + offset;\n      drawAxis(\n        offset,\n        y,\n        offset,\n        resolution,\n        radius,\n        label,\n        border,\n        color,\n        labelColor\n      );\n      drawAxis(\n        resolution + offset * 3,\n        y,\n        offset,\n        resolution,\n        radius,\n        label,\n        hoverBorder ?? border,\n        hoverColor ?? color,\n        hoverLabel ?? labelColor\n      );\n    }\n  );\n\n  /* \n  // Debug\n  document.body.appendChild(canvas);\n  Object.assign(canvas.style, {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    zIndex: 100000,\n  }); */\n\n  const colsCount = axes.length;\n  const offsetX = offset / (resolution * 2);\n  const offsetY = offset / (resolution * 6);\n  const cellHeight = 1 / colsCount;\n\n  const map = new CanvasTexture(canvas);\n  map.repeat.set(0.5 - 2 * offsetX, cellHeight - 2 * offsetY);\n  map.offset.set(offsetX, 1 - offsetY);\n\n  Object.assign(map, {\n    colorSpace: SRGBColorSpace,\n    wrapS: RepeatWrapping,\n    wrapT: RepeatWrapping,\n    userData: {\n      offsetX,\n      offsetY,\n      cellHeight,\n    },\n  });\n\n  return map;\n\n  function drawAxis(\n    x: number,\n    y: number,\n    offset: number,\n    size: number,\n    radius: number,\n    label: string,\n    border: GizmoAxisOptions[\"border\"],\n    color: ColorRepresentation,\n    labelColor: ColorRepresentation\n  ) {\n    radius = radius * (size / 2);\n\n    if (color != null && color !== \"\") {\n      drawRoundRectPath();\n      ctx.fillStyle = colorManager.set(color!).getStyle();\n      ctx.fill();\n    }\n\n    if (border && border.size) {\n      const halfBorderWidth = (border.size * size) / 2;\n      x += halfBorderWidth;\n      y += halfBorderWidth;\n      size -= border.size * size;\n      radius = Math.max(0, radius - halfBorderWidth);\n\n      drawRoundRectPath();\n      ctx.strokeStyle = colorManager.set(border.color).getStyle();\n      ctx.lineWidth = border.size * size;\n      ctx.stroke();\n    }\n\n    if (label)\n      drawText(\n        ctx,\n        x + size / 2,\n        y + (size + offset) / 2,\n        label,\n        colorManager.set(labelColor!).getStyle()\n      );\n\n    function drawRoundRectPath() {\n      ctx.beginPath();\n      ctx.moveTo(x + radius, y);\n      ctx.lineTo(x + size - radius, y);\n      ctx.arcTo(x + size, y, x + size, y + radius, radius);\n      ctx.lineTo(x + size, y + size - radius);\n      ctx.arcTo(x + size, y + size, x + size - radius, y + size, radius);\n      ctx.lineTo(x + radius, y + size);\n      ctx.arcTo(x, y + size, x, y + size - radius, radius);\n      ctx.lineTo(x, y + radius);\n      ctx.arcTo(x, y, x + radius, y, radius);\n      ctx.closePath();\n    }\n  }\n\n  function getFontStyle(\n    axis: GizmoAxisOptions[],\n    resolution: number,\n    font: GizmoOptionsFallback[\"font\"]\n  ) {\n    const longestLabel = [...axis]\n      .sort((a, b) => (a.label?.length || 0) - (b.label?.length || 0))\n      .pop()!;\n    const text = longestLabel.label!;\n\n    const { family, weight } = font;\n\n    const square = isSphere\n      ? Math.sqrt(Math.pow(resolution * 0.7, 2) / 2)\n      : resolution;\n    let fontSize = square;\n    let textWidth = 0;\n    let textHeight = 0;\n\n    do {\n      ctx.font = `${weight} ${fontSize}px ${family}`;\n      const measure = ctx.measureText(text);\n      textWidth = measure.width;\n      textHeight = measure.fontBoundingBoxDescent;\n      fontSize--;\n    } while (textWidth > square && fontSize > 0);\n\n    const yFix = square / textHeight;\n    const scaleFactor = Math.min(square / textWidth, yFix);\n    const finalFontSize = Math.floor(fontSize * scaleFactor);\n\n    return [`${weight} ${finalFontSize}px ${family}`, yFix] as const;\n  }\n\n  function drawText(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    text: string,\n    color: string\n  ) {\n    ctx.font = fontStyle;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = color;\n    ctx.fillText(text, x, y + (isSphere ? fontYFix : 0));\n  }\n};\n\nexport const setMapHoverOffset = (map: Texture, hover: boolean) =>\n  (map.offset.x = (hover ? 0.5 : 0) + map.userData.offsetX);\n\nexport const setMapColumnOffset = (map: Texture, col: number) => {\n  const {\n    offset,\n    userData: { offsetY, cellHeight },\n  } = map;\n  offset.y = 1 - (col + 1) * cellHeight + offsetY;\n};\n","import { BufferGeometry, BufferAttribute } from \"three\";\n\n/**\n * Generate a Rounded Rectangle geometry\n *\n * @param radius      - The edges radius\n * @param smoothness  - The edges smoothness\n *\n * @ThanksTo `@hofk` for the {@link https://discourse.threejs.org/t/roundedrectangle-squircle/28645 RoundedRectangle + Squircle } Geometry\n *\n * @returns A round rectangle geometry\n */\nexport function roundedRectangleGeometry(\n  radius: number,\n  smoothness: number,\n  width: number = 2,\n  height: number = 2\n) {\n  // helper const's\n  const wi = width / 2 - radius; // inner width\n  const hi = height / 2 - radius; // inner height\n  const ul = radius / width; // u left\n  const ur = (width - radius) / width; // u right\n  const vl = radius / height; // v low\n  const vh = (height - radius) / height; // v high\n\n  const positions = [wi, hi, 0, -wi, hi, 0, -wi, -hi, 0, wi, -hi, 0];\n  const uvs = [ur, vh, ul, vh, ul, vl, ur, vl];\n  const n = [\n    3 * (smoothness + 1) + 3,\n    3 * (smoothness + 1) + 4,\n    smoothness + 4,\n    smoothness + 5,\n    2 * (smoothness + 1) + 4,\n    2,\n    1,\n    2 * (smoothness + 1) + 3,\n    3,\n    4 * (smoothness + 1) + 3,\n    4,\n    0,\n  ];\n  const indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(\n    (i) => n[i]\n  );\n\n  let phi, cos, sin, xc, yc, uc, vc, idx;\n\n  for (let i = 0; i < 4; i++) {\n    xc = i < 1 || i > 2 ? wi : -wi;\n    yc = i < 2 ? hi : -hi;\n\n    uc = i < 1 || i > 2 ? ur : ul;\n    vc = i < 2 ? vh : vl;\n\n    for (let j = 0; j <= smoothness; j++) {\n      phi = (Math.PI / 2) * (i + j / smoothness);\n      cos = Math.cos(phi);\n      sin = Math.sin(phi);\n\n      positions.push(xc + radius * cos, yc + radius * sin, 0);\n\n      uvs.push(uc + ul * cos, vc + vl * sin);\n\n      if (j < smoothness) {\n        idx = (smoothness + 1) * i + j + 4;\n        indices.push(i, idx, idx + 1);\n      }\n    }\n  }\n\n  return new BufferGeometry()\n    .setIndex(new BufferAttribute(new Uint32Array(indices), 1))\n    .setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(positions), 3)\n    )\n    .setAttribute(\"uv\", new BufferAttribute(new Float32Array(uvs), 2));\n}\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n} from \"three\";\nimport { GIZMO_AXES, GIZMO_SPHERE_AXES_DISTANCE } from \"./constants\";\n\nimport { setMapColumnOffset } from \"./axesMap\";\n\nexport const axesFaces = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture\n): GizmoAxisObject[] => {\n  const target = new Vector3();\n  const { isSphere, radius, smoothness } = options;\n  const geometry = roundedRectangleGeometry(radius, smoothness);\n\n  return GIZMO_AXES.map((_, i) => {\n    const isPositive = i < 3;\n\n    const axis = GIZMO_AXES[i];\n    const map = i ? texture.clone() : texture;\n\n    setMapColumnOffset(map, i);\n\n    const { enabled, scale, opacity, hover } = options[axis];\n\n    const materialConfig: MeshBasicMaterialParameters = {\n      map,\n      opacity,\n      transparent: true,\n    };\n\n    const face = isSphere\n      ? new Sprite(new SpriteMaterial(materialConfig))\n      : new Mesh(geometry, new MeshBasicMaterial(materialConfig));\n\n    const direction = (isPositive ? axis : axis[1]) as \"x\" | \"y\" | \"z\";\n    face.position[direction] =\n      (isPositive ? 1 : -1) * (isSphere ? GIZMO_SPHERE_AXES_DISTANCE : 1);\n\n    if (!isSphere) face.lookAt(target.copy(face.position).multiplyScalar(1.7));\n\n    face.scale.setScalar(scale);\n    face.renderOrder = 1;\n    face.visible = enabled;\n    face.userData = {\n      scale,\n      opacity,\n      hover,\n    };\n\n    return face;\n  });\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n} from \"three\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\nimport { setMapColumnOffset } from \"./axesMap\";\n\nexport const axesCorners = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture\n) => {\n  const { isSphere, corners } = options;\n\n  if (!corners.enabled) return [];\n\n  const { color, opacity, scale, radius, smoothness, hover } = corners;\n\n  const geometry = isSphere\n    ? null\n    : roundedRectangleGeometry(radius, smoothness);\n\n  const materialConfig: MeshBasicMaterialParameters = {\n    transparent: true,\n    opacity,\n  };\n\n  const positions = [\n    1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, -1, -1, -1,\n    -1, -1,\n  ].map((val) => val * 0.85);\n\n  const target = new Vector3();\n  return Array(positions.length / 3)\n    .fill(0)\n    .map<GizmoAxisObject>((_, i) => {\n      if (isSphere) {\n        const map = texture.clone();\n        setMapColumnOffset(map, 6);\n        materialConfig.map = map;\n      } else {\n        materialConfig.color = color;\n      }\n\n      const corner = isSphere\n        ? new Sprite(new SpriteMaterial(materialConfig))\n        : new Mesh(geometry!, new MeshBasicMaterial(materialConfig));\n\n      const i3 = i * 3;\n      corner.position.set(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n\n      if (isSphere) corner.position.normalize().multiplyScalar(1.7);\n\n      corner.scale.setScalar(scale);\n      corner.lookAt(target.copy(corner.position).multiplyScalar(2));\n      corner.renderOrder = 1;\n\n      corner.userData = {\n        color,\n        opacity,\n        scale,\n        hover,\n      };\n\n      return corner;\n    });\n};\n","import { GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n} from \"three\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\nimport { setMapColumnOffset } from \"./axesMap\";\n\nexport const axesEdges = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture,\n  textureColumn: number\n) => {\n  const { isSphere, edges } = options;\n\n  if (!edges.enabled) return [];\n\n  const { color, opacity, scale, hover, radius, smoothness } = edges;\n\n  const geometry = isSphere\n    ? null\n    : roundedRectangleGeometry(radius, smoothness, 1.2, 0.25);\n\n  const materialConfig: MeshBasicMaterialParameters = {\n    transparent: true,\n    opacity,\n  };\n\n  const positions = [\n    0, 1, 1, 0, -1, 1, 1, 0, 1, -1, 0, 1, 0, 1, -1, 0, -1, -1, 1, 0, -1, -1, 0,\n    -1, 1, 1, 0, 1, -1, 0, -1, 1, 0, -1, -1, 0,\n  ].map((val) => val * 0.925);\n\n  const target = new Vector3();\n  return Array(positions.length / 3)\n    .fill(0)\n    .map<Mesh<any, MeshBasicMaterial> | Sprite>((_, i) => {\n      if (isSphere) {\n        const map = texture.clone();\n        setMapColumnOffset(map, textureColumn);\n        materialConfig.map = map;\n      } else {\n        materialConfig.color = color;\n      }\n\n      const edge = isSphere\n        ? new Sprite(new SpriteMaterial(materialConfig))\n        : new Mesh(geometry!, new MeshBasicMaterial(materialConfig));\n\n      const i3 = i * 3;\n      edge.position.set(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n      if (isSphere) edge.position.normalize().multiplyScalar(1.7);\n      edge.scale.setScalar(scale);\n\n      edge.lookAt(target.copy(edge.position).multiplyScalar(2));\n\n      if (!isSphere && !edge.position.y) edge.rotation.z = Math.PI / 2;\n\n      edge.renderOrder = 1;\n\n      edge.userData = {\n        color,\n        opacity,\n        scale,\n        hover,\n      };\n\n      return edge;\n    });\n};\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  BackSide,\n  BufferGeometry,\n  Mesh,\n  MeshBasicMaterial,\n  SphereGeometry,\n} from \"three\";\nimport { mergeGeometries } from \"three/examples/jsm/utils/BufferGeometryUtils.js\";\n\nexport const gizmoBackground = (\n  faces: GizmoAxisObject[],\n  options: GizmoOptionsFallback\n) => {\n  const {\n    isSphere,\n    background: { enabled, color, opacity, hover },\n  } = options;\n\n  let background: Mesh<any, MeshBasicMaterial>;\n\n  const material = new MeshBasicMaterial({\n    color,\n    side: BackSide,\n    opacity: opacity,\n    transparent: true,\n    depthWrite: false,\n  });\n\n  if (!enabled) return null;\n\n  if (isSphere) {\n    background = new Mesh<BufferGeometry, MeshBasicMaterial>(\n      new SphereGeometry(1.8, 64, 64),\n      material\n    );\n  } else {\n    let geometry!: BufferGeometry;\n\n    faces.forEach((plane) => {\n      const originalScale = plane.scale.x;\n      plane.scale.setScalar(0.9);\n      plane.updateMatrix();\n\n      const planeGeometry = plane.geometry.clone();\n      planeGeometry.applyMatrix4(plane.matrix);\n\n      geometry = !!geometry\n        ? mergeGeometries([geometry, planeGeometry])\n        : planeGeometry;\n\n      plane.scale.setScalar(originalScale);\n    });\n\n    background = new Mesh(geometry, material);\n  }\n\n  background.userData = {\n    color,\n    opacity,\n    hover,\n  };\n\n  return background;\n};\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n","/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nimport {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2\n} from 'three';\n\n\nUniformsLib.line = {\n\n\tworldUnits: { value: 1 },\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashOffset: { value: 0 },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t/* glsl */`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t/* glsl */`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttype: 'LineMaterial',\n\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tthis.isLineMaterial = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget color() {\n\n\t\treturn this.uniforms.diffuse.value;\n\n\t}\n\n\tset color( value ) {\n\n\t\tthis.uniforms.diffuse.value = value;\n\n\t}\n\n\tget worldUnits() {\n\n\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t}\n\n\t}\n\n\tget linewidth() {\n\n\t\treturn this.uniforms.linewidth.value;\n\n\t}\n\n\tset linewidth( value ) {\n\n\t\tif ( ! this.uniforms.linewidth ) return;\n\t\tthis.uniforms.linewidth.value = value;\n\n\t}\n\n\tget dashed() {\n\n\t\treturn 'USE_DASH' in this.defines;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( ( value === true ) !== this.dashed ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_DASH = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_DASH;\n\n\t\t}\n\n\t}\n\n\tget dashScale() {\n\n\t\treturn this.uniforms.dashScale.value;\n\n\t}\n\n\tset dashScale( value ) {\n\n\t\tthis.uniforms.dashScale.value = value;\n\n\t}\n\n\tget dashSize() {\n\n\t\treturn this.uniforms.dashSize.value;\n\n\t}\n\n\tset dashSize( value ) {\n\n\t\tthis.uniforms.dashSize.value = value;\n\n\t}\n\n\tget dashOffset() {\n\n\t\treturn this.uniforms.dashOffset.value;\n\n\t}\n\n\tset dashOffset( value ) {\n\n\t\tthis.uniforms.dashOffset.value = value;\n\n\t}\n\n\tget gapSize() {\n\n\t\treturn this.uniforms.gapSize.value;\n\n\t}\n\n\tset gapSize( value ) {\n\n\t\tthis.uniforms.gapSize.value = value;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( value ) {\n\n\t\tif ( ! this.uniforms ) return;\n\t\tthis.uniforms.opacity.value = value;\n\n\t}\n\n\tget resolution() {\n\n\t\treturn this.uniforms.resolution.value;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tthis.uniforms.resolution.value.copy( value );\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( ! this.defines ) return;\n\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\t\t\tthis.extensions.derivatives = true;\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\t\t\tthis.extensions.derivatives = false;\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nclass LineGeometry extends LineSegmentsGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineGeometry = true;\n\n\t\tthis.type = 'LineGeometry';\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst points = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setPositions( points );\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst colors = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setColors( colors );\n\n\t\treturn this;\n\n\t}\n\n\tfromLine( line ) {\n\n\t\tconst geometry = line.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { LineGeometry };\n","import { LineSegments2 } from '../lines/LineSegments2.js';\nimport { LineGeometry } from '../lines/LineGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n\n\tconstructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLine2 = true;\n\n\t\tthis.type = 'Line2';\n\n\t}\n\n}\n\nexport { Line2 };\n","import { Color, Vector2 } from \"three\";\nimport { Line2 } from \"three/addons/lines/Line2.js\";\nimport { LineGeometry } from \"three/addons/lines/LineGeometry.js\";\nimport { LineMaterial } from \"three/addons/lines/LineMaterial.js\";\nimport { GizmoOptionsFallback } from \"../types\";\nimport { GIZMO_AXES, GIZMO_SPHERE_AXES_DISTANCE } from \"./constants\";\n\nexport const axesLines = (options: GizmoOptionsFallback) => {\n  const colorManager = new Color();\n  const positions: number[] = [];\n  const colors: number[] = [];\n  const { isSphere } = options;\n\n  GIZMO_AXES.forEach((axisName, i) => {\n    const { enabled, line, scale, color } = options[axisName];\n\n    if (!enabled || !line) return;\n\n    const negative = i < 3 ? 1 : -1;\n    const distance = isSphere ? GIZMO_SPHERE_AXES_DISTANCE - scale / 2 : 0.975;\n    const point = distance * negative;\n\n    positions.push(\n      axisName.includes(\"x\") ? point : 0,\n      axisName.includes(\"y\") ? point : 0,\n      axisName.includes(\"z\") ? point : 0,\n      0,\n      0,\n      0\n    );\n\n    const colorArray = colorManager.set(color).toArray();\n    colors.push(...colorArray, ...colorArray);\n  });\n\n  if (!positions.length) return null;\n\n  const geometry = new LineGeometry().setPositions(positions).setColors(colors);\n\n  const material = new LineMaterial({\n    linewidth: options.lineWidth,\n    vertexColors: true,\n    resolution: new Vector2(window.innerWidth, window.innerHeight),\n  });\n\n  return new Line2(geometry, material).computeLineDistances();\n};\n","import { GizmoOptionsFallback, GizmoAxisObject } from \"../types\";\nimport { axesMap } from \"./axesMap\";\nimport { axesFaces } from \"./axesFaces\";\nimport { axesCorners } from \"./axesCorners\";\nimport { axesEdges } from \"./axesEdges\";\nimport { gizmoBackground } from \"./gizmoBackground\";\nimport { axesLines } from \"./axesLines\";\n\nexport const axesObjects = (options: GizmoOptionsFallback) => {\n  const { corners, edges } = options;\n\n  const axes: GizmoAxisObject[] = [];\n  const map = axesMap(options);\n\n  const faces = axesFaces(options, map);\n\n  axes.push(...faces);\n  if (corners.enabled) axes.push(...axesCorners(options, map));\n  if (edges.enabled)\n    axes.push(...axesEdges(options, map, corners.enabled ? 7 : 6));\n\n  const background = gizmoBackground(faces, options);\n\n  const lines = axesLines(options);\n\n  return [axes, background, lines] as const;\n};\n","import { GizmoAxisObject } from \"@lib/types\";\nimport { setMapHoverOffset } from \"./axesMap\";\n\nexport const axisHover = (axis: GizmoAxisObject, hovered: boolean = true) => {\n  const { material, userData } = axis;\n\n  const { opacity, color, scale } = hovered ? userData.hover : userData;\n\n  axis.scale.setScalar(scale);\n  material.opacity = opacity;\n\n  if (material.map) setMapHoverOffset(material.map, hovered);\n  else material.color.set(color);\n};\n","import {\n  Camera,\n  Clock,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  Vector2,\n  Vector3,\n  Vector4,\n  WebGLRenderer,\n} from \"three\";\n\nimport { gizmoDomElement, setDomPlacement } from \"./utils/gizmoDomElement\";\nimport { getDomElement } from \"./utils/getDomElement\";\nimport { updateAxis } from \"./utils/updateAxis\";\nimport { isClick } from \"./utils/isClick\";\nimport { intersectedObjects } from \"./utils/intersectedObjects\";\n\nimport {\n  GizmoOptions,\n  ViewportGizmoEventMap,\n  GizmoAxisOptions,\n  GizmoOptionsFallback,\n  GizmoAxisObject,\n} from \"./types\";\nimport { EPSILON, GIZMO_TURN_RATE } from \"./utils/constants\";\nimport { updateBackground } from \"./utils/updateBackground\";\nimport type { OrbitControls } from \"three/examples/jsm/Addons.js\";\nimport { optionsFallback } from \"./utils/optionsFallback\";\nimport { clamp } from \"three/src/math/MathUtils.js\";\nimport { axesObjects } from \"./utils/axesObjects\";\nimport { axisHover } from \"./utils/axisHover\";\n\nexport type { GizmoOptions, ViewportGizmoEventMap, GizmoAxisOptions };\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _spherical = /*@__PURE__*/ new Spherical();\nconst _vec3 = /*@__PURE__*/ new Vector3();\nconst _vec2 = /*@__PURE__*/ new Vector2();\n\n/**\n * ViewportGizmo is a 3D camera orientation controller that provides a visual interface\n * for changing the camera's viewing angle. It creates a widget that shows the current\n * camera orientation and allows direct manipulation of the view through clicking or dragging.\n *\n * @fires ViewportGizmo#start - Fired when a view change interaction begins\n * @fires ViewportGizmo#change - Fired during view changes\n * @fires ViewportGizmo#end - Fired when a view change interaction ends\n *\n * @extends Object3D\n */\nexport class ViewportGizmo extends Object3D<ViewportGizmoEventMap> {\n  type = \"ViewportGizmo\";\n\n  /** Whether the gizmo is currently active and responding to user input */\n  enabled: boolean = true;\n\n  /** The camera being controlled by this gizmo */\n  camera: OrthographicCamera | PerspectiveCamera;\n\n  /** The WebGLRenderer rendering the gizmo */\n  renderer: WebGLRenderer;\n\n  /** The configuration options */\n  options!: GizmoOptions;\n\n  /** The point around which the camera rotates */\n  target = new Vector3();\n\n  /** Whether view changes should be animated */\n  animated: boolean = true;\n\n  /** The speed of view change animations. Higher values result in faster animations */\n  speed: number = 1;\n\n  /**\n   * Indicates whether the gizmo is currently being animated or not,\n   * Useful when interacting with other camera controllers\n   *\n   * @readonly This value is set internally.\n   **/\n  animating = false;\n\n  private _options!: GizmoOptionsFallback;\n  private _intersections!: GizmoAxisObject[];\n  private _background: Mesh<any, MeshBasicMaterial> | null = null;\n  private _viewport: Vector4 = new Vector4();\n  private _originalViewport: Vector4 = new Vector4();\n  private _originalScissor: Vector4 = new Vector4();\n  private _camera!: Camera;\n  private _container!: HTMLElement;\n  private _domElement!: HTMLElement;\n  private _domRect!: DOMRect;\n  private _dragging: boolean = false;\n  private _distance: number = 0;\n  private _clock: Clock = new Clock();\n  private _targetPosition = new Vector3();\n  private _targetQuaternion = new Quaternion();\n  private _quaternionStart = new Quaternion();\n  private _quaternionEnd = new Quaternion();\n  private _pointerStart = new Vector2();\n  private _focus: GizmoAxisObject | null = null;\n  private _placement!: GizmoOptionsFallback[\"placement\"];\n  private _controls?: OrbitControls;\n  private _controlsListeners?: {\n    start: () => void;\n    end: () => void;\n    change: () => void;\n  };\n\n  /**\n   * Creates a new ViewportGizmo instance.\n   *\n   * @param camera - The camera to be controlled by this gizmo\n   * @param renderer - The WebGL renderer used to render the scene\n   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.\n   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string\n   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'\n   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128\n   * @param options.placement - Position of the gizmo in the viewport\n   *    Options include:\n   *    - `\"top-left\"`\n   *    - `\"top-center\"`\n   *    - `\"top-right\"`\n   *    - `\"center-left\"`\n   *    - `\"center-center\"`\n   *    - `\"center-right\"`\n   *    - `\"bottom-left\"`\n   *    - `\"bottom-center\"`\n   *    - `\"bottom-right\"`\n   * @param options.offset - Offset of the gizmo from container edges in pixels\n   * @param options.offset.left - Offset from the left edge\n   * @param options.offset.top - Offset from the top edge\n   * @param options.offset.right - Offset from the right edge\n   * @param options.offset.bottom - Offset from the bottom edge\n   * @param options.animated - Whether view changes should be animated. Defaults to true\n   * @param options.speed - Animation speed multiplier. Defaults to 1\n   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube\n   * @param options.lineWidth - Width of the axes lines in pixels\n   * @param options.id - HTML `id` attribute for the gizmo container\n   * @param options.className - HTML `class` attribute for the gizmo container\n   * @param options.font - Font configuration for axis labels\n   * @param options.font.family - Font family for axis labels\n   * @param options.font.weight - Font weight for axis labels\n   * @param options.background - Configuration for the background sphere/cube\n   * @param options.background.enabled - Whether to display the background\n   * @param options.background.color - Color of the background in normal state\n   * @param options.background.opacity - Opacity of the background in normal state\n   * @param options.background.hover.color - Color of the background when hovered\n   * @param options.background.hover.opacity - Opacity of the background when hovered\n   * @param options.corners - Configuration for corner indicators\n   * @param options.corners.enabled - Whether to display corner indicators\n   * @param options.corners.color - Base color of corner indicators\n   * @param options.corners.opacity - Opacity of corner indicators\n   * @param options.corners.scale - Scale multiplier for corner indicators\n   * @param options.corners.radius - Radius of corner indicators\n   * @param options.corners.smoothness - Smoothness of corner indicators\n   * @param options.corners.hover.color - Color of corner indicators when hovered\n   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered\n   * @param options.corners.hover.scale - Scale of corner indicators when hovered\n   * @param options.edges - Configuration for edge indicators\n   * @param options.edges.enabled - Whether to display edge indicators\n   * @param options.edges.color - Base color of edge indicators\n   * @param options.edges.opacity - Opacity of edge indicators\n   * @param options.edges.scale - Scale multiplier for edge indicators\n   * @param options.edges.radius - Radius of edge indicators\n   * @param options.edges.smoothness - Smoothness of edge indicators\n   * @param options.edges.hover.color - Color of edge indicators when hovered\n   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered\n   * @param options.edges.hover.scale - Scale of edge indicators when hovered\n   * @param options.x - Configuration for positive X axis/face\n   * @param options.y - Configuration for positive Y axis/face\n   * @param options.z - Configuration for positive Z axis/face\n   * @param options.nx - Configuration for negative X axis/face\n   * @param options.ny - Configuration for negative Y axis/face\n   * @param options.nz - Configuration for negative Z axis/face\n   *\n   * @remarks Axis-specific configuration can also use alias names for cube mode:\n   * - `right` (same as `x`)\n   * - `left` (same as `nx`)\n   * - `top` (same as `y`)\n   * - `bottom` (same as `ny`)\n   * - `front` (same as `z`)\n   * - `back` (same as `nz`)\n   *\n   * For each axis/face configuration, the following options are available:\n   * @param options.AXIS.enabled - Whether to draw the axis\n   * @param options.AXIS.label - Custom text label for the axis\n   * @param options.AXIS.opacity - Axis opacity\n   * @param options.AXIS.scale - Scale multiplier for indicator size\n   * @param options.AXIS.line - Whether to draw the axis line\n   * @param options.AXIS.color - Axis indicator background color\n   * @param options.AXIS.labelColor - Axis label color\n   * @param options.AXIS.border.size - Border size around the axis indicator\n   * @param options.AXIS.border.color - Border color around the axis indicator\n   * @param options.AXIS.hover.color - Fill color on hover\n   * @param options.AXIS.hover.labelColor - Label text color on hover\n   * @param options.AXIS.hover.opacity - Opacity when hovered\n   * @param options.AXIS.hover.scale - Indicator scale when hovered\n   * @param options.AXIS.hover.border.size - Hover border size\n   * @param options.AXIS.hover.border.color - Hover border color\n   */\n  constructor(\n    camera: PerspectiveCamera | OrthographicCamera,\n    renderer: WebGLRenderer,\n    options: GizmoOptions = {}\n  ) {\n    super();\n\n    this.camera = camera;\n    this.renderer = renderer;\n    this.set(options);\n  }\n\n  /** Gets the current placement of the gizmo relative to its container. */\n  get placement(): GizmoOptionsFallback[\"placement\"] {\n    return this._placement;\n  }\n\n  /**\n   * Sets and update the placement of the gizmo relative to its container.\n   *\n   * @param placement - The new placement position\n   */\n  set placement(placement: GizmoOptionsFallback[\"placement\"]) {\n    this._placement = setDomPlacement(this._domElement, placement);\n    this.domUpdate();\n  }\n\n  /**\n   * Regenerates the gizmo with the new options.\n   *\n   * @remarks\n   * - Not recommended for use in real-time rendering or animation loops\n   * - Provides a way to completely rebuild the gizmo with new options\n   * - Can be computationally expensive, so use sparingly\n   */\n  set(options: GizmoOptions = {}) {\n    this.dispose();\n\n    this.options = options;\n    this._options = optionsFallback(options);\n\n    this._camera = this._options.isSphere\n      ? new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 5, 10)\n      : new PerspectiveCamera(26, 1, 5, 10);\n\n    this._camera.position.set(0, 0, 7);\n\n    const [axes, background, lines] = axesObjects(this._options);\n\n    if (background) this.add(background);\n    if (lines) this.add(lines);\n    this.add(...axes);\n\n    this._background = background;\n    this._intersections = axes;\n\n    const { container, animated, speed } = this._options;\n\n    this.animated = animated;\n    this.speed = speed;\n\n    this._container = container\n      ? getDomElement(container as string)\n      : document.body;\n\n    this._domElement = gizmoDomElement(this._options);\n    this._domElement.onpointerdown = (e) => this._onPointerDown(e);\n    this._domElement.onpointermove = (e) => this._onPointerMove(e);\n    this._domElement.onpointerleave = () => this._onPointerLeave();\n\n    this._container.appendChild(this._domElement);\n\n    if (this._controls) this.attachControls(this._controls);\n\n    this.update();\n\n    return this;\n  }\n\n  /**\n   * Renders the gizmo to the screen.\n   * This method handles viewport and scissor management to ensure the gizmo\n   * renders correctly without affecting the main scene rendering.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  render() {\n    if (this.animating) this._animate();\n\n    const { renderer, _viewport } = this;\n\n    const _prevScissorTest = renderer.getScissorTest();\n    const _prevAutoClear = renderer.autoClear;\n\n    renderer.autoClear = false;\n    renderer.setViewport(_viewport);\n    if (_prevScissorTest) renderer.setScissor(_viewport);\n\n    renderer.clear(false, true, false);\n    renderer.render(this, this._camera);\n\n    renderer.setViewport(this._originalViewport);\n    if (_prevScissorTest) renderer.setScissor(this._originalScissor);\n\n    renderer.autoClear = _prevAutoClear;\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's DOM-related properties based on its current position\n   * and size in the document.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  domUpdate() {\n    this._domRect = this._domElement.getBoundingClientRect();\n\n    const renderer = this.renderer;\n    const domRect = this._domRect;\n    const containerRect = renderer.domElement.getBoundingClientRect();\n\n    this._viewport.set(\n      domRect.left - containerRect.left,\n      renderer.domElement.clientHeight -\n        (domRect.top - containerRect.top + domRect.height),\n      domRect.width,\n      domRect.height\n    );\n\n    renderer.getViewport(this._originalViewport);\n    if (renderer.getScissorTest()) renderer.getScissor(this._originalScissor);\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's orientation to match the current camera orientation.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  cameraUpdate() {\n    this._updateOrientation();\n    return this;\n  }\n\n  /**\n   * Performs a complete update of the gizmo, including both DOM and camera-related updates.\n   *\n   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  update(controls: boolean = true) {\n    if (controls && this._controls) this._controls.update();\n    return this.domUpdate().cameraUpdate();\n  }\n\n  /**\n   * Connects OrbitControls with the gizmo, handling interaction states and updates.\n   * Automatically detaches any previously attached controls.\n   *\n   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}\n   */\n  attachControls(controls: OrbitControls) {\n    this.detachControls();\n\n    this.target = controls.target;\n\n    this._controlsListeners = {\n      start: () => (controls.enabled = false),\n      end: () => (controls.enabled = true),\n      change: () => this.update(false),\n    };\n\n    this.addEventListener(\"start\", this._controlsListeners.start);\n    this.addEventListener(\"end\", this._controlsListeners.end);\n    controls.addEventListener(\"change\", this._controlsListeners.change);\n\n    this._controls = controls;\n\n    return this;\n  }\n\n  /** Removes all control event listeners and references. Safe to call multiple times. */\n  detachControls() {\n    if (!this._controlsListeners || !this._controls) return;\n\n    this.target = new Vector3().copy(this._controls.target);\n\n    this.removeEventListener(\"start\", this._controlsListeners.start);\n    this.removeEventListener(\"end\", this._controlsListeners.end);\n\n    this._controls.removeEventListener(\n      \"change\",\n      this._controlsListeners.change\n    );\n\n    this._controlsListeners = undefined;\n    this._controls = undefined;\n\n    return this;\n  }\n\n  /** Cleans up all resources including geometries, materials, textures, and event listeners. */\n  dispose() {\n    this.detachControls();\n\n    this.children.forEach((child) => {\n      this.remove(child);\n      const mesh = child as Mesh<any, MeshBasicMaterial>;\n      mesh.material?.dispose();\n      mesh.material?.map?.dispose();\n      mesh.geometry?.dispose();\n    });\n\n    this._domElement?.remove();\n  }\n\n  /**\n   * Updates the gizmo's orientation either based on the camera or internal state.\n   *\n   * @private\n   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)\n   */\n  private _updateOrientation(fromCamera: boolean = true) {\n    if (fromCamera) {\n      this.quaternion.copy(this.camera.quaternion).invert();\n      this.updateMatrixWorld();\n    }\n\n    updateAxis(this._options, this._intersections, this.camera);\n  }\n\n  /**\n   * Handles the animation of camera position and orientation changes.\n   *\n   * @private\n   */\n  private _animate() {\n    const { position, quaternion } = this.camera;\n\n    position.set(0, 0, 1);\n\n    if (!this.animated) {\n      position\n        .applyQuaternion(this._quaternionEnd)\n        .multiplyScalar(this._distance)\n        .add(this.target);\n\n      quaternion.copy(this._targetQuaternion);\n\n      this._updateOrientation();\n\n      this.animating = false;\n      this.dispatchEvent({ type: \"change\" });\n      this.dispatchEvent({ type: \"end\" });\n      return;\n    }\n\n    const delta = this._clock.getDelta();\n\n    const step = delta * GIZMO_TURN_RATE * this.speed;\n\n    this._quaternionStart.rotateTowards(this._quaternionEnd, step);\n\n    position\n      .applyQuaternion(this._quaternionStart)\n      .multiplyScalar(this._distance)\n      .add(this.target);\n\n    quaternion.rotateTowards(this._targetQuaternion, step);\n\n    this._updateOrientation();\n    requestAnimationFrame(() => this.dispatchEvent({ type: \"change\" }));\n\n    if (this._quaternionStart.angleTo(this._quaternionEnd) < EPSILON) {\n      this.animating = false;\n      this.dispatchEvent({ type: \"end\" });\n    }\n  }\n\n  /**\n   * Sets the camera orientation to look at the target from a specific axis.\n   *\n   * @private\n   * @param position - The axis point position\n   */\n  private _setOrientation(position: Vector3) {\n    const camera = this.camera;\n    const focusPoint = this.target;\n\n    this._targetPosition.copy(position).multiplyScalar(this._distance);\n\n    _matrix\n      .setPosition(this._targetPosition)\n      .lookAt(this._targetPosition, this.position, this.up);\n    this._targetQuaternion.setFromRotationMatrix(_matrix);\n\n    this._targetPosition.add(focusPoint);\n\n    _matrix.lookAt(this._targetPosition, focusPoint, this.up);\n    this._quaternionEnd.setFromRotationMatrix(_matrix);\n\n    _matrix\n      .setPosition(camera.position)\n      .lookAt(camera.position, focusPoint, this.up);\n    this._quaternionStart.setFromRotationMatrix(_matrix);\n\n    this.animating = true;\n    this._clock.start();\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Handles the pointer down event for starting drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerDown(e: PointerEvent) {\n    if (!this.enabled) return;\n\n    const drag = (e: PointerEvent) => {\n      if (!this._dragging) {\n        if (isClick(e, this._pointerStart)) return;\n        this._dragging = true;\n      }\n\n      const pointerAngle = _vec2\n        .set(e.clientX, e.clientY)\n        .sub(this._pointerStart)\n        .multiplyScalar((1 / this._domRect.width) * Math.PI);\n\n      const spherical = _spherical.setFromVector3(\n        _vec3.subVectors(this.camera.position, this.target)\n      );\n\n      spherical.theta = initialTheta - pointerAngle.x;\n      spherical.phi = clamp(\n        initialPhi - pointerAngle.y,\n        EPSILON,\n        Math.PI - EPSILON\n      );\n\n      this.camera.position.setFromSpherical(spherical).add(this.target);\n      this.camera.lookAt(this.target);\n\n      this.quaternion.copy(this.camera.quaternion).invert();\n\n      this._updateOrientation(false);\n      this.dispatchEvent({ type: \"change\" });\n    };\n\n    const endDrag = () => {\n      document.removeEventListener(\"pointermove\", drag, false);\n      document.removeEventListener(\"pointerup\", endDrag, false);\n\n      if (!this._dragging) return this._handleClick(e);\n\n      if (this._focus) {\n        axisHover(this._focus, false);\n        this._focus = null;\n      }\n\n      this._dragging = false;\n      this.dispatchEvent({ type: \"end\" });\n    };\n\n    if (this.animating) return;\n\n    e.preventDefault();\n    this._pointerStart.set(e.clientX, e.clientY);\n\n    const initialSpherical = new Spherical().setFromVector3(\n      _vec3.subVectors(this.camera.position, this.target)\n    );\n    const initialTheta = initialSpherical.theta;\n    const initialPhi = initialSpherical.phi;\n    this._distance = initialSpherical.radius;\n\n    document.addEventListener(\"pointermove\", drag, false);\n    document.addEventListener(\"pointerup\", endDrag, false);\n\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Handles pointer move events for hover effects and drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerMove(e: PointerEvent) {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._background) updateBackground(this._background, true);\n\n    this._handleHover(e);\n  }\n\n  /**\n   * Handles pointer leave events to reset hover states.\n   *\n   * @private\n   */\n  private _onPointerLeave() {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._background) updateBackground(this._background, false);\n    if (this._focus) axisHover(this._focus, false);\n\n    this._domElement.style.cursor = \"\";\n  }\n\n  /**\n   * Handles click events for axis selection.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleClick(e: PointerEvent) {\n    const intersection = intersectedObjects(\n      e,\n      this._domRect,\n      this._camera,\n      this._intersections\n    );\n\n    if (this._focus) {\n      axisHover(this._focus, false);\n      this._focus = null;\n    }\n\n    if (!intersection) return;\n\n    this._setOrientation(intersection.object.position);\n\n    this.dispatchEvent({ type: \"change\" });\n  }\n\n  /**\n   * Handles hover effects for interactive elements.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleHover(e: PointerEvent) {\n    const intersection = intersectedObjects(\n      e,\n      this._domRect,\n      this._camera,\n      this._intersections\n    );\n\n    const object = intersection?.object || null;\n\n    if (this._focus === object) return;\n\n    this._domElement.style.cursor = object ? \"pointer\" : \"\";\n\n    if (this._focus) axisHover(this._focus, false);\n\n    if ((this._focus = object)) axisHover(object, true);\n    else updateAxis(this._options, this._intersections, this.camera);\n  }\n}\n"],"names":["setDomPlacement","domElement","placement","y","x","gizmoDomElement","size","offset","id","className","div","top","left","right","bottom","getDomElement","element","clamp","value","min","max","axisMap","point","Vector3","updateAxis","isSphere","axes","camera","axis","positiveIndex","negativeIndex","object","opacity","isClick","e","startCoords","threshold","_raycaster","Raycaster","_mouse","Vector2","intersectedObjects","event","domRect","intersections","intersects","intersection","EPSILON","GIZMO_TURN_RATE","AXES","GIZMO_AXES","GIZMO_FACES","GIZMO_SPHERE_AXES_DISTANCE","updateBackground","background","hovered","material","userData","color","deepClone","obj","optionsFallback","options","type","resolution","container","face","index","axesFallback","negativeAxesFallback","assignNestedDefaults","target","defaultObjects","defaults","key","axesMap","colorManager","Color","doubleOffset","radius","font","corners","edges","canvas","ctx","fontStyle","fontYFix","getFontStyle","label","labelColor","border","hoverColor","hoverLabel","hoverBorder","drawAxis","colsCount","offsetX","offsetY","cellHeight","map","CanvasTexture","SRGBColorSpace","RepeatWrapping","drawRoundRectPath","halfBorderWidth","drawText","text","a","b","_a","_b","family","weight","square","fontSize","textWidth","textHeight","measure","yFix","scaleFactor","finalFontSize","setMapHoverOffset","hover","setMapColumnOffset","col","roundedRectangleGeometry","smoothness","width","height","wi","hi","ul","ur","vl","vh","positions","uvs","n","indices","i","phi","cos","sin","xc","yc","uc","vc","idx","j","BufferGeometry","BufferAttribute","axesFaces","texture","geometry","_","isPositive","enabled","scale","materialConfig","Sprite","SpriteMaterial","Mesh","MeshBasicMaterial","direction","axesCorners","val","corner","i3","axesEdges","textureColumn","edge","mergeGeometries","geometries","useGroups","isIndexed","attributesUsed","morphAttributesUsed","attributes","morphAttributes","morphTargetsRelative","mergedGeometry","attributesCount","name","count","indexOffset","mergedIndex","mergedAttribute","mergeAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","gpuType","arrayLength","attribute","array","result","tupleOffset","l","c","gizmoBackground","faces","BackSide","SphereGeometry","plane","originalScale","planeGeometry","_box","Box3","_vector","LineSegmentsGeometry","InstancedBufferGeometry","Float32BufferAttribute","matrix","start","end","lineSegments","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","mesh","WireframeGeometry","Sphere","center","maxRadiusSq","il","UniformsLib","ShaderLib","UniformsUtils","LineMaterial","ShaderMaterial","parameters","_start","_end","_start4","Vector4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","distance","raycastWorldUnits","matrixWorld","instanceStart","instanceEnd","segmentCount","pointOnLine","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","lineDistances","instanceDistanceBuffer","raycaster","worldUnits","sphereMargin","distanceToSphere","boxMargin","distanceToBox","LineGeometry","length","points","line","Line2","axesLines","axisName","negative","colorArray","axesObjects","lines","axisHover","_matrix","_spherical","Spherical","_vec3","_vec2","ViewportGizmo","Object3D","renderer","__publicField","Clock","Quaternion","OrthographicCamera","PerspectiveCamera","animated","speed","_viewport","_prevScissorTest","_prevAutoClear","containerRect","controls","child","_c","_d","fromCamera","position","quaternion","step","focusPoint","drag","pointerAngle","spherical","initialTheta","initialPhi","endDrag","initialSpherical"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqNV;AAAA;AAAA,IACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgKX;AAEA,MAAMG,WAAqBC,GAAe;AAAA,EAEzC,YAAaC,GAAa;AAEzB,UAAO;AAAA,MAEN,MAAM;AAAA,MAEN,UAAUH,GAAc,MAAOD,GAAW,KAAS,QAAU;AAAA,MAE7D,cAAcA,GAAW,KAAS;AAAA,MAClC,gBAAgBA,GAAW,KAAS;AAAA,MAEpC,UAAU;AAAA;AAAA,IAEb,CAAK,GAEH,KAAK,iBAAiB,IAEtB,KAAK,UAAWI,CAAY;AAAA,EAE9B;AAAA,EAEC,IAAI,QAAQ;AAEX,WAAO,KAAK,SAAS,QAAQ;AAAA,EAE/B;AAAA,EAEC,IAAI,MAAOzN,GAAQ;AAElB,SAAK,SAAS,QAAQ,QAAQA;AAAA,EAEhC;AAAA,EAEC,IAAI,aAAa;AAEhB,WAAO,iBAAiB,KAAK;AAAA,EAE/B;AAAA,EAEC,IAAI,WAAYA,GAAQ;AAEvB,IAAKA,MAAU,KAEd,KAAK,QAAQ,cAAc,KAI3B,OAAO,KAAK,QAAQ;AAAA,EAIvB;AAAA,EAEC,IAAI,YAAY;AAEf,WAAO,KAAK,SAAS,UAAU;AAAA,EAEjC;AAAA,EAEC,IAAI,UAAWA,GAAQ;AAEtB,IAAO,KAAK,SAAS,cACrB,KAAK,SAAS,UAAU,QAAQA;AAAA,EAElC;AAAA,EAEC,IAAI,SAAS;AAEZ,WAAO,cAAc,KAAK;AAAA,EAE5B;AAAA,EAEC,IAAI,OAAQA,GAAQ;AAEnB,IAAOA,MAAU,OAAW,KAAK,WAEhC,KAAK,cAAc,KAIfA,MAAU,KAEd,KAAK,QAAQ,WAAW,KAIxB,OAAO,KAAK,QAAQ;AAAA,EAIvB;AAAA,EAEC,IAAI,YAAY;AAEf,WAAO,KAAK,SAAS,UAAU;AAAA,EAEjC;AAAA,EAEC,IAAI,UAAWA,GAAQ;AAEtB,SAAK,SAAS,UAAU,QAAQA;AAAA,EAElC;AAAA,EAEC,IAAI,WAAW;AAEd,WAAO,KAAK,SAAS,SAAS;AAAA,EAEhC;AAAA,EAEC,IAAI,SAAUA,GAAQ;AAErB,SAAK,SAAS,SAAS,QAAQA;AAAA,EAEjC;AAAA,EAEC,IAAI,aAAa;AAEhB,WAAO,KAAK,SAAS,WAAW;AAAA,EAElC;AAAA,EAEC,IAAI,WAAYA,GAAQ;AAEvB,SAAK,SAAS,WAAW,QAAQA;AAAA,EAEnC;AAAA,EAEC,IAAI,UAAU;AAEb,WAAO,KAAK,SAAS,QAAQ;AAAA,EAE/B;AAAA,EAEC,IAAI,QAASA,GAAQ;AAEpB,SAAK,SAAS,QAAQ,QAAQA;AAAA,EAEhC;AAAA,EAEC,IAAI,UAAU;AAEb,WAAO,KAAK,SAAS,QAAQ;AAAA,EAE/B;AAAA,EAEC,IAAI,QAASA,GAAQ;AAEpB,IAAO,KAAK,aACZ,KAAK,SAAS,QAAQ,QAAQA;AAAA,EAEhC;AAAA,EAEC,IAAI,aAAa;AAEhB,WAAO,KAAK,SAAS,WAAW;AAAA,EAElC;AAAA,EAEC,IAAI,WAAYA,GAAQ;AAEvB,SAAK,SAAS,WAAW,MAAM,KAAMA,CAAO;AAAA,EAE9C;AAAA,EAEC,IAAI,kBAAkB;AAErB,WAAO,2BAA2B,KAAK;AAAA,EAEzC;AAAA,EAEC,IAAI,gBAAiBA,GAAQ;AAE5B,IAAO,KAAK,YAELA,MAAU,OAAW,KAAK,oBAEhC,KAAK,cAAc,KAIfA,MAAU,MAEd,KAAK,QAAQ,wBAAwB,IACrC,KAAK,WAAW,cAAc,OAI9B,OAAO,KAAK,QAAQ,uBACpB,KAAK,WAAW,cAAc;AAAA,EAIjC;AAEA;ACzlBA,MAAM0N,KAAS,IAAIrN,EAAS,GACtBsN,KAAO,IAAItN,EAAS,GAEpBuN,IAAU,IAAIC,EAAS,GACvBC,IAAQ,IAAID,EAAS,GAErBE,IAAY,IAAIF,EAAS,GACzBG,KAAa,IAAI3N,EAAS,GAC1B4N,KAAY,IAAIC,GAAS,GACzBC,IAAQ,IAAIC,GAAO,GACnBC,KAAgB,IAAIhO,EAAS,GAE7B0L,IAAO,IAAIC,GAAM,GACjBsC,KAAU,IAAItB,GAAQ,GACtBuB,IAAqB,IAAIV,EAAS;AAExC,IAAIW,GAAMC;AAIV,SAASC,GAAwBjO,GAAQkO,GAAU7L,GAAa;AAK/D,SAAAyL,EAAmB,IAAK,GAAG,GAAG,CAAEI,GAAU,GAAM,aAAclO,EAAO,gBAAkB,GACvF8N,EAAmB,eAAgB,IAAMA,EAAmB,CAAG,GAC/DA,EAAmB,IAAIE,IAAa3L,EAAW,OAC/CyL,EAAmB,IAAIE,IAAa3L,EAAW,QAC/CyL,EAAmB,aAAc9N,EAAO,uBAAyB,GACjE8N,EAAmB,eAAgB,IAAMA,EAAmB,CAAG,GAExD,KAAK,IAAK,KAAK,IAAKA,EAAmB,GAAGA,EAAmB,EAAK;AAE1E;AAEA,SAASK,GAAmBpC,GAAc7K,GAAa;AAEtD,QAAMkN,IAAcrC,EAAa,aAC3BjE,IAAWiE,EAAa,UACxBsC,IAAgBvG,EAAS,WAAW,eACpCwG,IAAcxG,EAAS,WAAW,aAClCyG,IAAe,KAAK,IAAKzG,EAAS,eAAeuG,EAAc,KAAO;AAE5E,WAAUrH,IAAI,GAAG6D,IAAI0D,GAAcvH,IAAI6D,GAAG7D,KAAO;AAEhD,IAAA0G,EAAM,MAAM,oBAAqBW,GAAerH,CAAG,GACnD0G,EAAM,IAAI,oBAAqBY,GAAatH,CAAG,GAE/C0G,EAAM,aAAcU,CAAa;AAEjC,UAAMI,IAAc,IAAI5O,EAAS,GAC3BD,IAAQ,IAAIC,EAAS;AAE3B,IAAAmO,EAAK,oBAAqBL,EAAM,OAAOA,EAAM,KAAK/N,GAAO6O,CAAa,GACrD7O,EAAM,WAAY6O,CAAa,IAAGR,IAAa,OAI/D9M,EAAW,KAAM;AAAA,MAChB,OAAAvB;AAAA,MACA,aAAA6O;AAAA,MACA,UAAUT,EAAK,OAAO,WAAYpO,CAAO;AAAA,MACzC,QAAQoM;AAAA,MACR,MAAM;AAAA,MACN,WAAW/E;AAAA,MACX,IAAI;AAAA,MACJ,KAAK;AAAA,IACT,CAAM;AAAA,EAIN;AAEA;AAEA,SAASyH,GAAoB1C,GAAc/L,GAAQkB,GAAa;AAE/D,QAAMwN,IAAmB1O,EAAO,kBAE1BqC,IADW0J,EAAa,SACF,YACtBqC,IAAcrC,EAAa,aAE3BjE,IAAWiE,EAAa,UACxBsC,IAAgBvG,EAAS,WAAW,eACpCwG,IAAcxG,EAAS,WAAW,aAClCyG,IAAe,KAAK,IAAKzG,EAAS,eAAeuG,EAAc,KAAO,GAEtEM,IAAO,CAAE3O,EAAO;AAOtB,EAAA+N,EAAK,GAAI,GAAGT,CAAW,GAGvBA,EAAU,IAAI,GACdA,EAAU,aAActN,EAAO,kBAAoB,GACnDsN,EAAU,aAAcoB,CAAkB,GAC1CpB,EAAU,eAAgB,IAAIA,EAAU,CAAG,GAG3CA,EAAU,KAAKjL,EAAW,IAAI,GAC9BiL,EAAU,KAAKjL,EAAW,IAAI,GAC9BiL,EAAU,IAAI,GAEdC,GAAW,KAAMD,CAAW,GAE5BE,GAAU,iBAAkBxN,EAAO,oBAAoBoO,CAAa;AAEpE,WAAUpH,IAAI,GAAG6D,IAAI0D,GAAcvH,IAAI6D,GAAG7D,KAAO;AAchD,QAZAmG,EAAQ,oBAAqBkB,GAAerH,CAAG,GAC/CqG,EAAM,oBAAqBiB,GAAatH,CAAG,GAE3CmG,EAAQ,IAAI,GACZE,EAAM,IAAI,GAGVF,EAAQ,aAAcK,EAAW,GACjCH,EAAM,aAAcG,EAAW,GAGJL,EAAQ,IAAIwB,KAAQtB,EAAM,IAAIsB;AAGxD;AAKD,QAAKxB,EAAQ,IAAIwB,GAAO;AAEvB,YAAMC,IAAYzB,EAAQ,IAAIE,EAAM,GAC9BwB,KAAM1B,EAAQ,IAAIwB,KAASC;AACjC,MAAAzB,EAAQ,KAAME,GAAOwB,CAAG;AAAA,IAE3B,WAAcxB,EAAM,IAAIsB,GAAO;AAE5B,YAAMC,IAAYvB,EAAM,IAAIF,EAAQ,GAC9B0B,KAAMxB,EAAM,IAAIsB,KAASC;AAC/B,MAAAvB,EAAM,KAAMF,GAAS0B,CAAG;AAAA,IAE3B;AAGE,IAAA1B,EAAQ,aAAcuB,CAAkB,GACxCrB,EAAM,aAAcqB,CAAkB,GAGtCvB,EAAQ,eAAgB,IAAIA,EAAQ,CAAG,GACvCE,EAAM,eAAgB,IAAIA,EAAM,CAAG,GAGnCF,EAAQ,KAAK9K,EAAW,IAAI,GAC5B8K,EAAQ,KAAK9K,EAAW,IAAI,GAE5BgL,EAAM,KAAKhL,EAAW,IAAI,GAC1BgL,EAAM,KAAKhL,EAAW,IAAI,GAG1BqL,EAAM,MAAM,KAAMP,CAAS,GAC3BO,EAAM,MAAM,IAAI,GAEhBA,EAAM,IAAI,KAAML,CAAO,GACvBK,EAAM,IAAI,IAAI;AAGd,UAAMoB,IAAQpB,EAAM,6BAA8BH,IAAY,EAAM;AACpE,IAAAG,EAAM,GAAIoB,GAAOlB,EAAe;AAGhC,UAAMmB,IAAOC,GAAU,KAAM7B,EAAQ,GAAGE,EAAM,GAAGyB,CAAO,GAClDG,IAAgBF,KAAQ,MAAOA,KAAQ,GAEvCG,IAAW3B,GAAW,WAAYK,EAAe,IAAGI,IAAa;AAEvE,QAAKiB,KAAiBC,GAAW;AAEhC,MAAAxB,EAAM,MAAM,oBAAqBW,GAAerH,CAAG,GACnD0G,EAAM,IAAI,oBAAqBY,GAAatH,CAAG,GAE/C0G,EAAM,MAAM,aAAcU,CAAa,GACvCV,EAAM,IAAI,aAAcU,CAAa;AAErC,YAAMI,IAAc,IAAI5O,EAAS,GAC3BD,IAAQ,IAAIC,EAAS;AAE3B,MAAAmO,EAAK,oBAAqBL,EAAM,OAAOA,EAAM,KAAK/N,GAAO6O,CAAa,GAEtEtN,EAAW,KAAM;AAAA,QAChB,OAAOvB;AAAA,QACP,aAAa6O;AAAA,QACb,UAAUT,EAAK,OAAO,WAAYpO,CAAO;AAAA,QACzC,QAAQoM;AAAA,QACR,MAAM;AAAA,QACN,WAAW/E;AAAA,QACX,IAAI;AAAA,QACJ,KAAK;AAAA,MACT,CAAM;AAAA,IAEN;AAAA,EAEA;AAEA;AAEA,MAAMmI,WAAsB7G,EAAK;AAAA,EAEhC,YAAaR,IAAW,IAAI2D,GAAsB,GAAE5J,IAAW,IAAIiL,GAAc,EAAE,OAAO,KAAK,WAAW,SAAU,CAAA,GAAK;AAExH,UAAOhF,GAAUjG,CAAU,GAE3B,KAAK,kBAAkB,IAEvB,KAAK,OAAO;AAAA,EAEd;AAAA;AAAA,EAIC,uBAAuB;AAEtB,UAAMiG,IAAW,KAAK,UAEhBuG,IAAgBvG,EAAS,WAAW,eACpCwG,IAAcxG,EAAS,WAAW,aAClCsH,IAAgB,IAAI,aAAc,IAAIf,EAAc,KAAO;AAEjE,aAAUrH,IAAI,GAAGS,IAAI,GAAGoD,IAAIwD,EAAc,OAAOrH,IAAI6D,GAAG7D,KAAMS,KAAK;AAElE,MAAAwF,GAAO,oBAAqBoB,GAAerH,CAAG,GAC9CkG,GAAK,oBAAqBoB,GAAatH,CAAG,GAE1CoI,EAAe3H,CAAG,IAAKA,MAAM,IAAM,IAAI2H,EAAe3H,IAAI,CAAG,GAC7D2H,EAAe3H,IAAI,KAAM2H,EAAe3H,KAAMwF,GAAO,WAAYC,EAAM;AAIxE,UAAMmC,IAAyB,IAAIpD,GAA4BmD,GAAe,GAAG,CAAC;AAElF,WAAAtH,EAAS,aAAc,yBAAyB,IAAIoE,EAA4BmD,GAAwB,GAAG,CAAC,IAC5GvH,EAAS,aAAc,uBAAuB,IAAIoE,EAA4BmD,GAAwB,GAAG,CAAC,IAEnG;AAAA,EAET;AAAA,EAEC,QAASC,GAAWpO,GAAa;AAEhC,UAAMqO,IAAa,KAAK,SAAS,YAC3BvP,IAASsP,EAAU;AAEzB,IAAKtP,MAAW,QAAQ,CAAEuP,KAEzB,QAAQ,MAAO,+HAAiI;AAIjJ,UAAM9O,IAAc6O,EAAU,OAAO,UAAU,UAAcA,EAAU,OAAO,MAAM,aAAa;AAEjG,IAAAvB,IAAOuB,EAAU;AAEjB,UAAMlB,IAAc,KAAK,aACnBtG,IAAW,KAAK,UAChBjG,IAAW,KAAK;AAEtB,IAAAmM,IAAanM,EAAS,YAAYpB,GAG7BqH,EAAS,mBAAmB,QAEhCA,EAAS,sBAAuB,GAIjC+F,GAAQ,KAAM/F,EAAS,cAAc,EAAG,aAAcsG,CAAa;AAGnE,QAAIoB;AACJ,QAAKD;AAEJ,MAAAC,IAAexB,IAAa;AAAA,SAEtB;AAEN,YAAMyB,IAAmB,KAAK,IAAKzP,EAAO,MAAM6N,GAAQ,gBAAiBE,EAAK,OAAU;AACxF,MAAAyB,IAAevB,GAAwBjO,GAAQyP,GAAkB5N,EAAS,UAAY;AAAA,IAEzF;AAIE,QAFAgM,GAAQ,UAAU2B,GAEbzB,EAAK,iBAAkBF,EAAO,MAAO;AAEzC;AAKD,IAAK/F,EAAS,gBAAgB,QAE7BA,EAAS,mBAAoB,GAI9BwD,EAAK,KAAMxD,EAAS,WAAW,EAAG,aAAcsG,CAAa;AAG7D,QAAIsB;AACJ,QAAKH;AAEJ,MAAAG,IAAY1B,IAAa;AAAA,SAEnB;AAEN,YAAM2B,IAAgB,KAAK,IAAK3P,EAAO,MAAMsL,EAAK,gBAAiByC,EAAK,OAAU;AAClF,MAAA2B,IAAYzB,GAAwBjO,GAAQ2P,GAAe9N,EAAS,UAAY;AAAA,IAEnF;AAIE,IAFAyJ,EAAK,eAAgBoE,CAAW,GAE3B3B,EAAK,cAAezC,CAAI,MAAO,OAM/BiE,IAEJpB,GAAmB,MAAMjN,CAAY,IAIrCuN,GAAoB,MAAMzO,GAAQkB,CAAY;AAAA,EAIjD;AAEA;ACpWA,MAAM0O,WAAqBnE,GAAqB;AAAA,EAE/C,cAAc;AAEb,UAAO,GAEP,KAAK,iBAAiB,IAEtB,KAAK,OAAO;AAAA,EAEd;AAAA,EAEC,aAAcf,GAAQ;AAIrB,UAAMmF,IAASnF,EAAM,SAAS,GACxBoF,IAAS,IAAI,aAAc,IAAID,CAAQ;AAE7C,aAAU,IAAI,GAAG,IAAIA,GAAQ,KAAK;AAEjC,MAAAC,EAAQ,IAAI,KAAMpF,EAAO,CAAG,GAC5BoF,EAAQ,IAAI,IAAI,CAAG,IAAGpF,EAAO,IAAI,CAAG,GACpCoF,EAAQ,IAAI,IAAI,CAAG,IAAGpF,EAAO,IAAI,CAAG,GAEpCoF,EAAQ,IAAI,IAAI,CAAG,IAAGpF,EAAO,IAAI,CAAG,GACpCoF,EAAQ,IAAI,IAAI,CAAG,IAAGpF,EAAO,IAAI,CAAG,GACpCoF,EAAQ,IAAI,IAAI,CAAG,IAAGpF,EAAO,IAAI,CAAG;AAIrC,iBAAM,aAAcoF,CAAQ,GAErB;AAAA,EAET;AAAA,EAEC,UAAWpF,GAAQ;AAIlB,UAAMmF,IAASnF,EAAM,SAAS,GACxByB,IAAS,IAAI,aAAc,IAAI0D,CAAQ;AAE7C,aAAU,IAAI,GAAG,IAAIA,GAAQ,KAAK;AAEjC,MAAA1D,EAAQ,IAAI,KAAMzB,EAAO,CAAG,GAC5ByB,EAAQ,IAAI,IAAI,CAAG,IAAGzB,EAAO,IAAI,CAAG,GACpCyB,EAAQ,IAAI,IAAI,CAAG,IAAGzB,EAAO,IAAI,CAAG,GAEpCyB,EAAQ,IAAI,IAAI,CAAG,IAAGzB,EAAO,IAAI,CAAG,GACpCyB,EAAQ,IAAI,IAAI,CAAG,IAAGzB,EAAO,IAAI,CAAG,GACpCyB,EAAQ,IAAI,IAAI,CAAG,IAAGzB,EAAO,IAAI,CAAG;AAIrC,iBAAM,UAAWyB,CAAQ,GAElB;AAAA,EAET;AAAA,EAEC,SAAU4D,GAAO;AAEhB,UAAMjI,IAAWiI,EAAK;AAEtB,gBAAK,aAAcjI,EAAS,WAAW,SAAS,KAAK,GAI9C;AAAA,EAET;AAEA;ACxEA,MAAMkI,WAAcb,GAAc;AAAA,EAEjC,YAAarH,IAAW,IAAI8H,GAAc,GAAE/N,IAAW,IAAIiL,GAAc,EAAE,OAAO,KAAK,WAAW,SAAU,CAAA,GAAK;AAEhH,UAAOhF,GAAUjG,CAAU,GAE3B,KAAK,UAAU,IAEf,KAAK,OAAO;AAAA,EAEd;AAEA;ACTa,MAAAoO,KAAY,CAAC9N,MAAkC;AACpD,QAAAc,IAAe,IAAIC,GAAM,GACzB0D,IAAsB,CAAC,GACvBuF,IAAmB,CAAC,GACpB,EAAE,UAAArM,MAAaqC;AAwBjB,MAtBOZ,EAAA,QAAQ,CAAC2O,GAAUlJ,MAAM;AAClC,UAAM,EAAE,SAAAiB,GAAS,MAAA8H,GAAM,OAAA7H,GAAO,OAAAnG,EAAM,IAAII,EAAQ+N,CAAQ;AAEpD,QAAA,CAACjI,KAAW,CAAC8H,EAAM;AAEjB,UAAAI,IAAWnJ,IAAI,IAAI,IAAI,IAEvBrH,KADWG,IAAW2B,KAA6ByG,IAAQ,IAAI,SAC5CiI;AAEf,IAAAvJ,EAAA;AAAA,MACRsJ,EAAS,SAAS,GAAG,IAAIvQ,IAAQ;AAAA,MACjCuQ,EAAS,SAAS,GAAG,IAAIvQ,IAAQ;AAAA,MACjCuQ,EAAS,SAAS,GAAG,IAAIvQ,IAAQ;AAAA,MACjC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAMyQ,IAAanN,EAAa,IAAIlB,CAAK,EAAE,QAAQ;AACnD,IAAAoK,EAAO,KAAK,GAAGiE,GAAY,GAAGA,CAAU;AAAA,EAAA,CACzC,GAEG,CAACxJ,EAAU,OAAe,QAAA;AAExB,QAAAkB,IAAW,IAAI8H,GAAa,EAAE,aAAahJ,CAAS,EAAE,UAAUuF,CAAM,GAEtEtK,IAAW,IAAIiL,GAAa;AAAA,IAChC,WAAW3K,EAAQ;AAAA,IACnB,cAAc;AAAA,IACd,YAAY,IAAItB,EAAQ,OAAO,YAAY,OAAO,WAAW;AAAA,EAAA,CAC9D;AAED,SAAO,IAAImP,GAAMlI,GAAUjG,CAAQ,EAAE,qBAAqB;AAC5D,GCtCawO,KAAc,CAAClO,MAAkC;AACtD,QAAA,EAAE,SAAAmB,GAAS,OAAAC,EAAA,IAAUpB,GAErBpC,IAA0B,CAAC,GAC3ByE,IAAMxB,GAAQb,CAAO,GAErB6I,IAAQpD,GAAUzF,GAASqC,CAAG;AAE/B,EAAAzE,EAAA,KAAK,GAAGiL,CAAK,GACd1H,EAAQ,WAAcvD,EAAA,KAAK,GAAG0I,GAAYtG,GAASqC,CAAG,CAAC,GACvDjB,EAAM,WACHxD,EAAA,KAAK,GAAG8I,GAAU1G,GAASqC,GAAKlB,EAAQ,UAAU,IAAI,CAAC,CAAC;AAEzD,QAAA3B,IAAaoJ,GAAgBC,GAAO7I,CAAO,GAE3CmO,IAAQL,GAAU9N,CAAO;AAExB,SAAA,CAACpC,GAAM4B,GAAY2O,CAAK;AACjC,GCvBaC,IAAY,CAACtQ,GAAuB2B,IAAmB,OAAS;AACrE,QAAA,EAAE,UAAAC,GAAU,UAAAC,EAAA,IAAa7B,GAEzB,EAAE,SAAAI,GAAS,OAAA0B,GAAO,OAAAmG,EAAU,IAAAtG,IAAUE,EAAS,QAAQA;AAExD,EAAA7B,EAAA,MAAM,UAAUiI,CAAK,GAC1BrG,EAAS,UAAUxB,GAEfwB,EAAS,MAAuBiE,GAAAjE,EAAS,KAAKD,CAAO,IACpDC,EAAS,MAAM,IAAIE,CAAK;AAC/B,GC2BMyO,wBAA4B/C,GAAQ,GACpCgD,yBAA+BC,GAAU,GACzCC,yBAA0B/Q,EAAQ,GAClCgR,yBAA0B/P,EAAQ;AAajC,MAAMgQ,WAAsBC,GAAgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuJjE,YACE9Q,GACA+Q,GACA5O,IAAwB,CAAA,GACxB;AACM,UAAA;AA3JR,IAAA6O,EAAA,cAAO;AAGP;AAAA,IAAAA,EAAA,iBAAmB;AAGnB;AAAA,IAAAA,EAAA;AAGA;AAAA,IAAAA,EAAA;AAGA;AAAA,IAAAA,EAAA;AAGA;AAAA,IAAAA,EAAA,gBAAS,IAAIpR,EAAQ;AAGrB;AAAA,IAAAoR,EAAA,kBAAoB;AAGpB;AAAA,IAAAA,EAAA,eAAgB;AAQhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,EAAA,mBAAY;AAEJ,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA,qBAAmD;AACnD,IAAAA,EAAA,mBAAqB,IAAI5D,EAAQ;AACjC,IAAA4D,EAAA,2BAA6B,IAAI5D,EAAQ;AACzC,IAAA4D,EAAA,0BAA4B,IAAI5D,EAAQ;AACxC,IAAA4D,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA,mBAAqB;AACrB,IAAAA,EAAA,mBAAoB;AACpB,IAAAA,EAAA,gBAAgB,IAAIC,GAAM;AAC1B,IAAAD,EAAA,yBAAkB,IAAIpR,EAAQ;AAC9B,IAAAoR,EAAA,2BAAoB,IAAIE,GAAW;AACnC,IAAAF,EAAA,0BAAmB,IAAIE,GAAW;AAClC,IAAAF,EAAA,wBAAiB,IAAIE,GAAW;AAChC,IAAAF,EAAA,uBAAgB,IAAInQ,EAAQ;AAC5B,IAAAmQ,EAAA,gBAAiC;AACjC,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AAyGN,SAAK,SAAShR,GACd,KAAK,WAAW+Q,GAChB,KAAK,IAAI5O,CAAO;AAAA,EAAA;AAAA;AAAA,EAIlB,IAAI,YAA+C;AACjD,WAAO,KAAK;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQd,IAAI,UAAU5D,GAA8C;AAC1D,SAAK,aAAaF,GAAgB,KAAK,aAAaE,CAAS,GAC7D,KAAK,UAAU;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWjB,IAAI4D,IAAwB,IAAI;AAC9B,SAAK,QAAQ,GAEb,KAAK,UAAUA,GACV,KAAA,WAAWD,GAAgBC,CAAO,GAEvC,KAAK,UAAU,KAAK,SAAS,WACzB,IAAIgP,GAAmB,MAAM,KAAK,KAAK,MAAM,GAAG,EAAE,IAClD,IAAIC,GAAkB,IAAI,GAAG,GAAG,EAAE,GAEtC,KAAK,QAAQ,SAAS,IAAI,GAAG,GAAG,CAAC;AAEjC,UAAM,CAACrR,GAAM4B,GAAY2O,CAAK,IAAID,GAAY,KAAK,QAAQ;AAEvD,IAAA1O,KAAiB,KAAA,IAAIA,CAAU,GAC/B2O,KAAY,KAAA,IAAIA,CAAK,GACpB,KAAA,IAAI,GAAGvQ,CAAI,GAEhB,KAAK,cAAc4B,GACnB,KAAK,iBAAiB5B;AAEtB,UAAM,EAAE,WAAAuC,GAAW,UAAA+O,GAAU,OAAAC,MAAU,KAAK;AAE5C,gBAAK,WAAWD,GAChB,KAAK,QAAQC,GAEb,KAAK,aAAahP,IACdlD,GAAckD,CAAmB,IACjC,SAAS,MAER,KAAA,cAAc5D,GAAgB,KAAK,QAAQ,GAChD,KAAK,YAAY,gBAAgB,CAAC6B,MAAM,KAAK,eAAeA,CAAC,GAC7D,KAAK,YAAY,gBAAgB,CAACA,MAAM,KAAK,eAAeA,CAAC,GAC7D,KAAK,YAAY,iBAAiB,MAAM,KAAK,gBAAgB,GAExD,KAAA,WAAW,YAAY,KAAK,WAAW,GAExC,KAAK,aAAgB,KAAA,eAAe,KAAK,SAAS,GAEtD,KAAK,OAAO,GAEL;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUT,SAAS;AACH,IAAA,KAAK,aAAW,KAAK,SAAS;AAE5B,UAAA,EAAE,UAAAwQ,GAAU,WAAAQ,EAAA,IAAc,MAE1BC,IAAmBT,EAAS,eAAe,GAC3CU,IAAiBV,EAAS;AAEhC,WAAAA,EAAS,YAAY,IACrBA,EAAS,YAAYQ,CAAS,GAC1BC,KAA2BT,EAAA,WAAWQ,CAAS,GAE1CR,EAAA,MAAM,IAAO,IAAM,EAAK,GACxBA,EAAA,OAAO,MAAM,KAAK,OAAO,GAEzBA,EAAA,YAAY,KAAK,iBAAiB,GACvCS,KAAkBT,EAAS,WAAW,KAAK,gBAAgB,GAE/DA,EAAS,YAAYU,GAEd;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAST,YAAY;AACL,SAAA,WAAW,KAAK,YAAY,sBAAsB;AAEvD,UAAMV,IAAW,KAAK,UAChB/P,IAAU,KAAK,UACf0Q,IAAgBX,EAAS,WAAW,sBAAsB;AAEhE,gBAAK,UAAU;AAAA,MACb/P,EAAQ,OAAO0Q,EAAc;AAAA,MAC7BX,EAAS,WAAW,gBACjB/P,EAAQ,MAAM0Q,EAAc,MAAM1Q,EAAQ;AAAA,MAC7CA,EAAQ;AAAA,MACRA,EAAQ;AAAA,IACV,GAES+P,EAAA,YAAY,KAAK,iBAAiB,GACvCA,EAAS,eAAe,KAAYA,EAAA,WAAW,KAAK,gBAAgB,GAEjE;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQT,eAAe;AACb,gBAAK,mBAAmB,GACjB;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUT,OAAOY,IAAoB,IAAM;AAC/B,WAAIA,KAAY,KAAK,aAAW,KAAK,UAAU,OAAO,GAC/C,KAAK,UAAU,EAAE,aAAa;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASvC,eAAeA,GAAyB;AACtC,gBAAK,eAAe,GAEpB,KAAK,SAASA,EAAS,QAEvB,KAAK,qBAAqB;AAAA,MACxB,OAAO,MAAOA,EAAS,UAAU;AAAA,MACjC,KAAK,MAAOA,EAAS,UAAU;AAAA,MAC/B,QAAQ,MAAM,KAAK,OAAO,EAAK;AAAA,IACjC,GAEA,KAAK,iBAAiB,SAAS,KAAK,mBAAmB,KAAK,GAC5D,KAAK,iBAAiB,OAAO,KAAK,mBAAmB,GAAG,GACxDA,EAAS,iBAAiB,UAAU,KAAK,mBAAmB,MAAM,GAElE,KAAK,YAAYA,GAEV;AAAA,EAAA;AAAA;AAAA,EAIT,iBAAiB;AACf,QAAI,GAAC,KAAK,sBAAsB,CAAC,KAAK;AAEtC,kBAAK,SAAS,IAAI/R,EAAA,EAAU,KAAK,KAAK,UAAU,MAAM,GAEtD,KAAK,oBAAoB,SAAS,KAAK,mBAAmB,KAAK,GAC/D,KAAK,oBAAoB,OAAO,KAAK,mBAAmB,GAAG,GAE3D,KAAK,UAAU;AAAA,QACb;AAAA,QACA,KAAK,mBAAmB;AAAA,MAC1B,GAEA,KAAK,qBAAqB,QAC1B,KAAK,YAAY,QAEV;AAAA,EAAA;AAAA;AAAA,EAIT,UAAU;;AACR,SAAK,eAAe,GAEf,KAAA,SAAS,QAAQ,CAACgS,MAAU;;AAC/B,WAAK,OAAOA,CAAK;AACjB,YAAMvF,IAAOuF;AACb,OAAA1M,IAAAmH,EAAK,aAAL,QAAAnH,EAAe,YACV2M,KAAA1M,IAAAkH,EAAA,aAAA,gBAAAlH,EAAU,QAAV,QAAA0M,EAAe,YACpBC,IAAAzF,EAAK,aAAL,QAAAyF,EAAe;AAAA,IAAQ,CACxB,IAED5M,IAAA,KAAK,gBAAL,QAAAA,EAAkB;AAAA,EAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASnB,mBAAmB6M,IAAsB,IAAM;AACrD,IAAIA,MACF,KAAK,WAAW,KAAK,KAAK,OAAO,UAAU,EAAE,OAAO,GACpD,KAAK,kBAAkB,IAGzBlS,GAAW,KAAK,UAAU,KAAK,gBAAgB,KAAK,MAAM;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQpD,WAAW;AACjB,UAAM,EAAE,UAAAmS,GAAU,YAAAC,EAAW,IAAI,KAAK;AAIlC,QAFKD,EAAA,IAAI,GAAG,GAAG,CAAC,GAEhB,CAAC,KAAK,UAAU;AAEf,MAAAA,EAAA,gBAAgB,KAAK,cAAc,EACnC,eAAe,KAAK,SAAS,EAC7B,IAAI,KAAK,MAAM,GAEPC,EAAA,KAAK,KAAK,iBAAiB,GAEtC,KAAK,mBAAmB,GAExB,KAAK,YAAY,IACjB,KAAK,cAAc,EAAE,MAAM,SAAA,CAAU,GACrC,KAAK,cAAc,EAAE,MAAM,MAAA,CAAO;AAClC;AAAA,IAAA;AAKI,UAAAC,IAFQ,KAAK,OAAO,SAAS,IAEd7Q,KAAkB,KAAK;AAE5C,SAAK,iBAAiB,cAAc,KAAK,gBAAgB6Q,CAAI,GAG1DF,EAAA,gBAAgB,KAAK,gBAAgB,EACrC,eAAe,KAAK,SAAS,EAC7B,IAAI,KAAK,MAAM,GAEPC,EAAA,cAAc,KAAK,mBAAmBC,CAAI,GAErD,KAAK,mBAAmB,GACxB,sBAAsB,MAAM,KAAK,cAAc,EAAE,MAAM,SAAA,CAAU,CAAC,GAE9D,KAAK,iBAAiB,QAAQ,KAAK,cAAc,IAAI9Q,OACvD,KAAK,YAAY,IACjB,KAAK,cAAc,EAAE,MAAM,MAAA,CAAO;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASM,gBAAgB4Q,GAAmB;AACzC,UAAMhS,IAAS,KAAK,QACdmS,IAAa,KAAK;AAExB,SAAK,gBAAgB,KAAKH,CAAQ,EAAE,eAAe,KAAK,SAAS,GAG9DxB,EAAA,YAAY,KAAK,eAAe,EAChC,OAAO,KAAK,iBAAiB,KAAK,UAAU,KAAK,EAAE,GACjD,KAAA,kBAAkB,sBAAsBA,CAAO,GAE/C,KAAA,gBAAgB,IAAI2B,CAAU,GAEnC3B,EAAQ,OAAO,KAAK,iBAAiB2B,GAAY,KAAK,EAAE,GACnD,KAAA,eAAe,sBAAsB3B,CAAO,GAG9CA,EAAA,YAAYxQ,EAAO,QAAQ,EAC3B,OAAOA,EAAO,UAAUmS,GAAY,KAAK,EAAE,GACzC,KAAA,iBAAiB,sBAAsB3B,CAAO,GAEnD,KAAK,YAAY,IACjB,KAAK,OAAO,MAAM,GAClB,KAAK,cAAc,EAAE,MAAM,QAAA,CAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS9B,eAAejQ,GAAiB;AAClC,QAAA,CAAC,KAAK,QAAS;AAEb,UAAA6R,IAAO,CAAC7R,MAAoB;AAC5B,UAAA,CAAC,KAAK,WAAW;AACnB,YAAID,GAAQC,GAAG,KAAK,aAAa,EAAG;AACpC,aAAK,YAAY;AAAA,MAAA;AAGnB,YAAM8R,IAAezB,GAClB,IAAIrQ,EAAE,SAASA,EAAE,OAAO,EACxB,IAAI,KAAK,aAAa,EACtB,eAAgB,IAAI,KAAK,SAAS,QAAS,KAAK,EAAE,GAE/C+R,IAAY7B,GAAW;AAAA,QAC3BE,GAAM,WAAW,KAAK,OAAO,UAAU,KAAK,MAAM;AAAA,MACpD;AAEU,MAAA2B,EAAA,QAAQC,IAAeF,EAAa,GAC9CC,EAAU,MAAMhT;AAAA,QACdkT,IAAaH,EAAa;AAAA,QAC1BjR;AAAA,QACA,KAAK,KAAKA;AAAA,MACZ,GAEA,KAAK,OAAO,SAAS,iBAAiBkR,CAAS,EAAE,IAAI,KAAK,MAAM,GAC3D,KAAA,OAAO,OAAO,KAAK,MAAM,GAE9B,KAAK,WAAW,KAAK,KAAK,OAAO,UAAU,EAAE,OAAO,GAEpD,KAAK,mBAAmB,EAAK,GAC7B,KAAK,cAAc,EAAE,MAAM,SAAA,CAAU;AAAA,IACvC,GAEMG,IAAU,MAAM;AAIpB,UAHS,SAAA,oBAAoB,eAAeL,GAAM,EAAK,GAC9C,SAAA,oBAAoB,aAAaK,GAAS,EAAK,GAEpD,CAAC,KAAK,UAAkB,QAAA,KAAK,aAAalS,CAAC;AAE/C,MAAI,KAAK,WACGgQ,EAAA,KAAK,QAAQ,EAAK,GAC5B,KAAK,SAAS,OAGhB,KAAK,YAAY,IACjB,KAAK,cAAc,EAAE,MAAM,MAAA,CAAO;AAAA,IACpC;AAEA,QAAI,KAAK,UAAW;AAEpB,IAAAhQ,EAAE,eAAe,GACjB,KAAK,cAAc,IAAIA,EAAE,SAASA,EAAE,OAAO;AAErC,UAAAmS,IAAmB,IAAIhC,GAAA,EAAY;AAAA,MACvCC,GAAM,WAAW,KAAK,OAAO,UAAU,KAAK,MAAM;AAAA,IACpD,GACM4B,IAAeG,EAAiB,OAChCF,IAAaE,EAAiB;AACpC,SAAK,YAAYA,EAAiB,QAEzB,SAAA,iBAAiB,eAAeN,GAAM,EAAK,GAC3C,SAAA,iBAAiB,aAAaK,GAAS,EAAK,GAErD,KAAK,cAAc,EAAE,MAAM,QAAA,CAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS9B,eAAelS,GAAiB;AACtC,IAAI,CAAC,KAAK,WAAW,KAAK,cAEtB,KAAK,eAA8BmB,GAAA,KAAK,aAAa,EAAI,GAE7D,KAAK,aAAanB,CAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQb,kBAAkB;AACxB,IAAI,CAAC,KAAK,WAAW,KAAK,cAEtB,KAAK,eAA8BmB,GAAA,KAAK,aAAa,EAAK,GAC1D,KAAK,UAAkB6O,EAAA,KAAK,QAAQ,EAAK,GAExC,KAAA,YAAY,MAAM,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS1B,aAAahQ,GAAiB;AACpC,UAAMY,IAAeL;AAAA,MACnBP;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAOA,IALI,KAAK,WACGgQ,EAAA,KAAK,QAAQ,EAAK,GAC5B,KAAK,SAAS,OAGXpP,MAEA,KAAA,gBAAgBA,EAAa,OAAO,QAAQ,GAEjD,KAAK,cAAc,EAAE,MAAM,SAAA,CAAU;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS/B,aAAaZ,GAAiB;AACpC,UAAMY,IAAeL;AAAA,MACnBP;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP,GAEMH,KAASe,KAAA,gBAAAA,EAAc,WAAU;AAEnC,IAAA,KAAK,WAAWf,MAEpB,KAAK,YAAY,MAAM,SAASA,IAAS,YAAY,IAEjD,KAAK,UAAkBmQ,EAAA,KAAK,QAAQ,EAAK,IAExC,KAAK,SAASnQ,KAASmQ,EAAUnQ,GAAQ,EAAI,OAClC,KAAK,UAAU,KAAK,gBAAgB,KAAK,MAAM;AAAA,EAAA;AAEnE;","x_google_ignoreList":[2,15,17,18,19,20,21]}