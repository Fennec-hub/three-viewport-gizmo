{"version":3,"file":"three-viewport-gizmo.js","sources":["../lib/utils/gizmoDomElement.ts","../lib/utils/getDomElement.ts","../node_modules/three/src/math/MathUtils.js","../lib/utils/updateAxis.ts","../lib/utils/isClick.ts","../lib/utils/intersectedObjects.ts","../lib/utils/constants.ts","../lib/utils/updateBackground.ts","../lib/utils/deepClone.ts","../lib/utils/optionsFallback.ts","../lib/utils/axesMap.ts","../lib/utils/roundedRectangleGeometry.ts","../lib/utils/axesFaces.ts","../lib/utils/axesCorners.ts","../lib/utils/axesEdges.ts","../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","../lib/utils/gizmoBackground.ts","../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../node_modules/three/examples/jsm/lines/LineMaterial.js","../node_modules/three/examples/jsm/lines/LineSegments2.js","../node_modules/three/examples/jsm/lines/LineGeometry.js","../node_modules/three/examples/jsm/lines/Line2.js","../lib/utils/axesLines.ts","../lib/utils/axesObjects.ts","../lib/utils/axisHover.ts","../lib/ViewportGizmo.ts"],"sourcesContent":["import { GizmoOptionsFallback } from \"../types\";\n\nexport const setDomPlacement = (\n  domElement: HTMLElement,\n  placement: GizmoOptionsFallback[\"placement\"]\n) => {\n  const [y, x] = placement.split(\"-\");\n  Object.assign(domElement.style, {\n    left: x === \"left\" ? \"0\" : x === \"center\" ? `50%` : \"\",\n    right: x === \"right\" ? \"0\" : \"\",\n    top: y === \"top\" ? \"0\" : y === \"bottom\" ? \"\" : \"50%\",\n    bottom: y === \"bottom\" ? \"0\" : \"\",\n    transform: `${x === \"center\" ? \"translateX(-50%)\" : \"\"} ${\n      y === \"center\" ? \"translateY(-50%)\" : \"\"\n    }`,\n  });\n\n  return placement;\n};\n\nexport const gizmoDomElement = ({\n  placement,\n  size,\n  offset,\n  id,\n  className,\n}: GizmoOptionsFallback) => {\n  const div = document.createElement(\"div\");\n\n  const { top, left, right, bottom } = offset;\n  Object.assign(div.style, {\n    id,\n    position: \"absolute\",\n    zIndex: \"1000\",\n    height: `${size}px`,\n    width: `${size}px`,\n    margin: `${top}px ${right}px ${bottom}px ${left}px`,\n    borderRadius: \"100%\",\n  });\n\n  setDomPlacement(div, placement);\n\n  if (id) div.id = id;\n  if (className) div.className = className;\n\n  return div;\n};\n","export const getDomElement = (\n  domElement: string | HTMLElement\n): HTMLElement => {\n  const element =\n    typeof domElement === \"string\"\n      ? document.querySelector<HTMLElement>(domElement)\n      : domElement;\n\n  if (!element) throw Error(`Invalid DOM element`);\n\n  return element;\n};\n","const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport { Camera, Vector3 } from \"three\";\nimport { clamp } from \"three/src/math/MathUtils.js\";\n\nconst axisMap: [\n  axis: \"x\" | \"y\" | \"z\",\n  positiveIndex: number,\n  negativeIndex: number\n][] = [\n  [\"x\", 0, 3],\n  [\"y\", 1, 4],\n  [\"z\", 2, 5],\n];\n\nconst point = /*@__PURE__*/ new Vector3();\nexport function updateAxis(\n  { isSphere }: GizmoOptionsFallback,\n  axes: GizmoAxisObject[],\n  camera: Camera\n): void {\n  if (!isSphere) return;\n\n  point.set(0, 0, 1).applyQuaternion(camera.quaternion);\n\n  axisMap.forEach(([axis, positiveIndex, negativeIndex]) => {\n    const value = point[axis];\n\n    let object = axes[positiveIndex];\n    let opacity = object.userData.opacity;\n\n    object.material.opacity = clamp(value >= 0 ? opacity : opacity / 2, 0, 1);\n\n    object = axes[negativeIndex];\n    opacity = object.userData.opacity;\n\n    object.material.opacity = clamp(value >= 0 ? opacity / 2 : opacity, 0, 1);\n  });\n}\n","import { Vector2 } from \"three\";\n\nexport const isClick = (\n  e: PointerEvent,\n  startCoords: Vector2,\n  threshold: number = 10\n) =>\n  Math.abs(e.clientX - startCoords.x) < threshold &&\n  Math.abs(e.clientY - startCoords.y) < threshold;\n","import { GizmoAxisObject } from \"@lib/types\";\nimport {\n  Vector2,\n  Raycaster,\n  type Object3D,\n  type Camera,\n  Intersection,\n} from \"three\";\n\nconst _raycaster = /*@__PURE__*/ new Raycaster();\nconst _mouse = /*@__PURE__*/ new Vector2();\n\nexport const intersectedObjects = (\n  event: PointerEvent,\n  domRect: DOMRect,\n  camera: Camera,\n  intersections: Object3D[]\n): Intersection<GizmoAxisObject> | null => {\n  _mouse.set(\n    ((event.clientX - domRect.left) / domRect.width) * 2 - 1,\n    -((event.clientY - domRect.top) / domRect.height) * 2 + 1\n  );\n\n  _raycaster.setFromCamera(_mouse, camera);\n\n  const intersects = _raycaster.intersectObjects<GizmoAxisObject>(\n    intersections,\n    false\n  );\n\n  // If we have intersections, apply smart sorting that respects both\n  // distance (occlusion) and intersectionOrder\n  if (intersects.length > 0) {\n    // First, sort by distance (default behavior from raycaster)\n    intersects.sort((a, b) => a.distance - b.distance);\n\n    // Distance threshold for considering objects at similar depth\n    // Objects within this threshold of the closest hit will be \n    // considered at the same depth and sorted by intersectionOrder instead\n    const DISTANCE_THRESHOLD = 0.2;\n\n    // Get the distance of the closest hit\n    const closestDistance = intersects[0].distance;\n\n    // Find all intersections within the threshold of the closest hit\n    const nearHits = intersects.filter(\n      hit => hit.distance <= closestDistance + DISTANCE_THRESHOLD\n    );\n\n    // If we have multiple hits at similar distance, sort them by intersectionOrder\n    if (nearHits.length > 1) {\n      nearHits.sort((a, b) => {\n        return (b.object.userData.intersectionOrder || 0) - (a.object.userData.intersectionOrder || 0);\n      });\n\n      // Put the highest intersectionOrder object that's within the threshold at the beginning\n      intersects.splice(0, nearHits.length, ...nearHits);\n    }\n  }\n\n  const intersection = intersects.length ? intersects[0] : null;\n\n  return !intersection || !intersection.object.visible ? null : intersection;\n};\n","export const GIZMO_EPSILON = 1e-6;\nexport const GIZMO_TURN_RATE = 2 * Math.PI;\nexport const GIZMO_MAIN_AXES = [\"x\", \"y\", \"z\"] as const;\nexport const GIZMO_AXES = [...GIZMO_MAIN_AXES, \"nx\", \"ny\", \"nz\"] as const;\nexport const GIZMO_AXES_Z_UP = [\"x\", \"z\", \"y\", \"nx\", \"nz\", \"ny\"] as const;\nexport const GIZMO_AXES_X_UP = [\"z\", \"x\", \"y\", \"nz\", \"nx\", \"ny\"] as const;\nexport const GIZMO_FACE_RIGHT = \"Right\";\nexport const GIZMO_FACE_TOP = \"Top\";\nexport const GIZMO_FACE_FRONT = \"Front\";\nexport const GIZMO_FACE_LEFT = \"Left\";\nexport const GIZMO_FACE_BOTTOM = \"Bottom\";\nexport const GIZMO_FACE_BACK = \"Back\";\nexport const GIZMO_FACES = [\n  GIZMO_FACE_RIGHT,\n  GIZMO_FACE_TOP,\n  GIZMO_FACE_FRONT,\n  GIZMO_FACE_LEFT,\n  GIZMO_FACE_BOTTOM,\n  GIZMO_FACE_BACK,\n].map((face) => face.toLocaleLowerCase());\nexport const GIZMO_SPHERE_AXES_DISTANCE = 1.3;\n","import { BufferGeometry, Mesh, MeshBasicMaterial } from \"three\";\n\nexport const updateBackground = (\n  background: Mesh<BufferGeometry, MeshBasicMaterial>,\n  hovered: boolean = true\n) => {\n  const { material, userData } = background;\n  const { color, opacity } = hovered ? userData.hover : userData;\n\n  material.color.set(color);\n  material.opacity = opacity;\n};\n","export const deepClone = <T>(obj: T) => JSON.parse(JSON.stringify(obj));\n","import {\n  GizmoAxisOptions,\n  GizmoOptions,\n  GizmoOptionsFallback,\n} from \"@lib/types\";\nimport {\n  GIZMO_MAIN_AXES,\n  GIZMO_AXES,\n  GIZMO_AXES_X_UP,\n  GIZMO_AXES_Z_UP,\n  GIZMO_FACES,\n  GIZMO_FACE_TOP,\n  GIZMO_FACE_RIGHT,\n  GIZMO_FACE_FRONT,\n  GIZMO_FACE_BOTTOM,\n  GIZMO_FACE_LEFT,\n  GIZMO_FACE_BACK,\n} from \"./constants\";\n\nimport { deepClone } from \"./deepClone\";\nimport { Object3D } from \"three\";\n\nexport const optionsFallback = (\n  options: GizmoOptions\n): GizmoOptionsFallback => {\n  const type = options.type || \"sphere\";\n  const isSphere = type === \"sphere\";\n  const isRoundedCube = type === \"rounded-cube\";\n  const resolution = options.resolution || isSphere ? 64 : 128;\n\n  const defaultUp = Object3D.DEFAULT_UP;\n  const zUp = defaultUp.z === 1;\n  const xUp = defaultUp.x === 1;\n\n  const { container } = options;\n  options.container = undefined;\n  options = JSON.parse(JSON.stringify(options));\n  options.container = container;\n\n  // Convert face axis to regular axis\n  const faceAxis = zUp ? GIZMO_AXES_Z_UP : xUp ? GIZMO_AXES_X_UP : GIZMO_AXES;\n  GIZMO_FACES.forEach((face, index) => {\n    if ((options as any)[face])\n      options[faceAxis[index]] = (options as any)[face];\n  });\n\n  // Positive Axes fallback options\n  const axesFallback: GizmoAxisOptions = {\n    enabled: true,\n    color: 0xffffff,\n    opacity: 1,\n    scale: isSphere ? 0.7 : 0.7,\n    labelColor: 0x222222,\n    line: false,\n    border: {\n      size: 0,\n      color: 0xdddddd,\n    },\n    hover: {\n      color: isSphere ? 0xffffff : 0x93d3eb,\n      labelColor: 0x222222,\n      opacity: 1,\n      scale: isSphere ? 0.7 : 0.7,\n      border: {\n        size: 0,\n        color: 0xdddddd,\n      },\n    },\n  };\n\n  // Negative Axes fallback options\n  const negativeAxesFallback = {\n    line: false,\n    scale: isSphere ? 0.45 : 0.7,\n    hover: {\n      scale: isSphere ? 0.5 : 0.7,\n    },\n  };\n\n  const optionsFallback: GizmoOptions = {\n    type,\n    container: document.body,\n    size: 128,\n    placement: \"top-right\",\n    resolution,\n    lineWidth: 4,\n    radius: isSphere ? 1 : 0.2,\n    smoothness: 18,\n    animated: true,\n    speed: 1,\n    background: {\n      enabled: true,\n      color: isSphere ? 0xffffff : 0xe0e6ec,\n      opacity: isSphere ? 0 : 1,\n      hover: {\n        color: isSphere ? 0xffffff : 0xe0e6ec,\n        opacity: isSphere ? 0.2 : 1,\n      },\n    },\n    font: {\n      family: \"sans-serif\",\n      weight: 900,\n    },\n    offset: {\n      top: 10,\n      left: 10,\n      bottom: 10,\n      right: 10,\n    },\n    corners: {\n      enabled: !isSphere,\n      color: isSphere ? 0xf2d962 : 0xffffff,\n      opacity: 1,\n      scale: isSphere ? 0.15 : 0.2,\n      radius: 1,\n      smoothness: 18,\n      hover: {\n        color: isSphere ? 0xffffff : 0x93d3eb,\n        opacity: 1,\n        scale: isSphere ? 0.2 : 0.225,\n      },\n    },\n    edges: {\n      enabled: !isSphere,\n      color: isSphere ? 0xf2d962 : isRoundedCube ? 0xeeeeee : 0xffffff,\n      opacity: isSphere ? 1 : 0,\n      radius: isSphere ? 1 : 0.125,\n      smoothness: 18,\n      scale: isSphere ? 0.15 : 1,\n      hover: {\n        color: isSphere ? 0xffffff : 0x93d3eb,\n        opacity: 1,\n        scale: isSphere ? 0.2 : 1,\n      },\n    },\n    x: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? { label: \"X\", color: 0xff3653, line: true }\n        : { label: xUp ? GIZMO_FACE_TOP : GIZMO_FACE_RIGHT }),\n    },\n    y: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? { label: \"Y\", color: 0x8adb00, line: true }\n        : { label: zUp || xUp ? GIZMO_FACE_FRONT : GIZMO_FACE_TOP }),\n    },\n    z: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? { label: \"Z\", color: 0x2c8fff, line: true }\n        : {\n            label: zUp\n              ? GIZMO_FACE_TOP\n              : xUp\n              ? GIZMO_FACE_RIGHT\n              : GIZMO_FACE_FRONT,\n          }),\n    },\n    nx: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere ? \"\" : xUp ? GIZMO_FACE_BOTTOM : GIZMO_FACE_LEFT,\n    },\n    ny: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere ? \"\" : zUp || xUp ? GIZMO_FACE_BACK : GIZMO_FACE_BOTTOM,\n    },\n    nz: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere\n        ? \"\"\n        : zUp\n        ? GIZMO_FACE_BOTTOM\n        : xUp\n        ? GIZMO_FACE_LEFT\n        : GIZMO_FACE_BACK,\n    },\n  };\n\n  assignNestedDefaults(options, optionsFallback);\n\n  /** Handle rounded-cube type options */\n  if (isRoundedCube) {\n    const mergedOptions = options as GizmoOptionsFallback;\n    mergedOptions.edges.radius = mergedOptions.radius;\n    mergedOptions.edges.scale = 1;\n    mergedOptions.edges.opacity = 1;\n    mergedOptions.edges.hover.scale = 1;\n    mergedOptions.edges.hover.opacity = 1;\n    mergedOptions.corners.radius = mergedOptions.radius;\n    mergedOptions.corners.scale = 1;\n    mergedOptions.corners.opacity = 1;\n    mergedOptions.corners.hover.scale = 1;\n    mergedOptions.corners.hover.opacity = 1;\n    mergedOptions.radius = 0;\n    GIZMO_AXES.forEach(axis => {\n      mergedOptions[axis].scale = 1;\n      mergedOptions[axis].opacity = 1;\n      mergedOptions[axis].hover.scale = 1;\n      mergedOptions[axis].hover.opacity = 1;\n    });\n  }\n\n  // Negative axis fallback to positive axis\n  GIZMO_MAIN_AXES.forEach((axis) =>\n    assignNestedDefaults(\n      (options as any)[`n${axis}`],\n      deepClone((options as any)[axis])\n    )\n  );\n\n  return { ...options, isSphere } as GizmoOptionsFallback;\n};\n\nfunction assignNestedDefaults<T>(target: T, ...defaultObjects: T[]) {\n  if (\n    target instanceof HTMLElement ||\n    typeof target !== \"object\" ||\n    target === null\n  )\n    return target;\n\n  for (const defaults of defaultObjects) {\n    for (const key in defaults) {\n      if (key === \"container\") continue;\n\n      if (key in (defaults as any)) {\n        if (target[key] === undefined) {\n          (target as any)[key] = defaults[key];\n        } else if (\n          typeof defaults[key] === \"object\" &&\n          !Array.isArray(defaults[key])\n        ) {\n          (target as any)[key] = assignNestedDefaults(\n            (target as any)[key] || {},\n            defaults[key]\n          );\n        }\n      }\n    }\n  }\n\n  return target as T;\n}\n","import {\n  CanvasTexture,\n  Color,\n  ColorRepresentation,\n  RepeatWrapping,\n  SRGBColorSpace,\n  Texture,\n} from \"three\";\nimport { GizmoAxisOptions, GizmoOptionsFallback } from \"@lib/types\";\nimport { GIZMO_AXES } from \"./constants\";\n\nexport const axesMap = (options: GizmoOptionsFallback, offset: number = 2) => {\n  const colorManager = new Color();\n  const doubleOffset = offset * 2;\n  const { isSphere, resolution, radius, font, corners, edges } = options;\n\n  const axes: (Required<GizmoAxisOptions> & { radius: number })[] =\n    GIZMO_AXES.map((axis) => ({ ...options[axis], radius }));\n\n  if (isSphere && corners.enabled) axes.push(corners as any);\n  if (isSphere && edges.enabled) axes.push(edges as any);\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n  canvas.width = resolution * 2 + doubleOffset * 2;\n  canvas.height = resolution * axes.length + doubleOffset * axes.length;\n\n  const [fontStyle, fontYFix] = getFontStyle(axes, resolution, font);\n\n  axes.forEach(\n    (\n      {\n        radius,\n        label,\n        color,\n        labelColor,\n        border,\n        hover: {\n          color: hoverColor,\n          labelColor: hoverLabel,\n          border: hoverBorder,\n        },\n      },\n      index\n    ) => {\n      const y = resolution * index + index * doubleOffset + offset;\n      drawAxis(\n        offset,\n        y,\n        offset,\n        resolution,\n        radius,\n        label,\n        border,\n        color,\n        labelColor\n      );\n      drawAxis(\n        resolution + offset * 3,\n        y,\n        offset,\n        resolution,\n        radius,\n        label,\n        hoverBorder ?? border,\n        hoverColor ?? color,\n        hoverLabel ?? labelColor\n      );\n    }\n  );\n\n  /* // Debug\n  document.body.appendChild(canvas);\n  Object.assign(canvas.style, {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    zIndex: 100000,\n  }); */\n\n  const colsCount = axes.length;\n  const offsetX = offset / (resolution * 2);\n  const offsetY = offset / (resolution * 6);\n  const cellHeight = 1 / colsCount;\n\n  const map = new CanvasTexture(canvas);\n  map.repeat.set(0.5 - 2 * offsetX, cellHeight - 2 * offsetY);\n  map.offset.set(offsetX, 1 - offsetY);\n\n  Object.assign(map, {\n    colorSpace: SRGBColorSpace,\n    wrapS: RepeatWrapping,\n    wrapT: RepeatWrapping,\n    userData: {\n      offsetX,\n      offsetY,\n      cellHeight,\n    },\n  });\n\n  return map;\n\n  function drawAxis(\n    x: number,\n    y: number,\n    offset: number,\n    size: number,\n    radius: number,\n    label: string,\n    border: GizmoAxisOptions[\"border\"],\n    color: ColorRepresentation,\n    labelColor: ColorRepresentation\n  ) {\n    radius = radius * (size / 2);\n\n    if (color != null && color !== \"\") {\n      drawRoundRectPath();\n      ctx.fillStyle = colorManager.set(color!).getStyle();\n      ctx.fill();\n    }\n\n    if (border && border.size) {\n      const halfBorderWidth = (border.size * size) / 2;\n      x += halfBorderWidth;\n      y += halfBorderWidth;\n      size -= border.size * size;\n      radius = Math.max(0, radius - halfBorderWidth);\n\n      drawRoundRectPath();\n      ctx.strokeStyle = colorManager.set(border.color).getStyle();\n      ctx.lineWidth = border.size * size;\n      ctx.stroke();\n    }\n\n    if (label)\n      drawText(\n        ctx,\n        x + size / 2,\n        y + (size + offset) / 2,\n        label,\n        colorManager.set(labelColor!).getStyle()\n      );\n\n    function drawRoundRectPath() {\n      ctx.beginPath();\n      ctx.moveTo(x + radius, y);\n      ctx.lineTo(x + size - radius, y);\n      ctx.arcTo(x + size, y, x + size, y + radius, radius);\n      ctx.lineTo(x + size, y + size - radius);\n      ctx.arcTo(x + size, y + size, x + size - radius, y + size, radius);\n      ctx.lineTo(x + radius, y + size);\n      ctx.arcTo(x, y + size, x, y + size - radius, radius);\n      ctx.lineTo(x, y + radius);\n      ctx.arcTo(x, y, x + radius, y, radius);\n      ctx.closePath();\n    }\n  }\n\n  function getFontStyle(\n    axis: GizmoAxisOptions[],\n    resolution: number,\n    font: GizmoOptionsFallback[\"font\"]\n  ) {\n    const longestLabel = [...axis]\n      .sort((a, b) => (a.label?.length || 0) - (b.label?.length || 0))\n      .pop()!;\n    const text = longestLabel.label!;\n\n    const { family, weight } = font;\n\n    const square = isSphere\n      ? Math.sqrt(Math.pow(resolution * 0.7, 2) / 2)\n      : resolution;\n    let fontSize = square;\n    if (options.font.size > 0) {\n      fontSize = options.font.size;\n    }\n    let textWidth = 0;\n    let textHeight = 0;\n\n    do {\n      ctx.font = `${weight} ${fontSize}px ${family}`;\n      const measure = ctx.measureText(text);\n      textWidth = measure.width;\n      textHeight = measure.fontBoundingBoxDescent;\n      fontSize--;\n    } while (textWidth > square && fontSize > 0);\n\n    const yFix = square / textHeight;\n    const scaleFactor = Math.min(square / textWidth, yFix);\n    const finalFontSize = Math.floor(fontSize * scaleFactor);\n\n    return [`${weight} ${finalFontSize}px ${family}`, yFix] as const;\n  }\n\n  function drawText(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    text: string,\n    color: string\n  ) {\n    ctx.font = fontStyle;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = color;\n    ctx.fillText(text, x, y + (isSphere ? fontYFix : 0));\n  }\n};\n\nexport const setMapHoverOffset = (map: Texture, hover: boolean) =>\n  (map.offset.x = (hover ? 0.5 : 0) + map.userData.offsetX);\n\nexport const setMapColumnOffset = (map: Texture, col: number) => {\n  const {\n    offset,\n    userData: { offsetY, cellHeight },\n  } = map;\n  offset.y = 1 - (col + 1) * cellHeight + offsetY;\n};\n","import { BufferGeometry, BufferAttribute } from \"three\";\n\n/**\n * Generate a Rounded Rectangle geometry\n *\n * @param radius      - The edges radius\n * @param smoothness  - The edges smoothness\n *\n * @ThanksTo `@hofk` for the {@link https://discourse.threejs.org/t/roundedrectangle-squircle/28645 RoundedRectangle + Squircle } Geometry\n *\n * @returns A round rectangle geometry\n */\nexport function roundedRectangleGeometry(\n  radius: number,\n  smoothness: number,\n  width: number = 2,\n  height: number = 2\n) {\n  // helper const's\n  const wi = width / 2 - radius; // inner width\n  const hi = height / 2 - radius; // inner height\n  const ul = radius / width; // u left\n  const ur = (width - radius) / width; // u right\n  const vl = radius / height; // v low\n  const vh = (height - radius) / height; // v high\n\n  const positions = [wi, hi, 0, -wi, hi, 0, -wi, -hi, 0, wi, -hi, 0];\n  const uvs = [ur, vh, ul, vh, ul, vl, ur, vl];\n  const n = [\n    3 * (smoothness + 1) + 3,\n    3 * (smoothness + 1) + 4,\n    smoothness + 4,\n    smoothness + 5,\n    2 * (smoothness + 1) + 4,\n    2,\n    1,\n    2 * (smoothness + 1) + 3,\n    3,\n    4 * (smoothness + 1) + 3,\n    4,\n    0,\n  ];\n  const indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(\n    (i) => n[i]\n  );\n\n  let phi, cos, sin, xc, yc, uc, vc, idx;\n\n  for (let i = 0; i < 4; i++) {\n    xc = i < 1 || i > 2 ? wi : -wi;\n    yc = i < 2 ? hi : -hi;\n\n    uc = i < 1 || i > 2 ? ur : ul;\n    vc = i < 2 ? vh : vl;\n\n    for (let j = 0; j <= smoothness; j++) {\n      phi = (Math.PI / 2) * (i + j / smoothness);\n      cos = Math.cos(phi);\n      sin = Math.sin(phi);\n\n      positions.push(xc + radius * cos, yc + radius * sin, 0);\n\n      uvs.push(uc + ul * cos, vc + vl * sin);\n\n      if (j < smoothness) {\n        idx = (smoothness + 1) * i + j + 4;\n        indices.push(i, idx, idx + 1);\n      }\n    }\n  }\n\n  return new BufferGeometry()\n    .setIndex(new BufferAttribute(new Uint32Array(indices), 1))\n    .setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(positions), 3)\n    )\n    .setAttribute(\"uv\", new BufferAttribute(new Float32Array(uvs), 2));\n}\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n} from \"three\";\nimport { GIZMO_AXES, GIZMO_SPHERE_AXES_DISTANCE } from \"./constants\";\n\nimport { setMapColumnOffset } from \"./axesMap\";\n\nexport const axesFaces = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture\n): GizmoAxisObject[] => {\n  const target = new Vector3();\n  const { isSphere, radius, smoothness, type } = options;\n  const isRoundedCube = type === \"rounded-cube\";\n  const faceLength = isRoundedCube ? (2 - options.edges.radius * 2) : 2;\n  const geometry = roundedRectangleGeometry(radius, smoothness, faceLength, faceLength);\n\n  return GIZMO_AXES.map((_, i) => {\n    const isPositive = i < 3;\n\n    const axis = GIZMO_AXES[i];\n    const map = i ? texture.clone() : texture;\n\n    setMapColumnOffset(map, i);\n\n    const { enabled, scale, opacity, hover } = options[axis];\n\n    const materialConfig: MeshBasicMaterialParameters = {\n      map,\n      opacity,\n      transparent: true,\n    };\n\n    const face = isSphere\n      ? new Sprite(new SpriteMaterial(materialConfig))\n      : new Mesh(geometry, new MeshBasicMaterial(materialConfig));\n\n    const direction = (isPositive ? axis : axis[1]) as \"x\" | \"y\" | \"z\";\n    face.position[direction] =\n      (isPositive ? 1 : -1) * (isSphere ? GIZMO_SPHERE_AXES_DISTANCE : 1);\n\n    if (!isSphere) face.lookAt(target.copy(face.position).multiplyScalar(1.7));\n\n    face.scale.setScalar(scale);\n    face.renderOrder = 1;\n    face.visible = enabled;\n    face.userData = {\n      scale,\n      opacity,\n      hover,\n    };\n\n    return face;\n  });\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  SphereGeometry,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n} from \"three\";\nimport { setMapColumnOffset } from \"./axesMap\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\n\nexport const axesCorners = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture\n) => {\n  const { isSphere, corners, type } = options;\n  const isRoundedCube = type === \"rounded-cube\";\n\n  if (!corners.enabled) return [];\n\n  const { color, opacity, scale, radius, smoothness, hover } = corners;\n\n  const geometry = isSphere\n    ? null\n    : isRoundedCube ?\n      new SphereGeometry(radius, smoothness * 2, smoothness)\n      : roundedRectangleGeometry(radius, smoothness);\n\n  const materialConfig: MeshBasicMaterialParameters = {\n    transparent: true,\n    opacity,\n  };\n\n  const positionOffsetRatio = isRoundedCube ? (1 - radius) : 0.85;\n  const positions = [\n    1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, -1, -1, -1,\n    -1, -1,\n  ].map((val) => val * positionOffsetRatio);\n\n  const target = new Vector3();\n  return Array(positions.length / 3)\n    .fill(0)\n    .map<GizmoAxisObject>((_, i) => {\n      if (isSphere) {\n        const map = texture.clone();\n        setMapColumnOffset(map, 6);\n        materialConfig.map = map;\n      } else {\n        materialConfig.color = color;\n      }\n\n      const corner = isSphere\n        ? new Sprite(new SpriteMaterial(materialConfig))\n        : new Mesh(geometry!, new MeshBasicMaterial(materialConfig));\n\n      const i3 = i * 3;\n      corner.position.set(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n\n      if (isSphere) corner.position.normalize().multiplyScalar(1.7);\n\n      corner.scale.setScalar(scale);\n      corner.lookAt(target.copy(corner.position).multiplyScalar(2));\n      corner.renderOrder = 1;\n\n      corner.userData = {\n        color,\n        opacity,\n        scale,\n        hover,\n        intersectionOrder: 1,\n      };\n\n      return corner;\n    });\n};\n","import { GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n  CylinderGeometry,\n} from \"three\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\nimport { setMapColumnOffset } from \"./axesMap\";\n\nexport const axesEdges = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture,\n  textureColumn: number\n) => {\n  const { isSphere, edges, type } = options;\n  const isRoundedCube = type === \"rounded-cube\";\n\n  if (!edges.enabled) return [];\n\n  const { color, opacity, scale, hover, radius, smoothness } = edges;\n\n  const edgeLength = isRoundedCube ? (2 - radius * 2) : 1.2;\n  const geometry = isSphere\n    ? null\n    : isRoundedCube ?\n      new CylinderGeometry(radius, radius, edgeLength, smoothness * 4)\n      : roundedRectangleGeometry(radius, smoothness, edgeLength, 0.25);\n\n  const materialConfig: MeshBasicMaterialParameters = {\n    transparent: true,\n    opacity,\n  };\n\n  const positionOffsetRatio = isRoundedCube ? (1 - radius) : 0.925;\n  const positions = [\n    0, 1, 1, 0, -1, 1, 1, 0, 1, -1, 0, 1, 0, 1, -1, 0, -1, -1, 1, 0, -1, -1, 0,\n    -1, 1, 1, 0, 1, -1, 0, -1, 1, 0, -1, -1, 0,\n  ].map((val) => val * positionOffsetRatio);\n\n  const target = new Vector3();\n  const defaultUp = new Vector3(0, 1, 0);\n  return Array(positions.length / 3)\n    .fill(0)\n    .map<Mesh<any, MeshBasicMaterial> | Sprite>((_, i) => {\n      if (isSphere) {\n        const map = texture.clone();\n        setMapColumnOffset(map, textureColumn);\n        materialConfig.map = map;\n      } else {\n        materialConfig.color = color;\n      }\n\n      const edge = isSphere\n        ? new Sprite(new SpriteMaterial(materialConfig))\n        : new Mesh(geometry!, new MeshBasicMaterial(materialConfig));\n\n      const i3 = i * 3;\n      edge.position.set(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n      if (isSphere) edge.position.normalize().multiplyScalar(1.7);\n      edge.scale.setScalar(scale);\n\n      edge.up.copy(defaultUp);\n      edge.lookAt(target.copy(edge.position).multiplyScalar(2));\n      if (isRoundedCube) {\n        if (!isSphere && !edge.position.z) edge.rotation.z = Math.PI;\n        if (!isSphere && !edge.position.x) edge.rotation.x = 0;\n        if (!isSphere && !edge.position.x) edge.rotation.z = Math.PI / 2;\n      } else {\n        if (!isSphere && !edge.position.y) edge.rotation.z = Math.PI / 2;\n      }\n\n      edge.renderOrder = 1;\n\n      edge.userData = {\n        color,\n        opacity,\n        scale,\n        hover,\n      };\n\n      return edge;\n    });\n};\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute} attribute\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  BackSide,\n  BufferGeometry,\n  Mesh,\n  MeshBasicMaterial,\n  SphereGeometry,\n} from \"three\";\nimport { mergeGeometries } from \"three/examples/jsm/utils/BufferGeometryUtils.js\";\n\nexport const gizmoBackground = (\n  faces: GizmoAxisObject[],\n  options: GizmoOptionsFallback\n) => {\n  const {\n    isSphere,\n    background: { enabled, color, opacity, hover },\n  } = options;\n\n  let background: Mesh<any, MeshBasicMaterial>;\n\n  const material = new MeshBasicMaterial({\n    color,\n    side: BackSide,\n    opacity: opacity,\n    transparent: true,\n    depthWrite: false,\n  });\n\n  if (!enabled) return null;\n\n  if (isSphere) {\n    background = new Mesh<BufferGeometry, MeshBasicMaterial>(\n      new SphereGeometry(1.8, 64, 64),\n      material\n    );\n  } else {\n    let geometry!: BufferGeometry;\n\n    faces.forEach((plane) => {\n      const originalScale = plane.scale.x;\n      plane.scale.setScalar(0.9);\n      plane.updateMatrix();\n\n      const planeGeometry = plane.geometry.clone();\n      planeGeometry.applyMatrix4(plane.matrix);\n\n      geometry = !!geometry\n        ? mergeGeometries([geometry, planeGeometry])\n        : planeGeometry;\n\n      plane.scale.setScalar(originalScale);\n    });\n\n    background = new Mesh(geometry, material);\n  }\n\n  background.userData = {\n    color,\n    opacity,\n    hover,\n  };\n\n  return background;\n};\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\tthis.instanceCount = this.attributes.instanceStart.count;\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n","import {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2,\n} from 'three';\n\nUniformsLib.line = {\n\n\tworldUnits: { value: 1 },\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashOffset: { value: 0 },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t/* glsl */`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t/* glsl */`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttype: 'LineMaterial',\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tthis.isLineMaterial = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget color() {\n\n\t\treturn this.uniforms.diffuse.value;\n\n\t}\n\n\tset color( value ) {\n\n\t\tthis.uniforms.diffuse.value = value;\n\n\t}\n\n\tget worldUnits() {\n\n\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t}\n\n\t}\n\n\tget linewidth() {\n\n\t\treturn this.uniforms.linewidth.value;\n\n\t}\n\n\tset linewidth( value ) {\n\n\t\tif ( ! this.uniforms.linewidth ) return;\n\t\tthis.uniforms.linewidth.value = value;\n\n\t}\n\n\tget dashed() {\n\n\t\treturn 'USE_DASH' in this.defines;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( ( value === true ) !== this.dashed ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_DASH = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_DASH;\n\n\t\t}\n\n\t}\n\n\tget dashScale() {\n\n\t\treturn this.uniforms.dashScale.value;\n\n\t}\n\n\tset dashScale( value ) {\n\n\t\tthis.uniforms.dashScale.value = value;\n\n\t}\n\n\tget dashSize() {\n\n\t\treturn this.uniforms.dashSize.value;\n\n\t}\n\n\tset dashSize( value ) {\n\n\t\tthis.uniforms.dashSize.value = value;\n\n\t}\n\n\tget dashOffset() {\n\n\t\treturn this.uniforms.dashOffset.value;\n\n\t}\n\n\tset dashOffset( value ) {\n\n\t\tthis.uniforms.dashOffset.value = value;\n\n\t}\n\n\tget gapSize() {\n\n\t\treturn this.uniforms.gapSize.value;\n\n\t}\n\n\tset gapSize( value ) {\n\n\t\tthis.uniforms.gapSize.value = value;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( value ) {\n\n\t\tif ( ! this.uniforms ) return;\n\t\tthis.uniforms.opacity.value = value;\n\n\t}\n\n\tget resolution() {\n\n\t\treturn this.uniforms.resolution.value;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tthis.uniforms.resolution.value.copy( value );\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( ! this.defines ) return;\n\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\n\t\tif ( uniforms && uniforms.resolution ) {\n\n\t\t\trenderer.getViewport( _viewport );\n\t\t\tthis.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nclass LineGeometry extends LineSegmentsGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineGeometry = true;\n\n\t\tthis.type = 'LineGeometry';\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst points = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setPositions( points );\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst colors = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setColors( colors );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\t// converts a vector3 or vector2 array to pairs format\n\n\t\tconst length = points.length - 1;\n\t\tconst positions = new Float32Array( 6 * length );\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tpositions[ 6 * i ] = points[ i ].x;\n\t\t\tpositions[ 6 * i + 1 ] = points[ i ].y;\n\t\t\tpositions[ 6 * i + 2 ] = points[ i ].z || 0;\n\n\t\t\tpositions[ 6 * i + 3 ] = points[ i + 1 ].x;\n\t\t\tpositions[ 6 * i + 4 ] = points[ i + 1 ].y;\n\t\t\tpositions[ 6 * i + 5 ] = points[ i + 1 ].z || 0;\n\n\t\t}\n\n\t\tsuper.setPositions( positions );\n\n\t\treturn this;\n\n\t}\n\n\tfromLine( line ) {\n\n\t\tconst geometry = line.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { LineGeometry };\n","import { LineSegments2 } from '../lines/LineSegments2.js';\nimport { LineGeometry } from '../lines/LineGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n\n\tconstructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLine2 = true;\n\n\t\tthis.type = 'Line2';\n\n\t}\n\n}\n\nexport { Line2 };\n","import { Color, Vector2 } from \"three\";\nimport { Line2 } from \"three/addons/lines/Line2.js\";\nimport { LineGeometry } from \"three/addons/lines/LineGeometry.js\";\nimport { LineMaterial } from \"three/addons/lines/LineMaterial.js\";\nimport { GizmoOptionsFallback } from \"../types\";\nimport { GIZMO_AXES, GIZMO_SPHERE_AXES_DISTANCE } from \"./constants\";\n\nexport const axesLines = (options: GizmoOptionsFallback) => {\n  const colorManager = new Color();\n  const positions: number[] = [];\n  const colors: number[] = [];\n  const { isSphere } = options;\n\n  GIZMO_AXES.forEach((axisName, i) => {\n    const { enabled, line, scale, color } = options[axisName];\n\n    if (!enabled || !line) return;\n\n    const negative = i < 3 ? 1 : -1;\n    const distance = isSphere ? GIZMO_SPHERE_AXES_DISTANCE - scale / 2 : 0.975;\n    const point = distance * negative;\n\n    positions.push(\n      axisName.includes(\"x\") ? point : 0,\n      axisName.includes(\"y\") ? point : 0,\n      axisName.includes(\"z\") ? point : 0,\n      0,\n      0,\n      0\n    );\n\n    const colorArray = colorManager.set(color).toArray();\n    colors.push(...colorArray, ...colorArray);\n  });\n\n  if (!positions.length) return null;\n\n  const geometry = new LineGeometry().setPositions(positions).setColors(colors);\n\n  const material = new LineMaterial({\n    linewidth: options.lineWidth,\n    vertexColors: true,\n    resolution: new Vector2(window.innerWidth, window.innerHeight),\n  });\n\n  return new Line2(geometry, material).computeLineDistances();\n};\n","import { GizmoOptionsFallback, GizmoAxisObject } from \"../types\";\nimport { axesMap } from \"./axesMap\";\nimport { axesFaces } from \"./axesFaces\";\nimport { axesCorners } from \"./axesCorners\";\nimport { axesEdges } from \"./axesEdges\";\nimport { gizmoBackground } from \"./gizmoBackground\";\nimport { axesLines } from \"./axesLines\";\n\nexport const axesObjects = (options: GizmoOptionsFallback) => {\n  const { corners, edges } = options;\n\n  const axes: GizmoAxisObject[] = [];\n  const map = axesMap(options);\n\n  const faces = axesFaces(options, map);\n\n  axes.push(...faces);\n  if (corners.enabled) axes.push(...axesCorners(options, map));\n  if (edges.enabled)\n    axes.push(...axesEdges(options, map, corners.enabled ? 7 : 6));\n\n  const background = gizmoBackground(faces, options);\n\n  const lines = axesLines(options);\n\n  return [axes, background, lines] as const;\n};\n","import { GizmoAxisObject } from \"@lib/types\";\nimport { setMapHoverOffset } from \"./axesMap\";\n\nexport const axisHover = (axis: GizmoAxisObject, hovered: boolean = true) => {\n  const { material, userData } = axis;\n\n  const { opacity, color, scale } = hovered ? userData.hover : userData;\n\n  axis.scale.setScalar(scale);\n  material.opacity = opacity;\n\n  if (material.map) setMapHoverOffset(material.map, hovered);\n  else material.color.set(color);\n};\n","import {\n  Camera,\n  Clock,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Scene,\n  Spherical,\n  Vector2,\n  Vector3,\n  Vector4,\n  type WebGLRenderer,\n} from \"three\";\n\nimport { gizmoDomElement, setDomPlacement } from \"./utils/gizmoDomElement\";\nimport { getDomElement } from \"./utils/getDomElement\";\nimport { updateAxis } from \"./utils/updateAxis\";\nimport { isClick } from \"./utils/isClick\";\nimport { intersectedObjects } from \"./utils/intersectedObjects\";\n\nimport {\n  GizmoOptions,\n  ViewportGizmoEventMap,\n  GizmoAxisOptions,\n  GizmoOptionsFallback,\n  GizmoAxisObject,\n  GizmoViewportArray,\n} from \"./types\";\nimport { GIZMO_EPSILON, GIZMO_TURN_RATE } from \"./utils/constants\";\nimport { updateBackground } from \"./utils/updateBackground\";\nimport type { OrbitControls } from \"three/examples/jsm/Addons.js\";\nimport { optionsFallback } from \"./utils/optionsFallback\";\nimport { clamp } from \"three/src/math/MathUtils.js\";\nimport { axesObjects } from \"./utils/axesObjects\";\nimport { axisHover } from \"./utils/axisHover\";\nimport type { WebGPURenderer } from \"three/webgpu\";\n\nexport type { GizmoOptions, ViewportGizmoEventMap, GizmoAxisOptions };\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _spherical = /*@__PURE__*/ new Spherical();\nconst _vec2 = /*@__PURE__*/ new Vector2();\nconst _vec3 = /*@__PURE__*/ new Vector3();\nconst _vec4 = /*@__PURE__*/ new Vector4();\n\n/**\n * ViewportGizmo is a 3D camera orientation controller that provides a visual interface\n * for changing the camera's viewing angle. It creates a widget that shows the current\n * camera orientation and allows direct manipulation of the view through clicking or dragging.\n *\n * @fires ViewportGizmo#start - Fired when a view change interaction begins\n * @fires ViewportGizmo#change - Fired during view changes\n * @fires ViewportGizmo#end - Fired when a view change interaction ends\n *\n * @extends Object3D\n */\nexport class ViewportGizmo extends Object3D<ViewportGizmoEventMap> {\n  /** Whether the gizmo is currently active and responding to user input */\n  enabled: boolean = true;\n\n  /** The camera being controlled by this gizmo */\n  camera: OrthographicCamera | PerspectiveCamera;\n\n  /** The WebGLRenderer rendering the gizmo */\n  renderer: WebGLRenderer | WebGPURenderer;\n\n  /** The configuration options */\n  options!: GizmoOptions;\n\n  /** The point around which the camera rotates */\n  target = new Vector3();\n\n  /** Whether view changes should be animated */\n  animated: boolean = true;\n\n  /** The speed of view change animations. Higher values result in faster animations */\n  speed: number = 1;\n\n  /**\n   * Indicates whether the gizmo is currently being animated or not,\n   * Useful when interacting with other camera controllers\n   *\n   * @readonly This value is set internally.\n   **/\n  animating = false;\n\n  private _options!: GizmoOptionsFallback;\n  private _intersections!: GizmoAxisObject[];\n  private _background: Mesh<any, MeshBasicMaterial> | null = null;\n  private _viewport: GizmoViewportArray = [0, 0, 0, 0];\n  private _originalViewport: GizmoViewportArray = [0, 0, 0, 0];\n  private _originalScissor: GizmoViewportArray = [0, 0, 0, 0];\n  private _scene: Scene;\n  private _camera!: Camera;\n  private _container!: HTMLElement;\n  private _domElement!: HTMLElement;\n  private _domRect!: DOMRect;\n  private _dragging: boolean = false;\n  private _distance: number = 0;\n  private _clock: Clock = new Clock();\n  private _targetQuaternion = new Quaternion();\n  private _quaternionStart = new Quaternion();\n  private _quaternionEnd = new Quaternion();\n  private _pointerStart = new Vector2();\n  private _focus: GizmoAxisObject | null = null;\n  private _placement!: GizmoOptionsFallback[\"placement\"];\n  private _controls?: OrbitControls;\n  private _controlsListeners?: {\n    start: () => void;\n    end: () => void;\n    change: () => void;\n  };\n\n  /**\n   * Creates a new ViewportGizmo instance.\n   *\n   * @param camera - The camera to be controlled by this gizmo\n   * @param renderer - The WebGL renderer used to render the scene\n   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.\n   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string\n   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'\n   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128\n   * @param options.placement - Position of the gizmo in the viewport\n   *    Options include:\n   *    - `\"top-left\"`\n   *    - `\"top-center\"`\n   *    - `\"top-right\"`\n   *    - `\"center-left\"`\n   *    - `\"center-center\"`\n   *    - `\"center-right\"`\n   *    - `\"bottom-left\"`\n   *    - `\"bottom-center\"`\n   *    - `\"bottom-right\"`\n   * @param options.offset - Offset of the gizmo from container edges in pixels\n   * @param options.offset.left - Offset from the left edge\n   * @param options.offset.top - Offset from the top edge\n   * @param options.offset.right - Offset from the right edge\n   * @param options.offset.bottom - Offset from the bottom edge\n   * @param options.animated - Whether view changes should be animated. Defaults to true\n   * @param options.speed - Animation speed multiplier. Defaults to 1\n   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube\n   * @param options.lineWidth - Width of the axes lines in pixels\n   * @param options.id - HTML `id` attribute for the gizmo container\n   * @param options.className - HTML `class` attribute for the gizmo container\n   * @param options.font - Font configuration for axis labels\n   * @param options.font.family - Font family for axis labels\n   * @param options.font.weight - Font weight for axis labels\n   * @param options.background - Configuration for the background sphere/cube\n   * @param options.background.enabled - Whether to display the background\n   * @param options.background.color - Color of the background in normal state\n   * @param options.background.opacity - Opacity of the background in normal state\n   * @param options.background.hover.color - Color of the background when hovered\n   * @param options.background.hover.opacity - Opacity of the background when hovered\n   * @param options.corners - Configuration for corner indicators\n   * @param options.corners.enabled - Whether to display corner indicators\n   * @param options.corners.color - Base color of corner indicators\n   * @param options.corners.opacity - Opacity of corner indicators\n   * @param options.corners.scale - Scale multiplier for corner indicators\n   * @param options.corners.radius - Radius of corner indicators\n   * @param options.corners.smoothness - Smoothness of corner indicators\n   * @param options.corners.hover.color - Color of corner indicators when hovered\n   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered\n   * @param options.corners.hover.scale - Scale of corner indicators when hovered\n   * @param options.edges - Configuration for edge indicators\n   * @param options.edges.enabled - Whether to display edge indicators\n   * @param options.edges.color - Base color of edge indicators\n   * @param options.edges.opacity - Opacity of edge indicators\n   * @param options.edges.scale - Scale multiplier for edge indicators\n   * @param options.edges.radius - Radius of edge indicators\n   * @param options.edges.smoothness - Smoothness of edge indicators\n   * @param options.edges.hover.color - Color of edge indicators when hovered\n   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered\n   * @param options.edges.hover.scale - Scale of edge indicators when hovered\n   * @param options.x - Configuration for positive X axis/face\n   * @param options.y - Configuration for positive Y axis/face\n   * @param options.z - Configuration for positive Z axis/face\n   * @param options.nx - Configuration for negative X axis/face\n   * @param options.ny - Configuration for negative Y axis/face\n   * @param options.nz - Configuration for negative Z axis/face\n   *\n   * @remarks Axis-specific configuration can also use alias names for cube mode:\n   * - `right` (same as `x`)\n   * - `left` (same as `nx`)\n   * - `top` (same as `y`)\n   * - `bottom` (same as `ny`)\n   * - `front` (same as `z`)\n   * - `back` (same as `nz`)\n   *\n   * For each axis/face configuration, the following options are available:\n   * @param options.AXIS.enabled - Whether to draw the axis\n   * @param options.AXIS.label - Custom text label for the axis\n   * @param options.AXIS.opacity - Axis opacity\n   * @param options.AXIS.scale - Scale multiplier for indicator size\n   * @param options.AXIS.line - Whether to draw the axis line\n   * @param options.AXIS.color - Axis indicator background color\n   * @param options.AXIS.labelColor - Axis label color\n   * @param options.AXIS.border.size - Border size around the axis indicator\n   * @param options.AXIS.border.color - Border color around the axis indicator\n   * @param options.AXIS.hover.color - Fill color on hover\n   * @param options.AXIS.hover.labelColor - Label text color on hover\n   * @param options.AXIS.hover.opacity - Opacity when hovered\n   * @param options.AXIS.hover.scale - Indicator scale when hovered\n   * @param options.AXIS.hover.border.size - Hover border size\n   * @param options.AXIS.hover.border.color - Hover border color\n   */\n  constructor(\n    camera: PerspectiveCamera | OrthographicCamera,\n    renderer: WebGLRenderer | WebGPURenderer,\n    options: GizmoOptions = {}\n  ) {\n    super();\n\n    this.camera = camera;\n    this.renderer = renderer;\n    this._scene = new Scene().add(this);\n    this.set(options);\n  }\n\n  /** Gets the current placement of the gizmo relative to its container. */\n  get placement(): GizmoOptionsFallback[\"placement\"] {\n    return this._placement;\n  }\n\n  /**\n   * Sets and update the placement of the gizmo relative to its container.\n   *\n   * @param placement - The new placement position\n   */\n  set placement(placement: GizmoOptionsFallback[\"placement\"]) {\n    this._placement = setDomPlacement(this._domElement, placement);\n    this.domUpdate();\n  }\n\n  /**\n   * Regenerates the gizmo with the new options.\n   *\n   * @remarks\n   * - Not recommended for use in real-time rendering or animation loops\n   * - Provides a way to completely rebuild the gizmo with new options\n   * - Can be computationally expensive, so use sparingly\n   */\n  set(options: GizmoOptions = {}) {\n    this.dispose();\n\n    this.options = options;\n    this._options = optionsFallback(options);\n\n    this._camera = this._options.isSphere\n      ? new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 5, 10)\n      : new PerspectiveCamera(26, 1, 5, 10);\n\n    this._camera.position.set(0, 0, 7);\n\n    const [axes, background, lines] = axesObjects(this._options);\n\n    if (background) this.add(background);\n    if (lines) this.add(lines);\n    this.add(...axes);\n\n    this._background = background;\n    this._intersections = axes;\n\n    const { container, animated, speed } = this._options;\n\n    this.animated = animated;\n    this.speed = speed;\n\n    this._container = container\n      ? getDomElement(container as string)\n      : document.body;\n\n    this._domElement = gizmoDomElement(this._options);\n    this._domElement.onpointerdown = (e) => this._onPointerDown(e);\n    this._domElement.onpointermove = (e) => this._onPointerMove(e);\n    this._domElement.onpointerleave = () => this._onPointerLeave();\n\n    this._container.appendChild(this._domElement);\n\n    if (this._controls) this.attachControls(this._controls);\n\n    this.update();\n\n    return this;\n  }\n\n  /**\n   * Renders the gizmo to the screen.\n   * This method handles viewport and scissor management to ensure the gizmo\n   * renders correctly without affecting the main scene rendering.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  render() {\n    if (this.animating) this._animate();\n\n    const { renderer, _viewport } = this;\n\n    const _prevScissorTest = renderer.getScissorTest();\n    const _prevAutoClear = renderer.autoClear;\n\n    renderer.autoClear = false;\n    renderer.setViewport(..._viewport);\n    if (_prevScissorTest) renderer.setScissor(..._viewport);\n\n    renderer.clear(false, true, false);\n    renderer.render(this._scene, this._camera);\n\n    renderer.setViewport(...this._originalViewport);\n    if (_prevScissorTest) renderer.setScissor(...this._originalScissor);\n\n    renderer.autoClear = _prevAutoClear;\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's DOM-related properties based on its current position\n   * and size in the document.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  domUpdate() {\n    this._domRect = this._domElement.getBoundingClientRect();\n\n    const renderer = this.renderer;\n    const domRect = this._domRect;\n    const containerRect = renderer.domElement.getBoundingClientRect();\n\n    this._viewport.splice(\n      0,\n      4,\n      domRect.left - containerRect.left,\n      renderer.domElement.clientHeight -\n        (domRect.top - containerRect.top + domRect.height),\n      domRect.width,\n      domRect.height\n    );\n\n    renderer.getViewport(_vec4).toArray(this._originalViewport);\n    if (renderer.getScissorTest())\n      renderer.getScissor(_vec4).toArray(this._originalScissor);\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's orientation to match the current camera orientation.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  cameraUpdate() {\n    this._updateOrientation();\n    return this;\n  }\n\n  /**\n   * Performs a complete update of the gizmo, including both DOM and camera-related updates.\n   *\n   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  update(controls: boolean = true) {\n    if (controls && this._controls) this._controls.update();\n    return this.domUpdate().cameraUpdate();\n  }\n\n  /**\n   * Connects OrbitControls with the gizmo, handling interaction states and updates.\n   * Automatically detaches any previously attached controls.\n   *\n   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}\n   */\n  attachControls(controls: OrbitControls) {\n    this.detachControls();\n\n    this.target = controls.target;\n\n    this._controlsListeners = {\n      start: () => (controls.enabled = false),\n      end: () => (controls.enabled = true),\n      change: () => this.update(false),\n    };\n\n    this.addEventListener(\"start\", this._controlsListeners.start);\n    this.addEventListener(\"end\", this._controlsListeners.end);\n    controls.addEventListener(\"change\", this._controlsListeners.change);\n\n    this._controls = controls;\n\n    return this;\n  }\n\n  /** Removes all control event listeners and references. Safe to call multiple times. */\n  detachControls() {\n    if (!this._controlsListeners || !this._controls) return;\n\n    this.target = new Vector3().copy(this._controls.target);\n\n    this.removeEventListener(\"start\", this._controlsListeners.start);\n    this.removeEventListener(\"end\", this._controlsListeners.end);\n\n    this._controls.removeEventListener(\n      \"change\",\n      this._controlsListeners.change\n    );\n\n    this._controlsListeners = undefined;\n    this._controls = undefined;\n\n    return this;\n  }\n\n  /** Cleans up all resources including geometries, materials, textures, and event listeners. */\n  dispose() {\n    this.detachControls();\n\n    this.children.forEach((child) => {\n      this.remove(child);\n      const mesh = child as Mesh<any, MeshBasicMaterial>;\n      mesh.material?.dispose();\n      mesh.material?.map?.dispose();\n      mesh.geometry?.dispose();\n    });\n\n    this._domElement?.remove();\n  }\n\n  /**\n   * Updates the gizmo's orientation either based on the camera or internal state.\n   *\n   * @private\n   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)\n   */\n  private _updateOrientation(fromCamera: boolean = true) {\n    if (fromCamera) {\n      this.quaternion.copy(this.camera.quaternion).invert();\n      this.updateMatrixWorld();\n    }\n\n    updateAxis(this._options, this._intersections, this.camera);\n  }\n\n  /**\n   * Handles the animation of camera position and orientation changes.\n   *\n   * @private\n   */\n  private _animate() {\n    const { position, quaternion } = this.camera;\n\n    position.set(0, 0, 1);\n\n    if (!this.animated) {\n      position\n        .applyQuaternion(this._quaternionEnd)\n        .multiplyScalar(this._distance)\n        .add(this.target);\n\n      quaternion.copy(this._targetQuaternion);\n\n      this._updateOrientation();\n\n      this.animating = false;\n      this.dispatchEvent({ type: \"change\" });\n      this.dispatchEvent({ type: \"end\" });\n      return;\n    }\n\n    if (this._controls) this._controls.enabled = false;\n\n    const delta = this._clock.getDelta();\n\n    const step = delta * GIZMO_TURN_RATE * this.speed;\n\n    this._quaternionStart.rotateTowards(this._quaternionEnd, step);\n\n    position\n      .applyQuaternion(this._quaternionStart)\n      .multiplyScalar(this._distance)\n      .add(this.target);\n\n    quaternion.rotateTowards(this._targetQuaternion, step);\n\n    this._updateOrientation();\n    // FIXME - Need fix?\n    requestAnimationFrame(() => this.dispatchEvent({ type: \"change\" }));\n\n    if (this._quaternionStart.angleTo(this._quaternionEnd) < GIZMO_EPSILON) {\n      if (this._controls) this._controls.enabled = true;\n      this.animating = false;\n      this.dispatchEvent({ type: \"end\" });\n    }\n  }\n\n  /**\n   * Sets the camera orientation to look at the target from a specific axis.\n   *\n   * @private\n   * @param position - The axis point position\n   */\n  private _setOrientation(position: Vector3) {\n    const camera = this.camera;\n    const focusPoint = this.target;\n\n    _vec3.copy(position).multiplyScalar(this._distance);\n\n    _matrix.setPosition(_vec3).lookAt(_vec3, this.position, this.up);\n    this._targetQuaternion.setFromRotationMatrix(_matrix);\n\n    _vec3.add(focusPoint);\n\n    _matrix.lookAt(_vec3, focusPoint, this.up);\n    this._quaternionEnd.setFromRotationMatrix(_matrix);\n\n    _matrix\n      .setPosition(camera.position)\n      .lookAt(camera.position, focusPoint, this.up);\n    this._quaternionStart.setFromRotationMatrix(_matrix);\n\n    this.animating = true;\n    this._clock.start();\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Handles the pointer down event for starting drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerDown(e: PointerEvent) {\n    if (!this.enabled) return;\n\n    const drag = (e: PointerEvent) => {\n      if (!this._dragging) {\n        if (isClick(e, this._pointerStart)) return;\n        this._dragging = true;\n      }\n\n      const pointerAngle = _vec2\n        .set(e.clientX, e.clientY)\n        .sub(this._pointerStart)\n        .multiplyScalar((1 / this._domRect.width) * Math.PI);\n\n      const direction = this.coordinateConversion(\n        _vec3.subVectors(this.camera.position, this.target)\n      );\n\n      const spherical = _spherical.setFromVector3(direction);\n\n      spherical.theta = initialTheta - pointerAngle.x;\n      spherical.phi = clamp(\n        initialPhi - pointerAngle.y,\n        GIZMO_EPSILON,\n        Math.PI - GIZMO_EPSILON\n      );\n\n      this.coordinateConversion(\n        this.camera.position.setFromSpherical(spherical),\n        true\n      ).add(this.target);\n\n      this.camera.lookAt(this.target);\n\n      this.quaternion.copy(this.camera.quaternion).invert();\n\n      this._updateOrientation(false);\n      this.dispatchEvent({ type: \"change\" });\n    };\n\n    const endDrag = () => {\n      document.removeEventListener(\"pointermove\", drag, false);\n      document.removeEventListener(\"pointerup\", endDrag, false);\n\n      if (!this._dragging) return this._handleClick(e);\n\n      if (this._focus) {\n        axisHover(this._focus, false);\n        this._focus = null;\n      }\n\n      this._dragging = false;\n      this.dispatchEvent({ type: \"end\" });\n    };\n\n    if (this.animating) return;\n\n    e.preventDefault();\n    this._pointerStart.set(e.clientX, e.clientY);\n\n    const direction = this.coordinateConversion(\n      _vec3.subVectors(this.camera.position, this.target)\n    );\n\n    const initialSpherical = _spherical.setFromVector3(direction);\n    const initialTheta = initialSpherical.theta;\n    const initialPhi = initialSpherical.phi;\n    this._distance = initialSpherical.radius;\n\n    document.addEventListener(\"pointermove\", drag, false);\n    document.addEventListener(\"pointerup\", endDrag, false);\n\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Converts the input-coordinates from the standard Y-axis up to what is set in Object3D.DEFAULT_UP.\n   *\n   * @private\n   * @param target      - The target Vector3 to be converted\n   * @param isSpherical - Whether or not the coordinates are for a sphere\n   * @returns The converted coordinates\n   */\n  private coordinateConversion(target: Vector3, isSpherical = false) {\n    const { x, y, z } = target;\n\n    const defaultUp = Object3D.DEFAULT_UP;\n\n    if (defaultUp.x === 1)\n      return isSpherical ? target.set(y, z, x) : target.set(z, x, y);\n\n    if (defaultUp.z === 1)\n      return isSpherical ? target.set(z, x, y) : target.set(y, z, x);\n\n    return target;\n  }\n\n  /**\n   * Handles pointer move events for hover effects and drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerMove(e: PointerEvent) {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._background) updateBackground(this._background, true);\n\n    this._handleHover(e);\n  }\n\n  /**\n   * Handles pointer leave events to reset hover states.\n   *\n   * @private\n   */\n  private _onPointerLeave() {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._background) updateBackground(this._background, false);\n    if (this._focus) axisHover(this._focus, false);\n\n    this._domElement.style.cursor = \"\";\n  }\n\n  /**\n   * Handles click events for axis selection.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleClick(e: PointerEvent) {\n    const intersection = intersectedObjects(\n      e,\n      this._domRect,\n      this._camera,\n      this._intersections\n    );\n\n    if (this._focus) {\n      axisHover(this._focus, false);\n      this._focus = null;\n    }\n\n    if (!intersection) return;\n\n    this._setOrientation(intersection.object.position);\n\n    this.dispatchEvent({ type: \"change\" });\n  }\n\n  /**\n   * Handles hover effects for interactive elements.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleHover(e: PointerEvent) {\n    const intersection = intersectedObjects(\n      e,\n      this._domRect,\n      this._camera,\n      this._intersections\n    );\n\n    const object = intersection?.object || null;\n\n    if (this._focus === object) return;\n\n    this._domElement.style.cursor = object ? \"pointer\" : \"\";\n\n    if (this._focus) axisHover(this._focus, false);\n\n    if ((this._focus = object)) axisHover(object, true);\n    else updateAxis(this._options, this._intersections, this.camera);\n  }\n}\n"],"names":["setDomPlacement","domElement","placement","y","x","gizmoDomElement","size","offset","id","className","div","top","left","right","bottom","getDomElement","element","clamp","value","min","max","axisMap","point","Vector3","updateAxis","isSphere","axes","camera","axis","positiveIndex","negativeIndex","object","opacity","isClick","e","startCoords","threshold","_raycaster","Raycaster","_mouse","Vector2","intersectedObjects","event","domRect","intersections","intersects","a","b","DISTANCE_THRESHOLD","closestDistance","nearHits","hit","intersection","GIZMO_EPSILON","GIZMO_TURN_RATE","GIZMO_MAIN_AXES","GIZMO_AXES","GIZMO_AXES_Z_UP","GIZMO_AXES_X_UP","GIZMO_FACE_RIGHT","GIZMO_FACE_TOP","GIZMO_FACE_FRONT","GIZMO_FACE_LEFT","GIZMO_FACE_BOTTOM","GIZMO_FACE_BACK","GIZMO_FACES","face","GIZMO_SPHERE_AXES_DISTANCE","updateBackground","background","hovered","material","userData","color","deepClone","obj","optionsFallback","options","type","isRoundedCube","resolution","defaultUp","Object3D","zUp","xUp","container","faceAxis","index","axesFallback","negativeAxesFallback","assignNestedDefaults","mergedOptions","target","defaultObjects","defaults","key","axesMap","colorManager","Color","doubleOffset","radius","font","corners","edges","canvas","ctx","fontStyle","fontYFix","getFontStyle","label","labelColor","border","hoverColor","hoverLabel","hoverBorder","drawAxis","colsCount","offsetX","offsetY","cellHeight","map","CanvasTexture","SRGBColorSpace","RepeatWrapping","drawRoundRectPath","halfBorderWidth","drawText","text","_a","_b","family","weight","square","fontSize","textWidth","textHeight","measure","yFix","scaleFactor","finalFontSize","setMapHoverOffset","hover","setMapColumnOffset","col","roundedRectangleGeometry","smoothness","width","height","wi","hi","ul","ur","vl","vh","positions","uvs","n","indices","i","phi","cos","sin","xc","yc","uc","vc","idx","j","BufferGeometry","BufferAttribute","axesFaces","texture","faceLength","geometry","_","isPositive","enabled","scale","materialConfig","Sprite","SpriteMaterial","Mesh","MeshBasicMaterial","direction","axesCorners","SphereGeometry","positionOffsetRatio","val","corner","i3","axesEdges","textureColumn","edgeLength","CylinderGeometry","edge","mergeGeometries","geometries","useGroups","isIndexed","attributesUsed","morphAttributesUsed","attributes","morphAttributes","morphTargetsRelative","mergedGeometry","attributesCount","name","count","indexOffset","mergedIndex","mergedAttribute","mergeAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","gpuType","arrayLength","attribute","array","result","tupleOffset","c","gizmoBackground","faces","BackSide","plane","originalScale","planeGeometry","_box","Box3","_vector","LineSegmentsGeometry","InstancedBufferGeometry","Float32BufferAttribute","matrix","start","end","lineSegments","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","mesh","WireframeGeometry","Sphere","center","maxRadiusSq","il","UniformsLib","ShaderLib","UniformsUtils","LineMaterial","ShaderMaterial","parameters","_viewport","Vector4","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","distance","raycastWorldUnits","matrixWorld","instanceStart","instanceEnd","segmentCount","l","pointOnLine","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","lineDistances","instanceDistanceBuffer","raycaster","worldUnits","sphereMargin","distanceToSphere","boxMargin","distanceToBox","renderer","uniforms","LineGeometry","length","points","line","Line2","axesLines","axisName","negative","colorArray","axesObjects","lines","axisHover","_matrix","_spherical","Spherical","_vec2","_vec3","_vec4","ViewportGizmo","__publicField","Clock","Quaternion","Scene","OrthographicCamera","PerspectiveCamera","animated","speed","_prevScissorTest","_prevAutoClear","containerRect","controls","child","_c","_d","fromCamera","position","quaternion","step","focusPoint","drag","pointerAngle","spherical","initialTheta","initialPhi","endDrag","initialSpherical","isSpherical","z"],"mappings":"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","x_google_ignoreList":[2,15,17,18,19,20,21]}