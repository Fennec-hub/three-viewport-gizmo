{"version":3,"file":"three-viewport-gizmo.js","sources":["../lib/utils/createDomElement.ts","../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../node_modules/three/examples/jsm/lines/LineMaterial.js","../node_modules/three/examples/jsm/lines/LineSegments2.js","../node_modules/three/examples/jsm/lines/LineGeometry.js","../node_modules/three/examples/jsm/lines/Line2.js","../lib/utils/constants.ts","../lib/utils/getAxesLines.ts","../lib/utils/getDomElement.ts","../lib/utils/getBackgroundSphere.ts","../lib/utils/getSpriteMaterial.ts","../lib/utils/getAxesSpritePoints.ts","../lib/utils/updateSpritesOpacity.ts","../lib/utils/isClick.ts","../lib/utils/resetSprites.ts","../lib/utils/getIntersectionObject.ts","../lib/utils/clamp.ts","../lib/utils/setSphereColor.ts","../lib/ViewportGizmo.ts"],"sourcesContent":["import { GizmoDomPlacement, GizmoOptions } from \"../types\";\n\nexport const createDomElement = (\n  placement: GizmoDomPlacement,\n  size: number,\n  offset: Required<GizmoOptions>[\"offset\"],\n  id?: string,\n  className?: string\n) => {\n  const div = document.createElement(\"div\");\n\n  const top = offset.top ?? 0;\n  const left = offset.left ?? 0;\n  const right = offset.right ?? 0;\n  const bottom = offset.bottom ?? 0;\n  const [y, x] = placement.split(\"-\");\n\n  Object.assign(div.style, {\n    height: `${size}px`,\n    width: `${size}px`,\n    borderRadius: \"100%\",\n    position: \"absolute\",\n    background: \"#fff3\",\n    opacity: \"0\",\n    zIndex: \"10000\",\n    transform: `${x === \"center\" ? \"translateX(-50%)\" : \"\"} ${\n      y === \"center\" ? \"translateY(-50%)\" : \"\"\n    }`,\n    margin: `${top}px ${right}px ${bottom}px ${left}px`,\n    left: x === \"left\" ? \"0\" : x === \"center\" ? `50%` : \"\",\n    right: x === \"right\" ? \"0\" : \"\",\n    top: y === \"top\" ? \"0\" : y === \"bottom\" ? \"\" : \"50%\",\n    bottom: y === \"bottom\" ? \"0\" : \"\",\n  });\n\n  if (id) div.id = id;\n  if (className) div.className = className;\n\n  return div;\n};\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n","/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nimport {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2\n} from 'three';\n\n\nUniformsLib.line = {\n\n\tworldUnits: { value: 1 },\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashOffset: { value: 0 },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t/* glsl */`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t/* glsl */`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttype: 'LineMaterial',\n\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tthis.isLineMaterial = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget color() {\n\n\t\treturn this.uniforms.diffuse.value;\n\n\t}\n\n\tset color( value ) {\n\n\t\tthis.uniforms.diffuse.value = value;\n\n\t}\n\n\tget worldUnits() {\n\n\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t}\n\n\t}\n\n\tget linewidth() {\n\n\t\treturn this.uniforms.linewidth.value;\n\n\t}\n\n\tset linewidth( value ) {\n\n\t\tif ( ! this.uniforms.linewidth ) return;\n\t\tthis.uniforms.linewidth.value = value;\n\n\t}\n\n\tget dashed() {\n\n\t\treturn 'USE_DASH' in this.defines;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( ( value === true ) !== this.dashed ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_DASH = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_DASH;\n\n\t\t}\n\n\t}\n\n\tget dashScale() {\n\n\t\treturn this.uniforms.dashScale.value;\n\n\t}\n\n\tset dashScale( value ) {\n\n\t\tthis.uniforms.dashScale.value = value;\n\n\t}\n\n\tget dashSize() {\n\n\t\treturn this.uniforms.dashSize.value;\n\n\t}\n\n\tset dashSize( value ) {\n\n\t\tthis.uniforms.dashSize.value = value;\n\n\t}\n\n\tget dashOffset() {\n\n\t\treturn this.uniforms.dashOffset.value;\n\n\t}\n\n\tset dashOffset( value ) {\n\n\t\tthis.uniforms.dashOffset.value = value;\n\n\t}\n\n\tget gapSize() {\n\n\t\treturn this.uniforms.gapSize.value;\n\n\t}\n\n\tset gapSize( value ) {\n\n\t\tthis.uniforms.gapSize.value = value;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( value ) {\n\n\t\tif ( ! this.uniforms ) return;\n\t\tthis.uniforms.opacity.value = value;\n\n\t}\n\n\tget resolution() {\n\n\t\treturn this.uniforms.resolution.value;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tthis.uniforms.resolution.value.copy( value );\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( ! this.defines ) return;\n\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\t\t\tthis.extensions.derivatives = true;\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\t\t\tthis.extensions.derivatives = false;\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nclass LineGeometry extends LineSegmentsGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineGeometry = true;\n\n\t\tthis.type = 'LineGeometry';\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst points = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setPositions( points );\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst colors = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setColors( colors );\n\n\t\treturn this;\n\n\t}\n\n\tfromLine( line ) {\n\n\t\tconst geometry = line.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { LineGeometry };\n","import { LineSegments2 } from '../lines/LineSegments2.js';\nimport { LineGeometry } from '../lines/LineGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n\n\tconstructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLine2 = true;\n\n\t\tthis.type = 'Line2';\n\n\t}\n\n}\n\nexport { Line2 };\n","import { GizmoOptions, OrientationAxes } from \"@lib/types\";\nimport { Vector3Tuple } from \"three\";\n\nexport const GIZMO_TURN_RATE = 2 * Math.PI;\n\nexport const GIZMO_DEFAULT_OPTIONS: GizmoOptions = {\n  container: document.body,\n  placement: \"top-right\",\n  size: 128,\n  lineWidth: 20,\n  animated: true,\n  speed: 1,\n  offset: {\n    top: 10,\n    left: 10,\n    right: 10,\n    bottom: 10,\n  },\n  font: {\n    family: \"helvetica\",\n    weight: 900,\n  },\n  resolution: 64,\n  sphere: {\n    enabled: true,\n    color: 0xffffff,\n    opacity: 0,\n    hoverColor: 0xffffff,\n    hoverOpacity: 0.2,\n  },\n  x: {\n    text: \"X\",\n    colors: {\n      main: \"#ff3653\",\n    },\n  },\n  y: {\n    text: \"Y\",\n    colors: {\n      main: \"#8adb00\",\n    },\n  },\n  z: {\n    text: \"Z\",\n    colors: {\n      main: \"#2c8fff\",\n    },\n  },\n  nx: {\n    line: false,\n    colors: {\n      main: \"#ff3653\",\n    },\n  },\n  ny: {\n    line: false,\n    colors: {\n      main: \"#8adb00\",\n    },\n  },\n  nz: {\n    line: false,\n    colors: {\n      main: \"#2c8fff\",\n    },\n  },\n};\n\nexport const GIZMO_AXES = [\"x\", \"y\", \"z\", \"nx\", \"ny\", \"nz\"] as const;\n\nexport const GIZMO_AXES_ORIENTATIONS: Record<\n  OrientationAxes,\n  [position: Vector3Tuple, orientation: Vector3Tuple]\n> = {\n  x: [\n    [1, 0, 0],\n    [0, Math.PI * 0.5, 0],\n  ],\n\n  y: [\n    [0, 1, 0],\n    [-Math.PI * 0.5, 0, 0],\n  ],\n\n  z: [\n    [0, 0, 1],\n    [0, 0, 0],\n  ],\n\n  nx: [\n    [-1, 0, 0],\n    [0, -Math.PI * 0.5, 0],\n  ],\n\n  ny: [\n    [0, -1, 0],\n    [Math.PI * 0.5, 0, 0],\n  ],\n\n  nz: [\n    [0, 0, -1],\n    [0, Math.PI, 0],\n  ],\n};\n","import { Color, Vector2 } from \"three\";\nimport { Line2 } from \"three/addons/lines/Line2.js\";\nimport { LineGeometry } from \"three/addons/lines/LineGeometry.js\";\nimport { LineMaterial } from \"three/addons/lines/LineMaterial.js\";\nimport { GizmoOptions } from \"../types\";\nimport { GIZMO_AXES } from \"./constants\";\n\nexport const getAxesLines = (options: GizmoOptions) => {\n  const colorManager = new Color();\n  const positions: number[] = [];\n  const colors: number[] = [];\n\n  GIZMO_AXES.forEach((key, i) => {\n    const axis = options[key]!;\n\n    if (axis.line === false) return;\n\n    const negative = i < 3 ? 1.1 : -1.1;\n    const distance = i < 3 ? 1 : 1.125;\n\n    positions.push(\n      key.includes(\"x\") ? distance * negative : 0,\n      key.includes(\"y\") ? distance * negative : 0,\n      key.includes(\"z\") ? distance * negative : 0,\n      0,\n      0,\n      0\n    );\n\n    const main = axis.colors!.main!;\n\n    const [color1, color2] = Array.isArray(main) ? main : [main, main];\n    colors.push(\n      ...colorManager.set(color2).toArray(),\n      ...colorManager.set(color1).toArray()\n    );\n  });\n\n  if (!positions.length) return null;\n\n  const geometry = new LineGeometry();\n  geometry.setPositions(positions);\n  geometry.setColors(colors);\n\n  const material = new LineMaterial({\n    linewidth: options.lineWidth ?? 20,\n    vertexColors: true,\n    resolution: new Vector2(window.innerWidth, window.innerHeight),\n  });\n\n  // Create Line2 instead of LineSegments\n  const line = new Line2(geometry, material);\n  line.computeLineDistances();\n  line.scale.set(1, 1, 1);\n  line.renderOrder = 1;\n\n  return line;\n};\n","export const getDomElement = (\n  domElement: string | HTMLElement\n): HTMLElement => {\n  const element =\n    typeof domElement === \"string\"\n      ? document.querySelector<HTMLElement>(domElement)\n      : domElement;\n\n  if (!element) throw Error(`Invalid DOM element`);\n\n  return element;\n};\n","import {\n  BackSide,\n  BufferGeometry,\n  ColorRepresentation,\n  Mesh,\n  MeshBasicMaterial,\n  SphereGeometry,\n} from \"three\";\n\nexport function getBackgroundSphere({\n  color,\n  opacity,\n}: { color?: ColorRepresentation; opacity?: number } = {}) {\n  const geometry = new SphereGeometry(1.8, 64, 64);\n  const sphere = new Mesh<BufferGeometry, MeshBasicMaterial>(\n    geometry,\n    new MeshBasicMaterial({\n      color,\n      side: BackSide,\n      transparent: true,\n      opacity: opacity ?? 0.2,\n    })\n  );\n\n  sphere.renderOrder = 0;\n\n  return sphere;\n}\n","import { GizmoOptions } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  RepeatWrapping,\n  SRGBColorSpace,\n  SpriteMaterial,\n} from \"three\";\n\nexport function getSpriteMaterial(\n  font: Required<GizmoOptions>[\"font\"],\n  resolution: number,\n  color: string,\n  text: string | undefined,\n  textColor: string | null,\n  hover: string | null,\n  hoverText: string | null,\n  circle: boolean = true,\n  border: boolean = false\n) {\n  const canvas = document.createElement(\"canvas\");\n  resolution = resolution ?? 64;\n\n  const offset = 0.02;\n\n  canvas.width = resolution * 2 + resolution * (offset * 4);\n  canvas.height = resolution + resolution * (offset * 2);\n\n  const radius = resolution / 2;\n  const centerY = resolution / 2 + resolution * offset;\n  const circle2X = centerY * 3;\n\n  const context = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n  drawCircle(context, radius, centerY, centerY, color, circle, border);\n  drawCircle(\n    context,\n    radius,\n    circle2X,\n    centerY,\n    hover || \"#FFF\",\n    circle,\n    border\n  );\n\n  if (text != null) {\n    const family = font.family || \"sans-serif\";\n    const weight = font.weight || 500;\n\n    const fixY = textFitBox(context, text, family, weight, resolution);\n\n    context.textAlign = \"center\";\n    context.textBaseline = \"middle\";\n    context.fillStyle = textColor || \"#000\";\n    context.fillText(text, centerY, centerY + fixY);\n    context.fillStyle = hoverText || textColor || \"#000\";\n    context.fillText(text, circle2X, centerY + fixY);\n  }\n\n  const texture = new CanvasTexture(canvas);\n  texture.colorSpace = SRGBColorSpace;\n  texture.wrapS = texture.wrapT = RepeatWrapping;\n  texture.repeat.x = 0.5;\n\n  return new SpriteMaterial({\n    map: texture,\n    toneMapped: false,\n    transparent: true,\n  });\n}\n\nfunction drawCircle(\n  context: CanvasRenderingContext2D,\n  radius: number,\n  x: number,\n  y: number,\n  color: string,\n  circle: boolean,\n  border: boolean = false\n) {\n  const borderSize = y * 0.1;\n  radius = border ? radius - borderSize : radius;\n\n  context.beginPath();\n  context.arc(x, y, radius, 0, 2 * Math.PI);\n  context.closePath();\n\n  if (border) context.globalAlpha = 0.2;\n\n  if (circle) {\n    context.fillStyle = color;\n    context.fill();\n  }\n\n  if (border) {\n    context.globalAlpha = 1;\n    context.strokeStyle = color;\n    context.lineWidth = borderSize;\n    context.stroke();\n  }\n}\n\nfunction textFitBox(\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  font: string,\n  weight: string | number,\n  size: number\n) {\n  const square = Math.sqrt(Math.pow(size * 0.7, 2) / 2);\n  let fontSize = square;\n  let textWidth = 0;\n  let textHeight = 0;\n\n  do {\n    ctx.font = `${weight} ${fontSize}px ${font}`;\n    const measure = ctx.measureText(text);\n    textWidth = measure.width;\n    textHeight = measure.fontBoundingBoxDescent;\n    fontSize--;\n  } while (textWidth > square && fontSize > 0);\n\n  const scaleFactor = Math.min(square / textWidth, square / textHeight);\n\n  const finalFontSize = Math.floor(fontSize * scaleFactor);\n\n  ctx.font = `${weight} ${finalFontSize}px ${font}`;\n\n  return square / textHeight;\n}\n","import { Color, Sprite } from \"three\";\nimport { getSpriteMaterial } from \"./getSpriteMaterial\";\nimport { GizmoOptions } from \"@lib/types\";\nimport { GIZMO_AXES } from \"./constants\";\n\nexport function getAxesSpritePoints(options: GizmoOptions) {\n  const colorManager = new Color();\n  const { font, resolution: spriteResolution } = options;\n\n  return GIZMO_AXES.map((key, i) => {\n    const { text, colors, circle, border } = options[key]!;\n    const isPositive = i < 3;\n    const axis = (isPositive ? key : key[1]) as \"x\" | \"y\" | \"z\";\n\n    const { text: textColor, main, hover, hoverText } = colors!;\n    const color = Array.isArray(main) ? main[1] : main!;\n    const forceScale = border && text;\n\n    const sprite = new Sprite(\n      getSpriteMaterial(\n        font!,\n        spriteResolution!,\n        colorManager.set(color).getStyle(),\n        text,\n        textColor != null ? colorManager.set(textColor).getStyle() : null,\n        hover != null ? colorManager.set(hover).getStyle() : null,\n        hoverText != null ? colorManager.set(hoverText).getStyle() : null,\n        circle ?? true,\n        border\n      )\n    );\n\n    sprite.userData.axis = key;\n    sprite.userData.forceScale = forceScale;\n    sprite.scale.setScalar(forceScale || isPositive ? 0.6 : 0.4);\n    sprite.position[axis] = isPositive ? 1.4 : -1.4;\n    sprite.renderOrder = 100;\n\n    return sprite;\n  });\n}\n","import { Camera, Sprite, Vector3 } from \"three\";\n\nconst axisMap: [\n  axis: \"x\" | \"y\" | \"z\",\n  positiveIndex: number,\n  negativeIndex: number\n][] = [\n  [\"x\", 0, 3],\n  [\"y\", 1, 4],\n  [\"z\", 2, 5],\n];\nconst primaryOpacity = 1;\nconst secondaryOpacity = 0.5;\n\nconst point = /*@__PURE__*/ new Vector3();\nexport function updateSpritesOpacity(sprites: Sprite[], camera: Camera): void {\n  point.set(0, 0, 1).applyQuaternion(camera.quaternion);\n\n  axisMap.forEach(([axis, positiveIndex, negativeIndex]) => {\n    const value = point[axis];\n\n    sprites[positiveIndex].material.opacity =\n      value >= 0 ? primaryOpacity : secondaryOpacity;\n    sprites[negativeIndex].material.opacity =\n      value >= 0 ? secondaryOpacity : primaryOpacity;\n  });\n}\n","import { Vector2 } from \"three\";\n\nexport const isClick = (\n  e: PointerEvent,\n  startCoords: Vector2,\n  threshold: number = 10\n) =>\n  Math.abs(e.clientX - startCoords.x) < threshold &&\n  Math.abs(e.clientY - startCoords.y) < threshold;\n","import { Sprite } from \"three\";\n\nexport function resetSprites(sprites: Sprite[]) {\n  for (let i = 0, l = sprites.length; i < l; i++) {\n    sprites[i].scale.setScalar(\n      i < 3 || sprites[i].userData.forceScale ? 0.6 : 0.4\n    );\n    sprites[i].material.map!.offset.x = 1;\n  }\n}\n","import { OrthographicCamera, Sprite, Vector2, Raycaster } from \"three\";\n\nconst _raycaster = /*@__PURE__*/ new Raycaster();\nconst _mouse = /*@__PURE__*/ new Vector2();\n\nexport function getIntersectionObject(\n  event: PointerEvent,\n  domRect: DOMRect,\n  orthoCamera: OrthographicCamera,\n  intersectionObjects: Sprite[]\n) {\n  _mouse.x = ((event.clientX - domRect.left) / domRect.width) * 2 - 1;\n  _mouse.y = -((event.clientY - domRect.top) / domRect.height) * 2 + 1;\n\n  _raycaster.setFromCamera(_mouse, orthoCamera);\n\n  const intersects = _raycaster.intersectObjects(intersectionObjects);\n\n  if (!intersects.length) return null;\n\n  const intersection = intersects[0];\n  return intersection.object as Sprite;\n}\n","export const clamp = (num: number, min: number, max: number) =>\n  Math.min(Math.max(num, min), max);\n","import { GizmoOptions } from \"@lib/types\";\nimport { BufferGeometry, Mesh, MeshBasicMaterial } from \"three\";\n\nexport const setSphereColor = (\n  sphere: Mesh<BufferGeometry, MeshBasicMaterial>,\n  { color, opacity, hoverColor, hoverOpacity }: GizmoOptions[\"sphere\"] = {},\n  hover: boolean = true\n) => {\n  const material = sphere.material;\n\n  material.color.set((hover && hoverColor) || color || 0xffffff);\n  material.opacity = hover ? hoverOpacity ?? 0.2 : opacity ?? 0;\n};\n","import {\n  BufferGeometry,\n  Clock,\n  Euler,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Sprite,\n  Vector2,\n  Vector3,\n  Vector4,\n  WebGLRenderer,\n} from \"three\";\n\nimport { createDomElement } from \"./utils/createDomElement\";\nimport { getAxesLines } from \"./utils/getAxesLines\";\nimport { getDomElement } from \"./utils/getDomElement\";\nimport { getBackgroundSphere } from \"./utils/getBackgroundSphere\";\nimport { getAxesSpritePoints } from \"./utils/getAxesSpritePoints\";\nimport { updateSpritesOpacity } from \"./utils/updateSpritesOpacity\";\nimport { isClick } from \"./utils/isClick\";\nimport { resetSprites } from \"./utils/resetSprites\";\nimport { getIntersectionObject } from \"./utils/getIntersectionObject\";\nimport { clamp } from \"./utils/clamp\";\n\nimport {\n  GizmoOptions,\n  ViewportGizmoEventMap,\n  GizmoDomPlacement,\n  GizmoAxisOptions,\n  OrientationAxes,\n} from \"./types\";\nimport {\n  GIZMO_AXES,\n  GIZMO_AXES_ORIENTATIONS,\n  GIZMO_DEFAULT_OPTIONS,\n  GIZMO_TURN_RATE,\n} from \"./utils/constants\";\nimport { setSphereColor } from \"./utils/setSphereColor\";\nimport type { OrbitControls } from \"three/examples/jsm/Addons.js\";\n\nexport type {\n  GizmoOptions,\n  ViewportGizmoEventMap,\n  GizmoDomPlacement,\n  GizmoAxisOptions,\n  OrientationAxes,\n};\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _euler = /*@__PURE__*/ new Euler();\n\n/**\n * ViewportGizmo is a 3D camera orientation controller that provides a visual interface\n * for changing the camera's viewing angle. It creates a widget that shows the current\n * camera orientation and allows direct manipulation of the view through clicking or dragging.\n *\n * @fires ViewportGizmo#start - Fired when a view change interaction begins\n * @fires ViewportGizmo#change - Fired during view changes\n * @fires ViewportGizmo#end - Fired when a view change interaction ends\n *\n * @extends Object3D\n */\nexport class ViewportGizmo extends Object3D<ViewportGizmoEventMap> {\n  /** Whether the gizmo is currently active and responding to user input */\n  enabled: boolean = true;\n\n  /** The camera being controlled by this gizmo */\n  camera: OrthographicCamera | PerspectiveCamera;\n\n  /** The point around which the camera rotates */\n  target = new Vector3();\n\n  /** Whether view changes should be animated */\n  animated: boolean = true;\n\n  /** The speed of view change animations. Higher values result in faster animations */\n  speed: number = 1;\n\n  /**\n   * Indicates whether the gizmo is currently being animated or not,\n   * Useful when interacting with other camera controllers\n   *\n   * @readonly This value is set internally.\n   **/\n  animating = false;\n\n  private _sphere?: Mesh<BufferGeometry, MeshBasicMaterial>;\n  private _sphereConfig?: GizmoOptions[\"sphere\"];\n  private _spritePoints: Sprite[];\n  private _viewport: Vector4 = new Vector4();\n  private _originalViewport: Vector4 = new Vector4();\n  private _originalScissor: Vector4 = new Vector4();\n  private _renderer: WebGLRenderer;\n  private _orthoCamera = new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 0, 4);\n  private _container: HTMLElement;\n  private _domElement: HTMLElement;\n  private _domRect!: DOMRect;\n  private _dragging: boolean = false;\n  private _distance: number = 0;\n  private _clock: Clock = new Clock();\n  private _targetPosition = new Vector3();\n  private _targetQuaternion = new Quaternion();\n  private _quaternionStart = new Quaternion();\n  private _quaternionEnd = new Quaternion();\n  private _mouseStart = new Vector2();\n  private _mouseAngle = new Vector2();\n  private _controls?: OrbitControls;\n  private _controlsListeners?: {\n    start: () => void;\n    end: () => void;\n    change: () => void;\n  };\n\n  /**\n   * Creates a new ViewportGizmo instance.\n   *\n   * @param camera - The camera to be controlled by this gizmo\n   * @param renderer - The WebGL renderer used to render the scene\n   * @param options - {@link GizmoOptions}, Configuration options for the gizmo\n   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string\n   * @param options.size - Size of the gizmo widget in pixels\n   * @param options.placement - Position of the gizmo in the viewport. One of:\n   *\n   *    - `\"top-left\"`\n   *    - `\"top-center\"`\n   *    - `\"top-right\"`\n   *    - `\"center-left\"`\n   *    - `\"center-center\"`\n   *    - `\"center-right\"`\n   *    - `\"bottom-left\"`\n   *    - `\"bottom-center\"`\n   *    - `\"bottom-right\"`\n   *\n   * @param options.animated - Whether view changes should be animated\n   * @param options.speed - Animation speed multiplier\n   * @param options.lineWidth - Width of the axis lines\n   * @param options.offset - Offset from the container edges in pixels\n   * @param options.offset.left - Offset from the left edge\n   * @param options.offset.top - Offset from the top edge\n   * @param options.offset.right - Offset from the right edge\n   * @param options.offset.bottom - Offset from the bottom edge\n   * @param options.sphere - Configuration for the background sphere\n   * @param options.sphere.enabled - Whether to show the background sphere\n   * @param options.sphere.color - Color of the background sphere\n   * @param options.sphere.opacity - Opacity of the background sphere\n   * @param options.sphere.hoverColor - Hover color of the background sphere\n   * @param options.sphere.hoverOpacity - Hover opacity of the background sphere\n   * @param options.id - HTML id attribute for the gizmo container\n   * @param options.className - HTML class attribute for the gizmo container\n   * @param options.font - Font configuration for axis labels\n   * @param options.font.family - Font family for axis labels\n   * @param options.font.weight - Font weight for axis labels\n   * @param options.resolution - Resolution of the gizmo rendering\n   * @param options.x - Configuration for positive X axis\n   * @param options.y - Configuration for positive Y axis\n   * @param options.z - Configuration for positive Z axis\n   * @param options.nx - Configuration for negative X axis\n   * @param options.ny - Configuration for negative Y axis\n   * @param options.nz - Configuration for negative Z axis\n   *\n   * @AXIS The following is the configuration for each AXIS `options.[x | y | z | nx | ny | nz]`:\n   *\n   * @param options.AXIS.text - Custom text label for the axis\n   * @param options.AXIS.circle - Whether to draw a circle indicator\n   * @param options.AXIS.line - Whether to draw the axis line\n   * @param options.AXIS.border - Whether to draw a border around the axis indicator\n   * @param options.AXIS.colors - Color configuration for the axis\n   * @param options.AXIS.colors.main - Main color(s) for the axis. Can be a single color or [normal, hover] colors\n   * @param options.AXIS.colors.hover - Hover color for the axis\n   * @param options.AXIS.colors.text - Color for the axis label\n   * @param options.AXIS.colors.hoverText - Color for the axis label on hover\n   */\n  constructor(\n    camera: PerspectiveCamera | OrthographicCamera,\n    renderer: WebGLRenderer,\n    options?: GizmoOptions\n  ) {\n    super();\n\n    this._renderer = renderer;\n    this.camera = camera;\n\n    this._orthoCamera.position.set(0, 0, 2);\n\n    options = { ...GIZMO_DEFAULT_OPTIONS, ...(options || {}) };\n\n    const {\n      container,\n      placement,\n      size,\n      animated,\n      speed,\n      offset,\n      sphere,\n      id,\n      className,\n    } = options as Required<GizmoOptions>;\n\n    this.animated = animated;\n    this.speed = speed;\n\n    const axesLines = getAxesLines(options);\n    if (axesLines) this.add(axesLines);\n\n    this._spritePoints = getAxesSpritePoints(options);\n    this.add(...this._spritePoints);\n\n    if (sphere.enabled) {\n      this._sphere = getBackgroundSphere(sphere);\n      this._sphereConfig = sphere;\n      this.add(this._sphere);\n    }\n\n    this._container = container ? getDomElement(container) : document.body;\n    this._domElement = createDomElement(placement, size, offset, id, className);\n    this._container.appendChild(this._domElement);\n\n    this._startListening();\n    this.update();\n  }\n\n  /**\n   * Renders the gizmo to the screen.\n   * This method handles viewport and scissor management to ensure the gizmo\n   * renders correctly without affecting the main scene rendering.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  render() {\n    if (this.animating) this._animate();\n\n    const { _renderer, _viewport } = this;\n\n    // save the current viewport config\n    const scissorTest = _renderer.getScissorTest();\n    const autoClear = _renderer.autoClear;\n\n    // render\n    _renderer.autoClear = false;\n    _renderer.setViewport(_viewport);\n    if (scissorTest) _renderer.setScissor(_viewport);\n\n    _renderer.clear(false, true, false);\n    _renderer.render(this, this._orthoCamera);\n\n    // reset the current viewport config\n    _renderer.setViewport(this._originalViewport);\n    if (scissorTest) _renderer.setScissor(this._originalScissor);\n\n    _renderer.autoClear = autoClear;\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's DOM-related properties based on its current position\n   * and size in the document.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  domUpdate() {\n    this._domRect = this._domElement.getBoundingClientRect();\n\n    const renderer = this._renderer;\n    const domRect = this._domRect;\n    const containerRect = renderer.domElement.getBoundingClientRect();\n\n    this._viewport.set(\n      domRect.left - containerRect.left,\n      renderer.domElement.clientHeight -\n        (domRect.top - containerRect.top + domRect.height),\n      domRect.width,\n      domRect.height\n    );\n\n    renderer.getViewport(this._originalViewport);\n    if (renderer.getScissorTest()) renderer.getScissor(this._originalScissor);\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's orientation to match the current camera orientation.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  cameraUpdate() {\n    this._updateOrientation();\n    return this;\n  }\n\n  /**\n   * Performs a complete update of the gizmo, including both DOM and camera-related updates.\n   *\n   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  update(controls: boolean = true) {\n    if (controls && this._controls) this._controls.update();\n    return this.domUpdate().cameraUpdate();\n  }\n\n  /**\n   * Connects OrbitControls with the gizmo, handling interaction states and updates.\n   * Automatically detaches any previously attached controls.\n   *\n   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}\n   */\n  attachControls(controls: OrbitControls) {\n    this.detachControls();\n\n    this.target = controls.target;\n\n    this._controlsListeners = {\n      start: () => (controls.enabled = false),\n      end: () => (controls.enabled = true),\n      change: () => this.update(false),\n    };\n\n    this.addEventListener(\"start\", this._controlsListeners.start);\n    this.addEventListener(\"end\", this._controlsListeners.end);\n    controls.addEventListener(\"change\", this._controlsListeners.change);\n\n    this._controls = controls;\n  }\n\n  /** Removes all control event listeners and references. Safe to call multiple times. */\n  detachControls() {\n    if (!this._controlsListeners || !this._controls) return;\n\n    this.target = new Vector3().copy(this._controls.target);\n\n    this.removeEventListener(\"start\", this._controlsListeners.start);\n    this.removeEventListener(\"end\", this._controlsListeners.end);\n\n    this._controls.removeEventListener(\n      \"change\",\n      this._controlsListeners.change\n    );\n\n    this._controlsListeners = undefined;\n    this._controls = undefined;\n  }\n\n  /** Cleans up all resources including geometries, materials, textures, and event listeners. */\n  dispose() {\n    this.detachControls();\n\n    this.children.forEach((child) => {\n      const mesh = child as Mesh<any, MeshBasicMaterial>;\n      mesh.material?.dispose();\n      mesh.material?.map?.dispose();\n      mesh.geometry?.dispose();\n    });\n\n    this._domElement.remove();\n  }\n\n  /**\n   * Updates the gizmo's orientation either based on the camera or internal state.\n   *\n   * @private\n   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)\n   */\n  private _updateOrientation(fromCamera: boolean = true) {\n    if (fromCamera) {\n      this.quaternion.copy(this.camera.quaternion).invert();\n      this.updateMatrixWorld();\n    }\n\n    updateSpritesOpacity(this._spritePoints, this.camera);\n  }\n\n  /**\n   * Handles the animation of camera position and orientation changes.\n   *\n   * @private\n   */\n  private _animate() {\n    const { position, quaternion } = this.camera;\n\n    position.set(0, 0, 1);\n\n    if (!this.animated) {\n      position\n        .applyQuaternion(this._quaternionEnd)\n        .multiplyScalar(this._distance)\n        .add(this.target);\n\n      quaternion.copy(this._targetQuaternion);\n\n      this._updateOrientation();\n\n      this.animating = false;\n      this.dispatchEvent({ type: \"change\" });\n      this.dispatchEvent({ type: \"end\" });\n      return;\n    }\n\n    const delta = this._clock.getDelta();\n\n    const step = delta * GIZMO_TURN_RATE * this.speed;\n\n    this._quaternionStart.rotateTowards(this._quaternionEnd, step);\n    position\n      .applyQuaternion(this._quaternionStart)\n      .multiplyScalar(this._distance)\n      .add(this.target);\n\n    quaternion.rotateTowards(this._targetQuaternion, step);\n\n    this._updateOrientation();\n    requestAnimationFrame(() => this.dispatchEvent({ type: \"change\" }));\n\n    if (this._quaternionStart.angleTo(this._quaternionEnd) === 0) {\n      this.animating = false;\n      this.dispatchEvent({ type: \"end\" });\n    }\n  }\n\n  /**\n   * Sets the camera orientation to look at the target from a specific axis.\n   *\n   * @private\n   * @param axis - The axis to orient the camera along\n   */\n  private _setOrientation(axis: (typeof GIZMO_AXES)[number]) {\n    const camera = this.camera;\n    const focusPoint = this.target;\n\n    const [position, orientation] = GIZMO_AXES_ORIENTATIONS[axis];\n    this._targetPosition.fromArray(position);\n    this._targetQuaternion.setFromEuler(_euler.fromArray(orientation));\n\n    this._targetPosition.multiplyScalar(this._distance).add(focusPoint);\n\n    _matrix.setPosition(camera.position);\n    _matrix.lookAt(camera.position, focusPoint, this.up);\n    this._quaternionStart.setFromRotationMatrix(_matrix);\n\n    _matrix.setPosition(this._targetPosition);\n    _matrix.lookAt(this._targetPosition, focusPoint, this.up);\n    this._quaternionEnd.setFromRotationMatrix(_matrix);\n\n    this.animating = true;\n    this._clock.start();\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Initializes event listeners for user interaction.\n   *\n   * @private\n   */\n  private _startListening() {\n    this._domElement.onpointerdown = (e) => this._onPointerDown(e);\n    this._domElement.onpointermove = (e) => this._onPointerMove(e);\n    this._domElement.onpointerleave = () => this._onPointerLeave();\n  }\n\n  /**\n   * Handles the pointer down event for starting drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerDown(e: PointerEvent) {\n    if (!this.enabled) return;\n\n    const drag = (e: PointerEvent) => {\n      if (!this._dragging) {\n        if (isClick(e, this._mouseStart)) return;\n\n        resetSprites(this._spritePoints);\n        this._dragging = true;\n      }\n\n      this._mouseAngle\n        .set(e.clientX, e.clientY)\n        .sub(this._mouseStart)\n        .multiplyScalar((1 / this._domRect.width) * Math.PI);\n\n      this.rotation.x = clamp(\n        rotationStart.x + this._mouseAngle.y,\n        Math.PI / -2 + 0.001,\n        Math.PI / 2 - 0.001\n      );\n      this.rotation.y = rotationStart.y + this._mouseAngle.x;\n      this.updateMatrixWorld();\n\n      this._quaternionStart.copy(this.quaternion).invert();\n\n      this.camera.position\n        .set(0, 0, 1)\n        .applyQuaternion(this._quaternionStart)\n        .multiplyScalar(this._distance)\n        .add(this.target);\n\n      this.camera.rotation.setFromQuaternion(this._quaternionStart);\n\n      this._updateOrientation(false);\n\n      this.dispatchEvent({ type: \"change\" });\n    };\n    const endDrag = () => {\n      document.removeEventListener(\"pointermove\", drag, false);\n      document.removeEventListener(\"pointerup\", endDrag, false);\n\n      if (!this._dragging) return this._handleClick(e);\n\n      this._dragging = false;\n      this.dispatchEvent({ type: \"end\" });\n    };\n\n    if (this.animating) return;\n\n    e.preventDefault();\n\n    this._mouseStart.set(e.clientX, e.clientY);\n\n    const rotationStart = _euler.copy(this.rotation);\n\n    this._distance = this.camera.position.distanceTo(this.target);\n\n    document.addEventListener(\"pointermove\", drag, false);\n    document.addEventListener(\"pointerup\", endDrag, false);\n\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Handles pointer move events for hover effects and drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerMove(e: PointerEvent) {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._sphere) setSphereColor(this._sphere, this._sphereConfig);\n\n    this._handleHover(e);\n  }\n\n  /**\n   * Handles pointer leave events to reset hover states.\n   *\n   * @private\n   */\n  private _onPointerLeave() {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._sphere) setSphereColor(this._sphere, this._sphereConfig, false);\n\n    resetSprites(this._spritePoints);\n    this._domElement.style.cursor = \"\";\n  }\n\n  /**\n   * Handles click events for axis selection.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleClick(e: PointerEvent) {\n    const object = getIntersectionObject(\n      e,\n      this._domRect,\n      this._orthoCamera,\n      this._spritePoints\n    );\n\n    if (!object) return;\n\n    this._setOrientation(object.userData.axis);\n    this.dispatchEvent({ type: \"change\" });\n  }\n\n  /**\n   * Handles hover effects for interactive elements.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleHover(e: PointerEvent) {\n    const object = getIntersectionObject(\n      e,\n      this._domRect,\n      this._orthoCamera,\n      this._spritePoints\n    );\n\n    resetSprites(this._spritePoints);\n\n    if (!object) {\n      this._domElement.style.cursor = \"\";\n    } else {\n      object.material.map!.offset.x = 0.5;\n      object.scale.multiplyScalar(1.2);\n      this._domElement.style.cursor = \"pointer\";\n    }\n  }\n}\n"],"names":["createDomElement","placement","size","offset","id","className","div","top","left","right","bottom","y","x","_box","Box3","_vector","Vector3","LineSegmentsGeometry","InstancedBufferGeometry","positions","uvs","index","Float32BufferAttribute","matrix","start","end","array","lineSegments","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","geometry","mesh","WireframeGeometry","Sphere","center","maxRadiusSq","i","il","UniformsLib","Vector2","ShaderLib","UniformsUtils","LineMaterial","ShaderMaterial","parameters","value","_start","_end","_start4","Vector4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","raycastWorldUnits","intersects","matrixWorld","instanceStart","instanceEnd","segmentCount","l","pointOnLine","point","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","Mesh","material","lineDistances","j","instanceDistanceBuffer","raycaster","worldUnits","threshold","sphereMargin","distanceToSphere","boxMargin","distanceToBox","LineGeometry","length","points","line","Line2","GIZMO_TURN_RATE","GIZMO_DEFAULT_OPTIONS","GIZMO_AXES","GIZMO_AXES_ORIENTATIONS","getAxesLines","options","colorManager","Color","key","axis","negative","main","color1","color2","getDomElement","domElement","element","getBackgroundSphere","color","opacity","SphereGeometry","sphere","MeshBasicMaterial","BackSide","getSpriteMaterial","font","text","textColor","hover","hoverText","circle","border","canvas","radius","centerY","circle2X","context","drawCircle","family","weight","fixY","textFitBox","texture","CanvasTexture","SRGBColorSpace","RepeatWrapping","SpriteMaterial","borderSize","ctx","square","fontSize","textWidth","textHeight","measure","scaleFactor","finalFontSize","getAxesSpritePoints","spriteResolution","isPositive","forceScale","sprite","Sprite","axisMap","primaryOpacity","secondaryOpacity","updateSpritesOpacity","sprites","positiveIndex","negativeIndex","isClick","e","startCoords","resetSprites","_raycaster","Raycaster","_mouse","getIntersectionObject","event","domRect","orthoCamera","intersectionObjects","clamp","num","min","max","setSphereColor","hoverColor","hoverOpacity","_matrix","_euler","Euler","ViewportGizmo","Object3D","renderer","__publicField","OrthographicCamera","Clock","Quaternion","container","animated","speed","axesLines","_renderer","_viewport","scissorTest","autoClear","containerRect","controls","child","_a","_c","_b","_d","fromCamera","position","quaternion","step","focusPoint","orientation","drag","rotationStart","endDrag","object"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5]}