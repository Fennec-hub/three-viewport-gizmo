{"version":3,"file":"three-viewport-gizmo.js","sources":["../lib/utils/getDomContainer.ts","../lib/utils/constants.ts","../lib/utils/getAxesLines.ts","../lib/utils/getDomElement.ts","../lib/utils/getBackgroundSphere.ts","../lib/utils/getSpriteMaterial.ts","../lib/utils/getAxesSpritePoints.ts","../lib/utils/prepareQuaternions.ts","../lib/utils/setRadius.ts","../lib/utils/prepareAnimationData.ts","../lib/utils/updateSpritesOpacity.ts","../lib/utils/isClick.ts","../lib/utils/resetSprites.ts","../lib/utils/updatePointer.ts","../lib/utils/getIntersectionObject.ts","../lib/utils/clamp.ts","../lib/ViewportGizmo.ts"],"sourcesContent":["import { DomPlacement, GizmoOptions } from \"../types\";\n\nexport const getDomContainer = (\n  placement: DomPlacement,\n  size: number,\n  offset: Required<GizmoOptions>[\"offset\"]\n) => {\n  const div = document.createElement(\"div\");\n  const style = div.style;\n\n  const { top, left, right, bottom } = offset;\n\n  style.height = `${size}px`;\n  style.width = `${size}px`;\n  style.borderRadius = \"100%\";\n  style.position = \"absolute\";\n  style.background = \"#fff3\";\n  style.opacity = \"0\";\n  style.zIndex = \"10000\";\n\n  const [y, x] = placement.split(\"-\");\n\n  style.transform = \"\";\n  style.margin = `${top}px ${right}px ${bottom}px ${left}px`;\n  style.left = x === \"left\" ? \"0\" : x === \"center\" ? `50%` : \"\";\n  style.right = x === \"right\" ? \"0\" : \"\";\n  style.transform += x === \"center\" ? \"translateX(-50%)\" : \"\";\n  style.top = y === \"top\" ? \"0\" : y === \"bottom\" ? \"\" : \"50%\";\n  style.bottom = y === \"bottom\" ? \"0\" : \"\";\n  style.transform += y === \"center\" ? \"translateY(-50%)\" : \"\";\n\n  return div;\n};\n","import { GizmoOptions } from \"@lib/types\";\nimport { Color } from \"three\";\n\nexport const GIZMO_AXES = [\"x\", \"y\", \"z\", \"nx\", \"ny\", \"nz\"] as const;\nexport const GIZMO_DEFAULT_OPTIONS: GizmoOptions = {\n  container: document.body,\n  placement: \"top-right\",\n  size: 128,\n  lineWidth: 3,\n  offset: {\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  font: {\n    family: \"helvetica\",\n    weight: 900,\n  },\n  resolution: 64,\n  backgroundSphere: {\n    enabled: true,\n    color: 0xffffff,\n    opacity: 0.2,\n  },\n  x: {\n    text: \"X\",\n    colors: {\n      main: \"#ff3653\",\n    },\n  },\n  y: {\n    text: \"Y\",\n    colors: {\n      main: \"#8adb00\",\n    },\n  },\n  z: {\n    text: \"Z\",\n    colors: {\n      main: \"#2c8fff\",\n    },\n  },\n  nx: {\n    drawLine: false,\n    colors: {\n      main: \"#ff3653\",\n    },\n  },\n  ny: {\n    drawLine: false,\n    colors: {\n      main: \"#8adb00\",\n    },\n  },\n  nz: {\n    drawLine: false,\n    colors: {\n      main: \"#2c8fff\",\n    },\n  },\n};\nexport const COLOR_MANAGER = new Color();\n","import {\n  BufferAttribute,\n  BufferGeometry,\n  LineBasicMaterial,\n  LineSegments,\n} from \"three\";\nimport { GizmoOptions } from \"../types\";\nimport { COLOR_MANAGER, GIZMO_AXES } from \"./constants\";\n\nexport const getAxesLines = (options: GizmoOptions) => {\n  const positions: number[] = [];\n  const colors: number[] = [];\n\n  GIZMO_AXES.forEach((key, i) => {\n    const axis = options[key]!;\n\n    if (axis.drawLine === false) return;\n\n    const negative = i < 3 ? 1 : -1;\n    const distance = i < 3 ? 0.9 : 1.025;\n\n    positions.push(\n      key.includes(\"x\") ? distance * negative : 0,\n      key.includes(\"y\") ? distance * negative : 0,\n      key.includes(\"z\") ? distance * negative : 0,\n      0,\n      0,\n      0\n    );\n\n    const main = axis.colors!.main!;\n    const [color1, color2] = Array.isArray(main) ? main : [main, main];\n    colors.push(\n      ...COLOR_MANAGER.set(color2).toArray(),\n      ...COLOR_MANAGER.set(color1).toArray()\n    );\n  });\n\n  const geometry = new BufferGeometry();\n  geometry.setAttribute(\n    \"position\",\n    new BufferAttribute(new Float32Array(positions), 3)\n  );\n  geometry.setAttribute(\n    \"color\",\n    new BufferAttribute(new Float32Array(colors), 3)\n  );\n\n  return new LineSegments(\n    geometry,\n    new LineBasicMaterial({\n      linewidth: options.lineWidth ?? 3,\n      vertexColors: true,\n    })\n  );\n};\n","export const getDomElement = (\n  domElement: string | HTMLElement\n): HTMLElement => {\n  const element =\n    typeof domElement === \"string\"\n      ? document.querySelector<HTMLElement>(domElement)\n      : domElement;\n\n  if (!element) throw Error(`Invalid DOM element`);\n\n  return element;\n};\n","import {\n  BackSide,\n  ColorRepresentation,\n  Mesh,\n  MeshBasicMaterial,\n  SphereGeometry,\n} from \"three\";\n\nexport function getBackgroundSphere(color: ColorRepresentation) {\n  const geometry = new SphereGeometry(1.6, 64, 64);\n  const sphere = new Mesh(\n    geometry,\n    new MeshBasicMaterial({\n      color,\n      side: BackSide,\n      transparent: true,\n      opacity: 0,\n      depthTest: false,\n    })\n  );\n\n  return sphere;\n}\n","import { GizmoOptions } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  RepeatWrapping,\n  SRGBColorSpace,\n  SpriteMaterial,\n} from \"three\";\n\nexport function getSpriteMaterial(\n  font: Required<GizmoOptions>[\"font\"],\n  resolution: number,\n  color: string,\n  text: string | undefined,\n  textColor: string | null,\n  hover: string | null,\n  hoverText: string | null,\n  border?: boolean\n) {\n  const canvas = document.createElement(\"canvas\");\n  resolution = resolution ?? 64;\n\n  const offset = 0.02;\n\n  canvas.width = resolution * 2 + resolution * (offset * 4);\n  canvas.height = resolution + resolution * (offset * 2);\n\n  const radius = resolution / 2;\n  const centerY = resolution / 2 + resolution * offset;\n  const circle2X = centerY * 3;\n\n  const context = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n  drawCircle(context, radius, centerY, centerY, color, border);\n  drawCircle(context, radius, circle2X, centerY, hover || \"#FFF\", border);\n\n  if (text != null) {\n    const family = font.family || \"sans-serif\";\n    const weight = font.weight || 500;\n\n    const fixY = fitTextInBox(context, text, family, weight, resolution);\n\n    context.textAlign = \"center\";\n    context.textBaseline = \"middle\";\n    context.fillStyle = textColor || \"#000\";\n    context.fillText(text, centerY, centerY + fixY);\n    context.fillStyle = hoverText || textColor || \"#000\";\n    context.fillText(text, circle2X, centerY + fixY);\n  }\n\n  const texture = new CanvasTexture(canvas);\n  texture.colorSpace = SRGBColorSpace;\n  texture.wrapS = texture.wrapT = RepeatWrapping;\n  texture.repeat.x = 0.5;\n\n  return new SpriteMaterial({\n    map: texture,\n    toneMapped: false,\n    transparent: true,\n  });\n}\n\nfunction drawCircle(\n  context: CanvasRenderingContext2D,\n  radius: number,\n  x: number,\n  y: number,\n  color: string,\n  border: boolean = false\n) {\n  const borderSize = y * 0.1;\n  radius = border ? radius - borderSize : radius;\n\n  if (border) context.globalAlpha = 0.2;\n  context.beginPath();\n  context.arc(x, y, radius, 0, 2 * Math.PI);\n  context.closePath();\n  context.fillStyle = color;\n  context.fill();\n\n  if (border) {\n    context.globalAlpha = 1;\n    context.strokeStyle = color;\n    context.lineWidth = borderSize;\n    context.stroke();\n  }\n}\n\nfunction fitTextInBox(\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  font: string,\n  weight: string | number,\n  size: number\n) {\n  const square = Math.sqrt(Math.pow(size * 0.7, 2) / 2);\n  let fontSize = square;\n  let textWidth = 0;\n  let textHeight = 0;\n\n  do {\n    ctx.font = `${weight} ${fontSize}px ${font}`;\n    const measure = ctx.measureText(text);\n    textWidth = measure.width;\n    textHeight = measure.fontBoundingBoxDescent;\n    fontSize--;\n  } while (textWidth > square && fontSize > 0);\n\n  const scaleFactor = Math.min(square / textWidth, square / textHeight);\n\n  const finalFontSize = Math.floor(fontSize * scaleFactor);\n\n  ctx.font = `${weight} ${finalFontSize}px ${font}`;\n\n  return square / textHeight;\n}\n","import { Sprite } from \"three\";\nimport { getSpriteMaterial } from \"./getSpriteMaterial\";\nimport { GizmoOptions } from \"@lib/types\";\nimport { COLOR_MANAGER, GIZMO_AXES } from \"./constants\";\n\nexport function getAxesSpritePoints(options: GizmoOptions) {\n  const { font, resolution: spriteResolution } = options;\n\n  return GIZMO_AXES.map((key, i) => {\n    const { text, colors, border } = options[key]!;\n    const isPositive = i < 3;\n    const axis = (isPositive ? key : key[1]) as \"x\" | \"y\" | \"z\";\n\n    const { text: textColor, main, hover, hoverText } = colors!;\n    const color = Array.isArray(main) ? main[1] : main!;\n    const forceScale = border && text;\n\n    const sprite = new Sprite(\n      getSpriteMaterial(\n        font!,\n        spriteResolution!,\n        COLOR_MANAGER.set(color).getStyle(),\n        text,\n        (textColor && COLOR_MANAGER.set(textColor).getStyle()) || null,\n        (hover && COLOR_MANAGER.set(hover).getStyle()) || null,\n        (hoverText && COLOR_MANAGER.set(hoverText).getStyle()) || null,\n        border\n      )\n    );\n\n    sprite.userData.type = key;\n    sprite.userData.forceScale = forceScale;\n    sprite.scale.setScalar(forceScale || isPositive ? 0.6 : 0.4);\n    sprite.position[axis] = isPositive ? 1.2 : -1.2;\n    sprite.renderOrder = 1;\n\n    return sprite;\n  });\n}\n","import { Camera, Object3D, Vector3 } from \"three\";\nimport { targetPosition, q1, q2 } from \"../ViewportGizmo\";\n\nconst dummy = new Object3D();\n\nexport function prepareQuaternions(\n  camera: Camera,\n  radius: { value: number },\n  focusPoint: Vector3\n) {\n  targetPosition.multiplyScalar(radius.value).add(focusPoint);\n\n  dummy.position.copy(focusPoint);\n\n  dummy.lookAt(camera.position);\n  q1.copy(dummy.quaternion);\n\n  dummy.lookAt(targetPosition);\n  q2.copy(dummy.quaternion);\n}\n","import { Camera, Vector3 } from \"three\";\n\nexport function setRadius(\n  camera: Camera,\n  radius: {\n    value: number;\n  },\n  focusPoint: Vector3\n) {\n  radius.value = camera.position.distanceTo(focusPoint);\n}\n","import { Euler, OrthographicCamera, PerspectiveCamera, Vector3 } from \"three\";\nimport { targetPosition, targetQuaternion } from \"../ViewportGizmo\";\nimport { prepareQuaternions } from \"./prepareQuaternions\";\nimport { setRadius } from \"./setRadius\";\nimport { GIZMO_AXES } from \"./constants\";\n\nexport function prepareAnimationData(\n  camera: OrthographicCamera | PerspectiveCamera,\n  focusPoint: Vector3,\n  axis: (typeof GIZMO_AXES)[number],\n  radius: { value: number }\n) {\n  switch (axis) {\n    case \"x\":\n      targetPosition.set(1, 0, 0);\n      targetQuaternion.setFromEuler(new Euler(0, Math.PI * 0.5, 0));\n      break;\n\n    case \"y\":\n      targetPosition.set(0, 1, 0);\n      targetQuaternion.setFromEuler(new Euler(-Math.PI * 0.5, 0, 0));\n      break;\n\n    case \"z\":\n      targetPosition.set(0, 0, 1);\n      targetQuaternion.setFromEuler(new Euler());\n      break;\n\n    case \"nx\":\n      targetPosition.set(-1, 0, 0);\n      targetQuaternion.setFromEuler(new Euler(0, -Math.PI * 0.5, 0));\n      break;\n\n    case \"ny\":\n      targetPosition.set(0, -1, 0);\n      targetQuaternion.setFromEuler(new Euler(Math.PI * 0.5, 0, 0));\n      break;\n\n    case \"nz\":\n      targetPosition.set(0, 0, -1);\n      targetQuaternion.setFromEuler(new Euler(0, Math.PI, 0));\n      break;\n\n    default:\n      console.error(\"ViewHelper: Invalid axis.\");\n  }\n\n  setRadius(camera, radius, focusPoint);\n  prepareQuaternions(camera, radius, focusPoint);\n}\n","import { Camera, Sprite, Vector3 } from \"three\";\n\nconst enum Axes {\n  PositiveX,\n  PositiveY,\n  PositiveZ,\n  NegativeX,\n  NegativeY,\n  NegativeZ,\n}\n\nconst point = new Vector3();\n\nexport function updateSpritesOpacity(sprites: Sprite[], camera: Camera) {\n  point.set(0, 0, 1);\n  point.applyQuaternion(camera.quaternion);\n\n  if (point.x >= 0) {\n    sprites[Axes.PositiveX].material.opacity = 1;\n    sprites[Axes.NegativeX].material.opacity = 0.5;\n  } else {\n    sprites[Axes.PositiveX].material.opacity = 0.5;\n    sprites[Axes.NegativeX].material.opacity = 1;\n  }\n\n  if (point.y >= 0) {\n    sprites[Axes.PositiveY].material.opacity = 1;\n    sprites[Axes.NegativeY].material.opacity = 0.5;\n  } else {\n    sprites[Axes.PositiveY].material.opacity = 0.5;\n    sprites[Axes.NegativeY].material.opacity = 1;\n  }\n\n  if (point.z >= 0) {\n    sprites[Axes.PositiveZ].material.opacity = 1;\n    sprites[Axes.NegativeZ].material.opacity = 0.5;\n  } else {\n    sprites[Axes.PositiveZ].material.opacity = 0.5;\n    sprites[Axes.NegativeZ].material.opacity = 1;\n  }\n}\n","import { Vector2 } from \"three\";\n\nexport function isClick(\n  e: PointerEvent,\n  startCoords: Vector2,\n  threshold: number = 10\n) {\n  return (\n    Math.abs(e.clientX - startCoords.x) < threshold &&\n    Math.abs(e.clientY - startCoords.y) < threshold\n  );\n}\n","import { Sprite } from \"three\";\n\nexport function resetSprites(sprites: Sprite[]) {\n  let i = sprites.length;\n\n  while (i--) {\n    sprites[i].scale.setScalar(\n      i < 3 || sprites[i].userData.forceScale ? 0.6 : 0.4\n    );\n    sprites[i].material.map!.offset.x = 1;\n  }\n}\n","import { OrthographicCamera, Vector2 } from \"three\";\nimport { raycaster } from \"../ViewportGizmo\";\n\nconst mouse = new Vector2();\n\nexport function updatePointer(\n  e: PointerEvent,\n  domRect: DOMRect,\n  orthoCamera: OrthographicCamera\n) {\n  mouse.x = ((e.clientX - domRect.left) / domRect.width) * 2 - 1;\n  mouse.y = -((e.clientY - domRect.top) / domRect.height) * 2 + 1;\n\n  raycaster.setFromCamera(mouse, orthoCamera);\n}\n","import { OrthographicCamera, Sprite } from \"three\";\nimport { updatePointer } from \"./updatePointer\";\nimport { raycaster } from \"../ViewportGizmo\";\n\nexport function getIntersectionObject(\n  event: PointerEvent,\n  domRect: DOMRect,\n  orthoCamera: OrthographicCamera,\n  intersectionObjects: Sprite[]\n) {\n  updatePointer(event, domRect, orthoCamera);\n\n  const intersects = raycaster.intersectObjects(intersectionObjects);\n\n  if (!intersects.length) return null;\n\n  const intersection = intersects[0];\n  return intersection.object as Sprite;\n}\n","export function clamp(num: number, min: number, max: number) {\n  return Math.min(Math.max(num, min), max);\n}\n","import {\n  Clock,\n  Euler,\n  Material,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Raycaster,\n  Sprite,\n  Vector2,\n  Vector3,\n  Vector4,\n  WebGLRenderer,\n} from \"three\";\n\nimport { getDomContainer } from \"./utils/getDomContainer\";\nimport { getAxesLines } from \"./utils/getAxesLines\";\nimport { getDomElement } from \"./utils/getDomElement\";\nimport { getBackgroundSphere } from \"./utils/getBackgroundSphere\";\nimport { getAxesSpritePoints } from \"./utils/getAxesSpritePoints\";\nimport { prepareAnimationData } from \"./utils/prepareAnimationData\";\nimport { setRadius } from \"./utils/setRadius\";\nimport { updateSpritesOpacity } from \"./utils/updateSpritesOpacity\";\nimport { isClick } from \"./utils/isClick\";\nimport { resetSprites } from \"./utils/resetSprites\";\nimport { getIntersectionObject } from \"./utils/getIntersectionObject\";\nimport { clamp } from \"./utils/clamp\";\n\nimport { GizmoOptions, ViewportGizmoEventMap } from \"./types\";\nimport { GIZMO_AXES, GIZMO_DEFAULT_OPTIONS } from \"./utils/constants\";\n\nexport const targetPosition = new Vector3();\nexport const targetQuaternion = new Quaternion();\nexport const q1 = new Quaternion();\nexport const q2 = new Quaternion();\nexport const raycaster = new Raycaster();\n\nconst clock = new Clock();\nconst euler = new Euler();\nconst turnRate = 2 * Math.PI; // turn rate in angles per second\n\nconst mouseStart = new Vector2();\nconst mouseAngle = new Vector2();\nconst radius = { value: 0 };\nlet offsetHeight = 0;\n\nexport class ViewportGizmo extends Object3D<ViewportGizmoEventMap> {\n  private _backgroundSphere?: Mesh;\n  private _bgSphereOpacity: number = 0.2;\n  private _spritePoints: Sprite[];\n  private _container: HTMLElement;\n  private _domRect: DOMRect;\n  private _viewport: Vector4 = new Vector4();\n  private _renderer: WebGLRenderer;\n  private _orthoCamera = new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 0, 4);\n  private _domElement: HTMLElement;\n  private _parentRect: DOMRect | undefined;\n  enabled: boolean = true;\n  camera: OrthographicCamera | PerspectiveCamera;\n  animated: boolean = true;\n  animating = false;\n  target = new Vector3();\n  dragging: boolean = false;\n  size: number;\n  speed: number = 1;\n\n  constructor(\n    camera: PerspectiveCamera | OrthographicCamera,\n    renderer: WebGLRenderer,\n    options?: GizmoOptions\n  ) {\n    super();\n\n    this._renderer = renderer;\n    this._container = renderer.domElement;\n    this.camera = camera;\n\n    this._orthoCamera.position.set(0, 0, 2);\n\n    options = Object.assign(GIZMO_DEFAULT_OPTIONS, options || {});\n\n    const { container, placement, size, offset, backgroundSphere } =\n      options as Required<GizmoOptions>;\n\n    this.size = size;\n\n    const axesLines = getAxesLines(options);\n    this._spritePoints = getAxesSpritePoints(options);\n\n    this.add(axesLines, ...this._spritePoints);\n\n    if (backgroundSphere.enabled) {\n      this._backgroundSphere = getBackgroundSphere(backgroundSphere.color!);\n      this._bgSphereOpacity = backgroundSphere.opacity ?? 0.2;\n      this.add(this._backgroundSphere);\n    }\n\n    this._domElement = getDomContainer(placement, size, offset);\n    getDomElement(container).appendChild(this._domElement);\n\n    this._domRect = this._domElement.getBoundingClientRect();\n    this._parentRect = this._domElement.parentElement?.getBoundingClientRect();\n    this._startListening();\n\n    this.update();\n  }\n\n  render() {\n    if (this.animating) this._animate();\n\n    let x = this._domRect.left;\n    let y = offsetHeight - this._domRect.bottom;\n    if (this._parentRect) {\n      x -= this._parentRect.left;\n      y += this._parentRect.top;\n    }\n\n\n    const autoClear = this._renderer.autoClear;\n    this._renderer.autoClear = false;\n    this._renderer.setViewport(x, y, this.size, this.size);\n    this._renderer.clear(false, true, false);\n    this._renderer.render(this, this._orthoCamera);\n    this._renderer.setViewport(this._viewport);\n    this._renderer.autoClear = autoClear;\n  }\n\n  update() {\n    this._domRect = this._domElement.getBoundingClientRect();\n    offsetHeight = this._container.offsetHeight;\n    setRadius(this.camera, radius, this.target);\n    this._renderer.getViewport(this._viewport);\n\n    this._updateOrientation();\n  }\n\n  dispose() {\n    this.children.forEach((child) => {\n      const mesh = child as Mesh<any, MeshBasicMaterial>;\n      mesh.material?.dispose();\n      mesh.material?.map?.dispose();\n      mesh.geometry?.dispose();\n    });\n\n    this._domElement.remove();\n  }\n\n  // INTERNALS ↓↓↓\n  private _updateOrientation(fromCamera: boolean = true) {\n    if (fromCamera) {\n      this.quaternion.copy(this.camera.quaternion).invert();\n      this.updateMatrixWorld();\n    }\n\n    updateSpritesOpacity(this._spritePoints, this.camera);\n  }\n\n  private _animate() {\n    if (!this.animated) {\n      this.camera.quaternion.copy(targetQuaternion);\n      this.animating = false;\n      this.dispatchEvent({ type: \"change\" });\n      this.dispatchEvent({ type: \"end\" });\n      return;\n    }\n\n    const delta = clock.getDelta();\n\n    const step = delta * turnRate * this.speed;\n\n    q1.rotateTowards(q2, step);\n    this.camera.position\n      .set(0, 0, 1)\n      .applyQuaternion(q1)\n      .multiplyScalar(radius.value)\n      .add(this.target);\n\n    this.camera.quaternion.rotateTowards(targetQuaternion, step);\n\n    this._updateOrientation();\n    requestAnimationFrame(() => this.dispatchEvent({ type: \"change\" }));\n\n    if (q1.angleTo(q2) === 0) {\n      this.animating = false;\n      this.dispatchEvent({ type: \"end\" });\n    }\n  }\n\n  private _setOrientation(orientation: (typeof GIZMO_AXES)[number]) {\n    prepareAnimationData(this.camera, this.target, orientation, radius);\n    this.animating = true;\n    clock.start();\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  private _startListening() {\n    this._domElement.onpointerdown = (e) => this._onPointerDown(e);\n    this._domElement.onpointermove = (e) => this._onPointerMove(e);\n    this._domElement.onpointerleave = () => this._onPointerLeave();\n  }\n\n  private _onPointerDown(e: PointerEvent) {\n    if (!this.enabled) return;\n\n    const drag = (e: PointerEvent) => {\n      if (!this.dragging && isClick(e, mouseStart)) return;\n      if (!this.dragging) {\n        resetSprites(this._spritePoints);\n        this.dragging = true;\n      }\n\n      mouseAngle\n        .set(e.clientX, e.clientY)\n        .sub(mouseStart)\n        .multiplyScalar((1 / this._domRect.width) * Math.PI);\n\n      this.rotation.x = clamp(\n        rotationStart.x + mouseAngle.y,\n        Math.PI / -2 + 0.001,\n        Math.PI / 2 - 0.001\n      );\n      this.rotation.y = rotationStart.y + mouseAngle.x;\n      this.updateMatrixWorld();\n\n      q1.copy(this.quaternion).invert();\n\n      this.camera.position\n        .set(0, 0, 1)\n        .applyQuaternion(q1)\n        .multiplyScalar(radius.value)\n        .add(this.target);\n\n      this.camera.rotation.setFromQuaternion(q1);\n\n      this._updateOrientation(false);\n\n      this.dispatchEvent({ type: \"change\" });\n    };\n    const endDrag = () => {\n      document.removeEventListener(\"pointermove\", drag, false);\n      document.removeEventListener(\"pointerup\", endDrag, false);\n\n      if (!this.dragging) return this._handleClick(e);\n\n      this.dragging = false;\n      this.dispatchEvent({ type: \"end\" });\n    };\n\n    if (this.animating === true) return;\n    e.preventDefault();\n\n    mouseStart.set(e.clientX, e.clientY);\n\n    const rotationStart = euler.copy(this.rotation);\n\n    setRadius(this.camera, radius, this.target);\n\n    document.addEventListener(\"pointermove\", drag, false);\n    document.addEventListener(\"pointerup\", endDrag, false);\n\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  private _onPointerMove(e: PointerEvent) {\n    if (!this.enabled || this.dragging) return;\n\n    if (this._backgroundSphere)\n      (this._backgroundSphere.material as Material).opacity =\n        this._bgSphereOpacity;\n\n    this._handleHover(e);\n  }\n\n  private _onPointerLeave() {\n    if (!this.enabled || this.dragging) return;\n\n    if (this._backgroundSphere)\n      (this._backgroundSphere.material as Material).opacity = 0;\n\n    resetSprites(this._spritePoints);\n    this._domElement.style.cursor = \"\";\n  }\n\n  private _handleClick(e: PointerEvent) {\n    const object = getIntersectionObject(\n      e,\n      this._domRect,\n      this._orthoCamera,\n      this._spritePoints\n    );\n\n    if (!object) return;\n\n    this._setOrientation(object.userData.type);\n    this.dispatchEvent({ type: \"change\" });\n  }\n\n  private _handleHover(e: PointerEvent) {\n    const object = getIntersectionObject(\n      e,\n      this._domRect,\n      this._orthoCamera,\n      this._spritePoints\n    );\n\n    resetSprites(this._spritePoints);\n\n    if (!object) {\n      this._domElement.style.cursor = \"\";\n    } else {\n      object.material.map!.offset.x = 0.5;\n      object.scale.multiplyScalar(1.2);\n      this._domElement.style.cursor = \"pointer\";\n    }\n  }\n}\n"],"names":["getDomContainer","placement","size","offset","div","style","top","left","right","bottom","y","x","GIZMO_AXES","GIZMO_DEFAULT_OPTIONS","COLOR_MANAGER","Color","getAxesLines","options","positions","colors","key","i","axis","negative","distance","main","color1","color2","geometry","BufferGeometry","BufferAttribute","LineSegments","LineBasicMaterial","getDomElement","domElement","element","getBackgroundSphere","color","SphereGeometry","Mesh","MeshBasicMaterial","BackSide","getSpriteMaterial","font","resolution","text","textColor","hover","hoverText","border","canvas","radius","centerY","circle2X","context","drawCircle","family","weight","fixY","fitTextInBox","texture","CanvasTexture","SRGBColorSpace","RepeatWrapping","SpriteMaterial","borderSize","ctx","square","fontSize","textWidth","textHeight","measure","scaleFactor","finalFontSize","getAxesSpritePoints","spriteResolution","isPositive","forceScale","sprite","Sprite","dummy","Object3D","prepareQuaternions","camera","focusPoint","targetPosition","q1","q2","setRadius","prepareAnimationData","targetQuaternion","Euler","point","Vector3","updateSpritesOpacity","sprites","isClick","e","startCoords","threshold","resetSprites","mouse","Vector2","updatePointer","domRect","orthoCamera","raycaster","getIntersectionObject","event","intersectionObjects","intersects","clamp","num","min","max","Quaternion","Raycaster","clock","Clock","euler","turnRate","mouseStart","mouseAngle","offsetHeight","ViewportGizmo","renderer","__publicField","Vector4","OrthographicCamera","container","backgroundSphere","axesLines","_a","autoClear","child","mesh","_c","_b","_d","fromCamera","step","orientation","drag","rotationStart","endDrag","object"],"mappings":"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"}