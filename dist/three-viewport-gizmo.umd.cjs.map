{"version":3,"file":"three-viewport-gizmo.umd.cjs","sources":["../lib/utils/createDomElement.ts","../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../node_modules/three/examples/jsm/lines/LineMaterial.js","../node_modules/three/examples/jsm/lines/LineSegments2.js","../node_modules/three/examples/jsm/lines/LineGeometry.js","../node_modules/three/examples/jsm/lines/Line2.js","../lib/utils/constants.ts","../lib/utils/getAxesLines.ts","../lib/utils/getDomElement.ts","../lib/utils/getBackgroundSphere.ts","../lib/utils/getSpriteMaterial.ts","../lib/utils/getAxesSpritePoints.ts","../lib/utils/updateSpritesOpacity.ts","../lib/utils/isClick.ts","../lib/utils/resetSprites.ts","../lib/utils/getIntersectionObject.ts","../lib/utils/clamp.ts","../lib/utils/setSphereColor.ts","../lib/ViewportGizmo.ts"],"sourcesContent":["import { GizmoDomPlacement, GizmoOptions } from \"../types\";\n\nexport const createDomElement = (\n  placement: GizmoDomPlacement,\n  size: number,\n  offset: Required<GizmoOptions>[\"offset\"],\n  id?: string,\n  className?: string\n) => {\n  const div = document.createElement(\"div\");\n\n  const top = offset.top ?? 0;\n  const left = offset.left ?? 0;\n  const right = offset.right ?? 0;\n  const bottom = offset.bottom ?? 0;\n  const [y, x] = placement.split(\"-\");\n\n  Object.assign(div.style, {\n    height: `${size}px`,\n    width: `${size}px`,\n    borderRadius: \"100%\",\n    position: \"absolute\",\n    background: \"#fff3\",\n    opacity: \"0\",\n    zIndex: \"10000\",\n    transform: `${x === \"center\" ? \"translateX(-50%)\" : \"\"} ${\n      y === \"center\" ? \"translateY(-50%)\" : \"\"\n    }`,\n    margin: `${top}px ${right}px ${bottom}px ${left}px`,\n    left: x === \"left\" ? \"0\" : x === \"center\" ? `50%` : \"\",\n    right: x === \"right\" ? \"0\" : \"\",\n    top: y === \"top\" ? \"0\" : y === \"bottom\" ? \"\" : \"50%\",\n    bottom: y === \"bottom\" ? \"0\" : \"\",\n  });\n\n  if (id) div.id = id;\n  if (className) div.className = className;\n\n  return div;\n};\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n","/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nimport {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2\n} from 'three';\n\n\nUniformsLib.line = {\n\n\tworldUnits: { value: 1 },\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashOffset: { value: 0 },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t/* glsl */`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t/* glsl */`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttype: 'LineMaterial',\n\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tthis.isLineMaterial = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget color() {\n\n\t\treturn this.uniforms.diffuse.value;\n\n\t}\n\n\tset color( value ) {\n\n\t\tthis.uniforms.diffuse.value = value;\n\n\t}\n\n\tget worldUnits() {\n\n\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t}\n\n\t}\n\n\tget linewidth() {\n\n\t\treturn this.uniforms.linewidth.value;\n\n\t}\n\n\tset linewidth( value ) {\n\n\t\tif ( ! this.uniforms.linewidth ) return;\n\t\tthis.uniforms.linewidth.value = value;\n\n\t}\n\n\tget dashed() {\n\n\t\treturn 'USE_DASH' in this.defines;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( ( value === true ) !== this.dashed ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_DASH = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_DASH;\n\n\t\t}\n\n\t}\n\n\tget dashScale() {\n\n\t\treturn this.uniforms.dashScale.value;\n\n\t}\n\n\tset dashScale( value ) {\n\n\t\tthis.uniforms.dashScale.value = value;\n\n\t}\n\n\tget dashSize() {\n\n\t\treturn this.uniforms.dashSize.value;\n\n\t}\n\n\tset dashSize( value ) {\n\n\t\tthis.uniforms.dashSize.value = value;\n\n\t}\n\n\tget dashOffset() {\n\n\t\treturn this.uniforms.dashOffset.value;\n\n\t}\n\n\tset dashOffset( value ) {\n\n\t\tthis.uniforms.dashOffset.value = value;\n\n\t}\n\n\tget gapSize() {\n\n\t\treturn this.uniforms.gapSize.value;\n\n\t}\n\n\tset gapSize( value ) {\n\n\t\tthis.uniforms.gapSize.value = value;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( value ) {\n\n\t\tif ( ! this.uniforms ) return;\n\t\tthis.uniforms.opacity.value = value;\n\n\t}\n\n\tget resolution() {\n\n\t\treturn this.uniforms.resolution.value;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tthis.uniforms.resolution.value.copy( value );\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( ! this.defines ) return;\n\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\t\t\tthis.extensions.derivatives = true;\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\t\t\tthis.extensions.derivatives = false;\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nclass LineGeometry extends LineSegmentsGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineGeometry = true;\n\n\t\tthis.type = 'LineGeometry';\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst points = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setPositions( points );\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst colors = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setColors( colors );\n\n\t\treturn this;\n\n\t}\n\n\tfromLine( line ) {\n\n\t\tconst geometry = line.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { LineGeometry };\n","import { LineSegments2 } from '../lines/LineSegments2.js';\nimport { LineGeometry } from '../lines/LineGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n\n\tconstructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLine2 = true;\n\n\t\tthis.type = 'Line2';\n\n\t}\n\n}\n\nexport { Line2 };\n","import { GizmoOptions, OrientationAxes } from \"@lib/types\";\nimport { Vector3Tuple } from \"three\";\n\nexport const GIZMO_TURN_RATE = 2 * Math.PI;\n\nexport const GIZMO_DEFAULT_OPTIONS: GizmoOptions = {\n  container: document.body,\n  placement: \"top-right\",\n  size: 128,\n  lineWidth: 20,\n  animated: true,\n  speed: 1,\n  offset: {\n    top: 10,\n    left: 10,\n    right: 10,\n    bottom: 10,\n  },\n  font: {\n    family: \"helvetica\",\n    weight: 900,\n  },\n  resolution: 64,\n  sphere: {\n    enabled: true,\n    color: 0xffffff,\n    opacity: 0,\n    hoverColor: 0xffffff,\n    hoverOpacity: 0.2,\n  },\n  x: {\n    text: \"X\",\n    colors: {\n      main: \"#ff3653\",\n    },\n  },\n  y: {\n    text: \"Y\",\n    colors: {\n      main: \"#8adb00\",\n    },\n  },\n  z: {\n    text: \"Z\",\n    colors: {\n      main: \"#2c8fff\",\n    },\n  },\n  nx: {\n    line: false,\n    colors: {\n      main: \"#ff3653\",\n    },\n  },\n  ny: {\n    line: false,\n    colors: {\n      main: \"#8adb00\",\n    },\n  },\n  nz: {\n    line: false,\n    colors: {\n      main: \"#2c8fff\",\n    },\n  },\n};\n\nexport const GIZMO_AXES = [\"x\", \"y\", \"z\", \"nx\", \"ny\", \"nz\"] as const;\n\nexport const GIZMO_AXES_ORIENTATIONS: Record<\n  OrientationAxes,\n  [position: Vector3Tuple, orientation: Vector3Tuple]\n> = {\n  x: [\n    [1, 0, 0],\n    [0, Math.PI * 0.5, 0],\n  ],\n\n  y: [\n    [0, 1, 0],\n    [-Math.PI * 0.5, 0, 0],\n  ],\n\n  z: [\n    [0, 0, 1],\n    [0, 0, 0],\n  ],\n\n  nx: [\n    [-1, 0, 0],\n    [0, -Math.PI * 0.5, 0],\n  ],\n\n  ny: [\n    [0, -1, 0],\n    [Math.PI * 0.5, 0, 0],\n  ],\n\n  nz: [\n    [0, 0, -1],\n    [0, Math.PI, 0],\n  ],\n};\n","import { Color, Vector2 } from \"three\";\nimport { Line2 } from \"three/addons/lines/Line2.js\";\nimport { LineGeometry } from \"three/addons/lines/LineGeometry.js\";\nimport { LineMaterial } from \"three/addons/lines/LineMaterial.js\";\nimport { GizmoOptions } from \"../types\";\nimport { GIZMO_AXES } from \"./constants\";\n\nexport const getAxesLines = (options: GizmoOptions) => {\n  const colorManager = new Color();\n  const positions: number[] = [];\n  const colors: number[] = [];\n\n  GIZMO_AXES.forEach((key, i) => {\n    const axis = options[key]!;\n\n    if (axis.line === false) return;\n\n    const negative = i < 3 ? 1.1 : -1.1;\n    const distance = i < 3 ? 1 : 1.125;\n\n    positions.push(\n      key.includes(\"x\") ? distance * negative : 0,\n      key.includes(\"y\") ? distance * negative : 0,\n      key.includes(\"z\") ? distance * negative : 0,\n      0,\n      0,\n      0\n    );\n\n    const main = axis.colors!.main!;\n\n    const [color1, color2] = Array.isArray(main) ? main : [main, main];\n    colors.push(\n      ...colorManager.set(color2).toArray(),\n      ...colorManager.set(color1).toArray()\n    );\n  });\n\n  if (!positions.length) return null;\n\n  const geometry = new LineGeometry();\n  geometry.setPositions(positions);\n  geometry.setColors(colors);\n\n  const material = new LineMaterial({\n    linewidth: options.lineWidth ?? 20,\n    vertexColors: true,\n    resolution: new Vector2(window.innerWidth, window.innerHeight),\n  });\n\n  // Create Line2 instead of LineSegments\n  const line = new Line2(geometry, material);\n  line.computeLineDistances();\n  line.scale.set(1, 1, 1);\n  line.renderOrder = 1;\n\n  return line;\n};\n","export const getDomElement = (\n  domElement: string | HTMLElement\n): HTMLElement => {\n  const element =\n    typeof domElement === \"string\"\n      ? document.querySelector<HTMLElement>(domElement)\n      : domElement;\n\n  if (!element) throw Error(`Invalid DOM element`);\n\n  return element;\n};\n","import {\n  BackSide,\n  BufferGeometry,\n  ColorRepresentation,\n  Mesh,\n  MeshBasicMaterial,\n  SphereGeometry,\n} from \"three\";\n\nexport function getBackgroundSphere({\n  color,\n  opacity,\n}: { color?: ColorRepresentation; opacity?: number } = {}) {\n  const geometry = new SphereGeometry(1.8, 64, 64);\n  const sphere = new Mesh<BufferGeometry, MeshBasicMaterial>(\n    geometry,\n    new MeshBasicMaterial({\n      color,\n      side: BackSide,\n      transparent: true,\n      opacity: opacity ?? 0.2,\n    })\n  );\n\n  sphere.renderOrder = 0;\n\n  return sphere;\n}\n","import { GizmoOptions } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  RepeatWrapping,\n  SRGBColorSpace,\n  SpriteMaterial,\n} from \"three\";\n\nexport function getSpriteMaterial(\n  font: Required<GizmoOptions>[\"font\"],\n  resolution: number,\n  color: string,\n  text: string | undefined,\n  textColor: string | null,\n  hover: string | null,\n  hoverText: string | null,\n  circle: boolean = true,\n  border: boolean = false\n) {\n  const canvas = document.createElement(\"canvas\");\n  resolution = resolution ?? 64;\n\n  const offset = 0.02;\n\n  canvas.width = resolution * 2 + resolution * (offset * 4);\n  canvas.height = resolution + resolution * (offset * 2);\n\n  const radius = resolution / 2;\n  const centerY = resolution / 2 + resolution * offset;\n  const circle2X = centerY * 3;\n\n  const context = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n  drawCircle(context, radius, centerY, centerY, color, circle, border);\n  drawCircle(\n    context,\n    radius,\n    circle2X,\n    centerY,\n    hover || \"#FFF\",\n    circle,\n    border\n  );\n\n  if (text != null) {\n    const family = font.family || \"sans-serif\";\n    const weight = font.weight || 500;\n\n    const fixY = textFitBox(context, text, family, weight, resolution);\n\n    context.textAlign = \"center\";\n    context.textBaseline = \"middle\";\n    context.fillStyle = textColor || \"#000\";\n    context.fillText(text, centerY, centerY + fixY);\n    context.fillStyle = hoverText || textColor || \"#000\";\n    context.fillText(text, circle2X, centerY + fixY);\n  }\n\n  const texture = new CanvasTexture(canvas);\n  texture.colorSpace = SRGBColorSpace;\n  texture.wrapS = texture.wrapT = RepeatWrapping;\n  texture.repeat.x = 0.5;\n\n  return new SpriteMaterial({\n    map: texture,\n    toneMapped: false,\n    transparent: true,\n  });\n}\n\nfunction drawCircle(\n  context: CanvasRenderingContext2D,\n  radius: number,\n  x: number,\n  y: number,\n  color: string,\n  circle: boolean,\n  border: boolean = false\n) {\n  const borderSize = y * 0.1;\n  radius = border ? radius - borderSize : radius;\n\n  if (border) context.globalAlpha = 0.2;\n\n  if (circle) {\n    context.beginPath();\n    context.arc(x, y, radius, 0, 2 * Math.PI);\n    context.closePath();\n    context.fillStyle = color;\n    context.fill();\n  }\n\n  if (border) {\n    context.globalAlpha = 1;\n    context.strokeStyle = color;\n    context.lineWidth = borderSize;\n    context.stroke();\n  }\n}\n\nfunction textFitBox(\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  font: string,\n  weight: string | number,\n  size: number\n) {\n  const square = Math.sqrt(Math.pow(size * 0.7, 2) / 2);\n  let fontSize = square;\n  let textWidth = 0;\n  let textHeight = 0;\n\n  do {\n    ctx.font = `${weight} ${fontSize}px ${font}`;\n    const measure = ctx.measureText(text);\n    textWidth = measure.width;\n    textHeight = measure.fontBoundingBoxDescent;\n    fontSize--;\n  } while (textWidth > square && fontSize > 0);\n\n  const scaleFactor = Math.min(square / textWidth, square / textHeight);\n\n  const finalFontSize = Math.floor(fontSize * scaleFactor);\n\n  ctx.font = `${weight} ${finalFontSize}px ${font}`;\n\n  return square / textHeight;\n}\n","import { Color, Sprite } from \"three\";\nimport { getSpriteMaterial } from \"./getSpriteMaterial\";\nimport { GizmoOptions } from \"@lib/types\";\nimport { GIZMO_AXES } from \"./constants\";\n\nexport function getAxesSpritePoints(options: GizmoOptions) {\n  const colorManager = new Color();\n  const { font, resolution: spriteResolution } = options;\n\n  return GIZMO_AXES.map((key, i) => {\n    const { text, colors, circle, border } = options[key]!;\n    const isPositive = i < 3;\n    const axis = (isPositive ? key : key[1]) as \"x\" | \"y\" | \"z\";\n\n    const { text: textColor, main, hover, hoverText } = colors!;\n    const color = Array.isArray(main) ? main[1] : main!;\n    const forceScale = border && text;\n\n    const sprite = new Sprite(\n      getSpriteMaterial(\n        font!,\n        spriteResolution!,\n        colorManager.set(color).getStyle(),\n        text,\n        textColor != null ? colorManager.set(textColor).getStyle() : null,\n        hover != null ? colorManager.set(hover).getStyle() : null,\n        hoverText != null ? colorManager.set(hoverText).getStyle() : null,\n        circle ?? true,\n        border\n      )\n    );\n\n    sprite.userData.axis = key;\n    sprite.userData.forceScale = forceScale;\n    sprite.scale.setScalar(forceScale || isPositive ? 0.6 : 0.4);\n    sprite.position[axis] = isPositive ? 1.4 : -1.4;\n    sprite.renderOrder = 100;\n\n    return sprite;\n  });\n}\n","import { Camera, Sprite, Vector3 } from \"three\";\n\nconst axisMap: [\n  axis: \"x\" | \"y\" | \"z\",\n  positiveIndex: number,\n  negativeIndex: number\n][] = [\n  [\"x\", 0, 3],\n  [\"y\", 1, 4],\n  [\"z\", 2, 5],\n];\nconst primaryOpacity = 1;\nconst secondaryOpacity = 0.5;\n\nconst point = /*@__PURE__*/ new Vector3();\nexport function updateSpritesOpacity(sprites: Sprite[], camera: Camera): void {\n  point.set(0, 0, 1).applyQuaternion(camera.quaternion);\n\n  axisMap.forEach(([axis, positiveIndex, negativeIndex]) => {\n    const value = point[axis];\n\n    sprites[positiveIndex].material.opacity =\n      value >= 0 ? primaryOpacity : secondaryOpacity;\n    sprites[negativeIndex].material.opacity =\n      value >= 0 ? secondaryOpacity : primaryOpacity;\n  });\n}\n","import { Vector2 } from \"three\";\n\nexport const isClick = (\n  e: PointerEvent,\n  startCoords: Vector2,\n  threshold: number = 10\n) =>\n  Math.abs(e.clientX - startCoords.x) < threshold &&\n  Math.abs(e.clientY - startCoords.y) < threshold;\n","import { Sprite } from \"three\";\n\nexport function resetSprites(sprites: Sprite[]) {\n  for (let i = 0, l = sprites.length; i < l; i++) {\n    sprites[i].scale.setScalar(\n      i < 3 || sprites[i].userData.forceScale ? 0.6 : 0.4\n    );\n    sprites[i].material.map!.offset.x = 1;\n  }\n}\n","import { OrthographicCamera, Sprite, Vector2, Raycaster } from \"three\";\n\nconst _raycaster = /*@__PURE__*/ new Raycaster();\nconst _mouse = /*@__PURE__*/ new Vector2();\n\nexport function getIntersectionObject(\n  event: PointerEvent,\n  domRect: DOMRect,\n  orthoCamera: OrthographicCamera,\n  intersectionObjects: Sprite[]\n) {\n  _mouse.x = ((event.clientX - domRect.left) / domRect.width) * 2 - 1;\n  _mouse.y = -((event.clientY - domRect.top) / domRect.height) * 2 + 1;\n\n  _raycaster.setFromCamera(_mouse, orthoCamera);\n\n  const intersects = _raycaster.intersectObjects(intersectionObjects);\n\n  if (!intersects.length) return null;\n\n  const intersection = intersects[0];\n  return intersection.object as Sprite;\n}\n","export const clamp = (num: number, min: number, max: number) =>\n  Math.min(Math.max(num, min), max);\n","import { GizmoOptions } from \"@lib/types\";\nimport { BufferGeometry, Mesh, MeshBasicMaterial } from \"three\";\n\nexport const setSphereColor = (\n  sphere: Mesh<BufferGeometry, MeshBasicMaterial>,\n  { color, opacity, hoverColor, hoverOpacity }: GizmoOptions[\"sphere\"] = {},\n  hover: boolean = true\n) => {\n  const material = sphere.material;\n\n  material.color.set((hover && hoverColor) || color || 0xffffff);\n  material.opacity = hover ? hoverOpacity ?? 0.2 : opacity ?? 0;\n};\n","import {\n  BufferGeometry,\n  Clock,\n  Euler,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Sprite,\n  Vector2,\n  Vector3,\n  Vector4,\n  WebGLRenderer,\n} from \"three\";\n\nimport { createDomElement } from \"./utils/createDomElement\";\nimport { getAxesLines } from \"./utils/getAxesLines\";\nimport { getDomElement } from \"./utils/getDomElement\";\nimport { getBackgroundSphere } from \"./utils/getBackgroundSphere\";\nimport { getAxesSpritePoints } from \"./utils/getAxesSpritePoints\";\nimport { updateSpritesOpacity } from \"./utils/updateSpritesOpacity\";\nimport { isClick } from \"./utils/isClick\";\nimport { resetSprites } from \"./utils/resetSprites\";\nimport { getIntersectionObject } from \"./utils/getIntersectionObject\";\nimport { clamp } from \"./utils/clamp\";\n\nimport {\n  GizmoOptions,\n  ViewportGizmoEventMap,\n  GizmoDomPlacement,\n  GizmoAxisOptions,\n  OrientationAxes,\n} from \"./types\";\nimport {\n  GIZMO_AXES,\n  GIZMO_AXES_ORIENTATIONS,\n  GIZMO_DEFAULT_OPTIONS,\n  GIZMO_TURN_RATE,\n} from \"./utils/constants\";\nimport { setSphereColor } from \"./utils/setSphereColor\";\nimport type { OrbitControls } from \"three/examples/jsm/Addons.js\";\n\nexport type {\n  GizmoOptions,\n  ViewportGizmoEventMap,\n  GizmoDomPlacement,\n  GizmoAxisOptions,\n  OrientationAxes,\n};\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _euler = /*@__PURE__*/ new Euler();\n\n/**\n * ViewportGizmo is a 3D camera orientation controller that provides a visual interface\n * for changing the camera's viewing angle. It creates a widget that shows the current\n * camera orientation and allows direct manipulation of the view through clicking or dragging.\n *\n * @fires ViewportGizmo#start - Fired when a view change interaction begins\n * @fires ViewportGizmo#change - Fired during view changes\n * @fires ViewportGizmo#end - Fired when a view change interaction ends\n *\n * @extends Object3D\n */\nexport class ViewportGizmo extends Object3D<ViewportGizmoEventMap> {\n  /** Whether the gizmo is currently active and responding to user input */\n  enabled: boolean = true;\n\n  /** The camera being controlled by this gizmo */\n  camera: OrthographicCamera | PerspectiveCamera;\n\n  /** The point around which the camera rotates */\n  target = new Vector3();\n\n  /** Whether view changes should be animated */\n  animated: boolean = true;\n\n  /** The speed of view change animations. Higher values result in faster animations */\n  speed: number = 1;\n\n  /**\n   * Indicates whether the gizmo is currently being animated or not,\n   * Useful when interacting with other camera controllers\n   *\n   * @readonly This value is set internally.\n   **/\n  animating = false;\n\n  private _sphere?: Mesh<BufferGeometry, MeshBasicMaterial>;\n  private _sphereConfig?: GizmoOptions[\"sphere\"];\n  private _spritePoints: Sprite[];\n  private _viewport: Vector4 = new Vector4();\n  private _originalViewport: Vector4 = new Vector4();\n  private _originalScissor: Vector4 = new Vector4();\n  private _renderer: WebGLRenderer;\n  private _orthoCamera = new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 0, 4);\n  private _container: HTMLElement;\n  private _domElement: HTMLElement;\n  private _domRect!: DOMRect;\n  private _dragging: boolean = false;\n  private _distance: number = 0;\n  private _clock: Clock = new Clock();\n  private _targetPosition = new Vector3();\n  private _targetQuaternion = new Quaternion();\n  private _quaternionStart = new Quaternion();\n  private _quaternionEnd = new Quaternion();\n  private _mouseStart = new Vector2();\n  private _mouseAngle = new Vector2();\n  private _controls?: OrbitControls;\n  private _controlsListeners?: {\n    start: () => void;\n    end: () => void;\n    change: () => void;\n  };\n\n  /**\n   * Creates a new ViewportGizmo instance.\n   *\n   * @param camera - The camera to be controlled by this gizmo\n   * @param renderer - The WebGL renderer used to render the scene\n   * @param options - {@link GizmoOptions}, Configuration options for the gizmo\n   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string\n   * @param options.size - Size of the gizmo widget in pixels\n   * @param options.placement - Position of the gizmo in the viewport. One of:\n   *\n   *    - `\"top-left\"`\n   *    - `\"top-center\"`\n   *    - `\"top-right\"`\n   *    - `\"center-left\"`\n   *    - `\"center-center\"`\n   *    - `\"center-right\"`\n   *    - `\"bottom-left\"`\n   *    - `\"bottom-center\"`\n   *    - `\"bottom-right\"`\n   *\n   * @param options.animated - Whether view changes should be animated\n   * @param options.speed - Animation speed multiplier\n   * @param options.lineWidth - Width of the axis lines\n   * @param options.offset - Offset from the container edges in pixels\n   * @param options.offset.left - Offset from the left edge\n   * @param options.offset.top - Offset from the top edge\n   * @param options.offset.right - Offset from the right edge\n   * @param options.offset.bottom - Offset from the bottom edge\n   * @param options.sphere - Configuration for the background sphere\n   * @param options.sphere.enabled - Whether to show the background sphere\n   * @param options.sphere.color - Color of the background sphere\n   * @param options.sphere.opacity - Opacity of the background sphere\n   * @param options.sphere.hoverColor - Hover color of the background sphere\n   * @param options.sphere.hoverOpacity - Hover opacity of the background sphere\n   * @param options.id - HTML id attribute for the gizmo container\n   * @param options.className - HTML class attribute for the gizmo container\n   * @param options.font - Font configuration for axis labels\n   * @param options.font.family - Font family for axis labels\n   * @param options.font.weight - Font weight for axis labels\n   * @param options.resolution - Resolution of the gizmo rendering\n   * @param options.x - Configuration for positive X axis\n   * @param options.y - Configuration for positive Y axis\n   * @param options.z - Configuration for positive Z axis\n   * @param options.nx - Configuration for negative X axis\n   * @param options.ny - Configuration for negative Y axis\n   * @param options.nz - Configuration for negative Z axis\n   *\n   * @AXIS The following is the configuration for each AXIS `options.[x | y | z | nx | ny | nz]`:\n   *\n   * @param options.AXIS.text - Custom text label for the axis\n   * @param options.AXIS.circle - Whether to draw a circle indicator\n   * @param options.AXIS.line - Whether to draw the axis line\n   * @param options.AXIS.border - Whether to draw a border around the axis indicator\n   * @param options.AXIS.colors - Color configuration for the axis\n   * @param options.AXIS.colors.main - Main color(s) for the axis. Can be a single color or [normal, hover] colors\n   * @param options.AXIS.colors.hover - Hover color for the axis\n   * @param options.AXIS.colors.text - Color for the axis label\n   * @param options.AXIS.colors.hoverText - Color for the axis label on hover\n   */\n  constructor(\n    camera: PerspectiveCamera | OrthographicCamera,\n    renderer: WebGLRenderer,\n    options?: GizmoOptions\n  ) {\n    super();\n\n    this._renderer = renderer;\n    this.camera = camera;\n\n    this._orthoCamera.position.set(0, 0, 2);\n\n    options = { ...GIZMO_DEFAULT_OPTIONS, ...(options || {}) };\n\n    const {\n      container,\n      placement,\n      size,\n      animated,\n      speed,\n      offset,\n      sphere,\n      id,\n      className,\n    } = options as Required<GizmoOptions>;\n\n    this.animated = animated;\n    this.speed = speed;\n\n    const axesLines = getAxesLines(options);\n    if (axesLines) this.add(axesLines);\n\n    this._spritePoints = getAxesSpritePoints(options);\n    this.add(...this._spritePoints);\n\n    if (sphere.enabled) {\n      this._sphere = getBackgroundSphere(sphere);\n      this._sphereConfig = sphere;\n      this.add(this._sphere);\n    }\n\n    this._container = container ? getDomElement(container) : document.body;\n    this._domElement = createDomElement(placement, size, offset, id, className);\n    this._container.appendChild(this._domElement);\n\n    this._startListening();\n    this.update();\n  }\n\n  /**\n   * Renders the gizmo to the screen.\n   * This method handles viewport and scissor management to ensure the gizmo\n   * renders correctly without affecting the main scene rendering.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  render() {\n    if (this.animating) this._animate();\n\n    const { _renderer, _viewport } = this;\n\n    // save the current viewport config\n    const scissorTest = _renderer.getScissorTest();\n    const autoClear = _renderer.autoClear;\n\n    // render\n    _renderer.autoClear = false;\n    _renderer.setViewport(_viewport);\n    if (scissorTest) _renderer.setScissor(_viewport);\n\n    _renderer.clear(false, true, false);\n    _renderer.render(this, this._orthoCamera);\n\n    // reset the current viewport config\n    _renderer.setViewport(this._originalViewport);\n    if (scissorTest) _renderer.setScissor(this._originalScissor);\n\n    _renderer.autoClear = autoClear;\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's DOM-related properties based on its current position\n   * and size in the document.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  domUpdate() {\n    this._domRect = this._domElement.getBoundingClientRect();\n\n    const renderer = this._renderer;\n    const domRect = this._domRect;\n    const containerRect = renderer.domElement.getBoundingClientRect();\n\n    this._viewport.set(\n      domRect.left - containerRect.left,\n      renderer.domElement.clientHeight -\n        (domRect.top - containerRect.top + domRect.height),\n      domRect.width,\n      domRect.height\n    );\n\n    renderer.getViewport(this._originalViewport);\n    if (renderer.getScissorTest()) renderer.getScissor(this._originalScissor);\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's orientation to match the current camera orientation.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  cameraUpdate() {\n    this._updateOrientation();\n    return this;\n  }\n\n  /**\n   * Performs a complete update of the gizmo, including both DOM and camera-related updates.\n   *\n   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  update(controls: boolean = true) {\n    if (controls && this._controls) this._controls.update();\n    return this.domUpdate().cameraUpdate();\n  }\n\n  /**\n   * Connects OrbitControls with the gizmo, handling interaction states and updates.\n   * Automatically detaches any previously attached controls.\n   *\n   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}\n   */\n  attachControls(controls: OrbitControls) {\n    this.detachControls();\n\n    this.target = controls.target;\n\n    this._controlsListeners = {\n      start: () => (controls.enabled = false),\n      end: () => (controls.enabled = true),\n      change: () => this.update(false),\n    };\n\n    this.addEventListener(\"start\", this._controlsListeners.start);\n    this.addEventListener(\"end\", this._controlsListeners.end);\n    controls.addEventListener(\"change\", this._controlsListeners.change);\n\n    this._controls = controls;\n  }\n\n  /** Removes all control event listeners and references. Safe to call multiple times. */\n  detachControls() {\n    if (!this._controlsListeners || !this._controls) return;\n\n    this.target = new Vector3().copy(this._controls.target);\n\n    this.removeEventListener(\"start\", this._controlsListeners.start);\n    this.removeEventListener(\"end\", this._controlsListeners.end);\n\n    this._controls.removeEventListener(\n      \"change\",\n      this._controlsListeners.change\n    );\n\n    this._controlsListeners = undefined;\n    this._controls = undefined;\n  }\n\n  /** Cleans up all resources including geometries, materials, textures, and event listeners. */\n  dispose() {\n    this.detachControls();\n\n    this.children.forEach((child) => {\n      const mesh = child as Mesh<any, MeshBasicMaterial>;\n      mesh.material?.dispose();\n      mesh.material?.map?.dispose();\n      mesh.geometry?.dispose();\n    });\n\n    this._domElement.remove();\n  }\n\n  /**\n   * Updates the gizmo's orientation either based on the camera or internal state.\n   *\n   * @private\n   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)\n   */\n  private _updateOrientation(fromCamera: boolean = true) {\n    if (fromCamera) {\n      this.quaternion.copy(this.camera.quaternion).invert();\n      this.updateMatrixWorld();\n    }\n\n    updateSpritesOpacity(this._spritePoints, this.camera);\n  }\n\n  /**\n   * Handles the animation of camera position and orientation changes.\n   *\n   * @private\n   */\n  private _animate() {\n    const { position, quaternion } = this.camera;\n\n    position.set(0, 0, 1);\n\n    if (!this.animated) {\n      position\n        .applyQuaternion(this._quaternionEnd)\n        .multiplyScalar(this._distance)\n        .add(this.target);\n\n      quaternion.copy(this._targetQuaternion);\n\n      this._updateOrientation();\n\n      this.animating = false;\n      this.dispatchEvent({ type: \"change\" });\n      this.dispatchEvent({ type: \"end\" });\n      return;\n    }\n\n    const delta = this._clock.getDelta();\n\n    const step = delta * GIZMO_TURN_RATE * this.speed;\n\n    this._quaternionStart.rotateTowards(this._quaternionEnd, step);\n    position\n      .applyQuaternion(this._quaternionStart)\n      .multiplyScalar(this._distance)\n      .add(this.target);\n\n    quaternion.rotateTowards(this._targetQuaternion, step);\n\n    this._updateOrientation();\n    requestAnimationFrame(() => this.dispatchEvent({ type: \"change\" }));\n\n    if (this._quaternionStart.angleTo(this._quaternionEnd) === 0) {\n      this.animating = false;\n      this.dispatchEvent({ type: \"end\" });\n    }\n  }\n\n  /**\n   * Sets the camera orientation to look at the target from a specific axis.\n   *\n   * @private\n   * @param axis - The axis to orient the camera along\n   */\n  private _setOrientation(axis: (typeof GIZMO_AXES)[number]) {\n    const camera = this.camera;\n    const focusPoint = this.target;\n\n    const [position, orientation] = GIZMO_AXES_ORIENTATIONS[axis];\n    this._targetPosition.fromArray(position);\n    this._targetQuaternion.setFromEuler(_euler.fromArray(orientation));\n\n    this._targetPosition.multiplyScalar(this._distance).add(focusPoint);\n\n    _matrix.setPosition(camera.position);\n    _matrix.lookAt(camera.position, focusPoint, this.up);\n    this._quaternionStart.setFromRotationMatrix(_matrix);\n\n    _matrix.setPosition(this._targetPosition);\n    _matrix.lookAt(this._targetPosition, focusPoint, this.up);\n    this._quaternionEnd.setFromRotationMatrix(_matrix);\n\n    this.animating = true;\n    this._clock.start();\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Initializes event listeners for user interaction.\n   *\n   * @private\n   */\n  private _startListening() {\n    this._domElement.onpointerdown = (e) => this._onPointerDown(e);\n    this._domElement.onpointermove = (e) => this._onPointerMove(e);\n    this._domElement.onpointerleave = () => this._onPointerLeave();\n  }\n\n  /**\n   * Handles the pointer down event for starting drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerDown(e: PointerEvent) {\n    if (!this.enabled) return;\n\n    const drag = (e: PointerEvent) => {\n      if (!this._dragging) {\n        if (isClick(e, this._mouseStart)) return;\n\n        resetSprites(this._spritePoints);\n        this._dragging = true;\n      }\n\n      this._mouseAngle\n        .set(e.clientX, e.clientY)\n        .sub(this._mouseStart)\n        .multiplyScalar((1 / this._domRect.width) * Math.PI);\n\n      this.rotation.x = clamp(\n        rotationStart.x + this._mouseAngle.y,\n        Math.PI / -2 + 0.001,\n        Math.PI / 2 - 0.001\n      );\n      this.rotation.y = rotationStart.y + this._mouseAngle.x;\n      this.updateMatrixWorld();\n\n      this._quaternionStart.copy(this.quaternion).invert();\n\n      this.camera.position\n        .set(0, 0, 1)\n        .applyQuaternion(this._quaternionStart)\n        .multiplyScalar(this._distance)\n        .add(this.target);\n\n      this.camera.rotation.setFromQuaternion(this._quaternionStart);\n\n      this._updateOrientation(false);\n\n      this.dispatchEvent({ type: \"change\" });\n    };\n    const endDrag = () => {\n      document.removeEventListener(\"pointermove\", drag, false);\n      document.removeEventListener(\"pointerup\", endDrag, false);\n\n      if (!this._dragging) return this._handleClick(e);\n\n      this._dragging = false;\n      this.dispatchEvent({ type: \"end\" });\n    };\n\n    if (this.animating) return;\n\n    e.preventDefault();\n\n    this._mouseStart.set(e.clientX, e.clientY);\n\n    const rotationStart = _euler.copy(this.rotation);\n\n    this._distance = this.camera.position.distanceTo(this.target);\n\n    document.addEventListener(\"pointermove\", drag, false);\n    document.addEventListener(\"pointerup\", endDrag, false);\n\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Handles pointer move events for hover effects and drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerMove(e: PointerEvent) {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._sphere) setSphereColor(this._sphere, this._sphereConfig);\n\n    this._handleHover(e);\n  }\n\n  /**\n   * Handles pointer leave events to reset hover states.\n   *\n   * @private\n   */\n  private _onPointerLeave() {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._sphere) setSphereColor(this._sphere, this._sphereConfig, false);\n\n    resetSprites(this._spritePoints);\n    this._domElement.style.cursor = \"\";\n  }\n\n  /**\n   * Handles click events for axis selection.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleClick(e: PointerEvent) {\n    const object = getIntersectionObject(\n      e,\n      this._domRect,\n      this._orthoCamera,\n      this._spritePoints\n    );\n\n    if (!object) return;\n\n    this._setOrientation(object.userData.axis);\n    this.dispatchEvent({ type: \"change\" });\n  }\n\n  /**\n   * Handles hover effects for interactive elements.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleHover(e: PointerEvent) {\n    const object = getIntersectionObject(\n      e,\n      this._domRect,\n      this._orthoCamera,\n      this._spritePoints\n    );\n\n    resetSprites(this._spritePoints);\n\n    if (!object) {\n      this._domElement.style.cursor = \"\";\n    } else {\n      object.material.map!.offset.x = 0.5;\n      object.scale.multiplyScalar(1.2);\n      this._domElement.style.cursor = \"pointer\";\n    }\n  }\n}\n"],"names":["createDomElement","placement","size","offset","id","className","div","top","left","right","bottom","y","x","_box","Box3","_vector","Vector3","LineSegmentsGeometry","InstancedBufferGeometry","positions","uvs","index","Float32BufferAttribute","matrix","start","end","array","lineSegments","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","geometry","mesh","WireframeGeometry","Sphere","center","maxRadiusSq","i","il","three","Vector2","UniformsUtils","UniformsLib","LineMaterial","ShaderMaterial","parameters","ShaderLib","value","_start","_end","_start4","Vector4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","raycastWorldUnits","intersects","matrixWorld","instanceStart","instanceEnd","segmentCount","l","pointOnLine","point","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","Mesh","material","lineDistances","j","instanceDistanceBuffer","raycaster","worldUnits","threshold","sphereMargin","distanceToSphere","boxMargin","distanceToBox","LineGeometry","length","points","line","Line2","GIZMO_TURN_RATE","GIZMO_DEFAULT_OPTIONS","GIZMO_AXES","GIZMO_AXES_ORIENTATIONS","getAxesLines","options","colorManager","Color","key","axis","negative","main","color1","color2","getDomElement","domElement","element","getBackgroundSphere","color","opacity","SphereGeometry","sphere","MeshBasicMaterial","BackSide","getSpriteMaterial","font","text","textColor","hover","hoverText","circle","border","canvas","radius","centerY","circle2X","context","drawCircle","family","weight","fixY","textFitBox","texture","CanvasTexture","SRGBColorSpace","RepeatWrapping","SpriteMaterial","borderSize","ctx","square","fontSize","textWidth","textHeight","measure","scaleFactor","finalFontSize","getAxesSpritePoints","spriteResolution","isPositive","forceScale","sprite","Sprite","axisMap","primaryOpacity","secondaryOpacity","updateSpritesOpacity","sprites","positiveIndex","negativeIndex","isClick","e","startCoords","resetSprites","_raycaster","Raycaster","_mouse","getIntersectionObject","event","domRect","orthoCamera","intersectionObjects","clamp","num","min","max","setSphereColor","hoverColor","hoverOpacity","_matrix","_euler","Euler","ViewportGizmo","Object3D","renderer","__publicField","OrthographicCamera","Clock","Quaternion","container","animated","speed","axesLines","_renderer","_viewport","scissorTest","autoClear","containerRect","controls","child","_a","_c","_b","_d","fromCamera","position","quaternion","step","focusPoint","orientation","drag","rotationStart","endDrag","object"],"mappings":"qbAEO,MAAMA,EAAmB,CAC9BC,EACAC,EACAC,EACAC,EACAC,IACG,CACG,MAAAC,EAAM,SAAS,cAAc,KAAK,EAElCC,EAAMJ,EAAO,KAAO,EACpBK,EAAOL,EAAO,MAAQ,EACtBM,EAAQN,EAAO,OAAS,EACxBO,EAASP,EAAO,QAAU,EAC1B,CAACQ,EAAGC,CAAC,EAAIX,EAAU,MAAM,GAAG,EAE3B,cAAA,OAAOK,EAAI,MAAO,CACvB,OAAQ,GAAGJ,CAAI,KACf,MAAO,GAAGA,CAAI,KACd,aAAc,OACd,SAAU,WACV,WAAY,QACZ,QAAS,IACT,OAAQ,QACR,UAAW,GAAGU,IAAM,SAAW,mBAAqB,EAAE,IACpDD,IAAM,SAAW,mBAAqB,EACxC,GACA,OAAQ,GAAGJ,CAAG,MAAME,CAAK,MAAMC,CAAM,MAAMF,CAAI,KAC/C,KAAMI,IAAM,OAAS,IAAMA,IAAM,SAAW,MAAQ,GACpD,MAAOA,IAAM,QAAU,IAAM,GAC7B,IAAKD,IAAM,MAAQ,IAAMA,IAAM,SAAW,GAAK,MAC/C,OAAQA,IAAM,SAAW,IAAM,EAAA,CAChC,EAEGP,MAAQ,GAAKA,GACbC,MAAe,UAAYA,GAExBC,CACT,EC5BMO,EAAO,IAAIC,EAAAA,KACXC,EAAU,IAAIC,EAAAA,QAEpB,MAAMC,UAA6BC,EAAAA,uBAAwB,CAE1D,aAAc,CAEb,MAAO,EAEP,KAAK,uBAAyB,GAE9B,KAAK,KAAO,uBAEZ,MAAMC,EAAY,CAAE,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,CAAG,EAClGC,EAAM,CAAE,GAAK,EAAG,EAAG,EAAG,GAAK,EAAG,EAAG,EAAG,GAAK,GAAK,EAAG,GAAK,GAAK,GAAK,EAAG,EAAK,EACxEC,EAAQ,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAG,EAEtE,KAAK,SAAUA,CAAO,EACtB,KAAK,aAAc,WAAY,IAAIC,EAAAA,uBAAwBH,EAAW,EAAK,EAC3E,KAAK,aAAc,KAAM,IAAIG,EAAAA,uBAAwBF,EAAK,EAAK,CAEjE,CAEC,aAAcG,EAAS,CAEtB,MAAMC,EAAQ,KAAK,WAAW,cACxBC,EAAM,KAAK,WAAW,YAE5B,OAAKD,IAAU,SAEdA,EAAM,aAAcD,CAAQ,EAE5BE,EAAI,aAAcF,CAAQ,EAE1BC,EAAM,YAAc,IAIhB,KAAK,cAAgB,MAEzB,KAAK,mBAAoB,EAIrB,KAAK,iBAAmB,MAE5B,KAAK,sBAAuB,EAItB,IAET,CAEC,aAAcE,EAAQ,CAErB,IAAIC,EAECD,aAAiB,aAErBC,EAAeD,EAEJ,MAAM,QAASA,KAE1BC,EAAe,IAAI,aAAcD,CAAO,GAIzC,MAAME,EAAiB,IAAIC,EAA0B,2BAAEF,EAAc,EAAG,CAAC,EAEzE,YAAK,aAAc,gBAAiB,IAAIG,EAAAA,2BAA4BF,EAAgB,EAAG,CAAC,GACxF,KAAK,aAAc,cAAe,IAAIE,EAAAA,2BAA4BF,EAAgB,EAAG,CAAC,GAItF,KAAK,mBAAoB,EACzB,KAAK,sBAAuB,EAErB,IAET,CAEC,UAAWF,EAAQ,CAElB,IAAIK,EAECL,aAAiB,aAErBK,EAASL,EAEE,MAAM,QAASA,KAE1BK,EAAS,IAAI,aAAcL,CAAO,GAInC,MAAMM,EAAsB,IAAIH,EAA0B,2BAAEE,EAAQ,EAAG,CAAC,EAExE,YAAK,aAAc,qBAAsB,IAAID,EAAAA,2BAA4BE,EAAqB,EAAG,CAAC,GAClG,KAAK,aAAc,mBAAoB,IAAIF,EAAAA,2BAA4BE,EAAqB,EAAG,CAAC,GAEzF,IAET,CAEC,sBAAuBC,EAAW,CAEjC,YAAK,aAAcA,EAAS,WAAW,SAAS,KAAO,EAEhD,IAET,CAEC,kBAAmBA,EAAW,CAE7B,YAAK,aAAcA,EAAS,WAAW,SAAS,KAAO,EAEhD,IAET,CAEC,SAAUC,EAAO,CAEhB,YAAK,sBAAuB,IAAIC,EAAiB,kBAAED,EAAK,QAAQ,CAAI,EAI7D,IAET,CAEC,iBAAkBP,EAAe,CAEhC,MAAMM,EAAWN,EAAa,SAE9B,YAAK,aAAcM,EAAS,WAAW,SAAS,KAAK,EAI9C,IAET,CAEC,oBAAqB,CAEf,KAAK,cAAgB,OAEzB,KAAK,YAAc,IAAInB,QAIxB,MAAMU,EAAQ,KAAK,WAAW,cACxBC,EAAM,KAAK,WAAW,YAEvBD,IAAU,QAAaC,IAAQ,SAEnC,KAAK,YAAY,uBAAwBD,CAAO,EAEhDX,EAAK,uBAAwBY,CAAK,EAElC,KAAK,YAAY,MAAOZ,CAAM,EAIjC,CAEC,uBAAwB,CAElB,KAAK,iBAAmB,OAE5B,KAAK,eAAiB,IAAIuB,UAItB,KAAK,cAAgB,MAEzB,KAAK,mBAAoB,EAI1B,MAAMZ,EAAQ,KAAK,WAAW,cACxBC,EAAM,KAAK,WAAW,YAE5B,GAAKD,IAAU,QAAaC,IAAQ,OAAY,CAE/C,MAAMY,EAAS,KAAK,eAAe,OAEnC,KAAK,YAAY,UAAWA,CAAQ,EAEpC,IAAIC,EAAc,EAElB,QAAUC,EAAI,EAAGC,EAAKhB,EAAM,MAAOe,EAAIC,EAAID,IAE1CxB,EAAQ,oBAAqBS,EAAOe,CAAG,EACvCD,EAAc,KAAK,IAAKA,EAAaD,EAAO,kBAAmBtB,EAAW,EAE1EA,EAAQ,oBAAqBU,EAAKc,CAAG,EACrCD,EAAc,KAAK,IAAKA,EAAaD,EAAO,kBAAmBtB,EAAW,EAI3E,KAAK,eAAe,OAAS,KAAK,KAAMuB,CAAa,EAEhD,MAAO,KAAK,eAAe,MAAM,GAErC,QAAQ,MAAO,wIAAyI,IAAM,CAIlK,CAEA,CAEC,QAAS,CAIV,CAEC,YAAaf,EAAS,CAErB,eAAQ,KAAM,+EAAiF,EAExF,KAAK,aAAcA,CAAQ,CAEpC,CAEA,CCxNWkB,EAAA,YAAC,KAAO,CAElB,WAAY,CAAE,MAAO,CAAG,EACxB,UAAW,CAAE,MAAO,CAAG,EACvB,WAAY,CAAE,MAAO,IAAIC,EAAO,QAAE,EAAG,CAAC,CAAI,EAC1C,WAAY,CAAE,MAAO,CAAG,EACxB,UAAW,CAAE,MAAO,CAAG,EACvB,SAAU,CAAE,MAAO,CAAG,EACtB,QAAS,CAAE,MAAO,CAAG,CAEtB,EAESD,EAAA,UAAE,KAAW,CAErB,SAAUE,EAAa,cAAC,MAAO,CAC9BC,EAAAA,YAAY,OACZA,EAAAA,YAAY,IACZA,cAAY,IACd,CAAI,EAEH,aACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAqNV,eACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAgKX,EAEA,MAAMC,UAAqBC,EAAAA,cAAe,CAEzC,YAAaC,EAAa,CAEzB,MAAO,CAEN,KAAM,eAEN,SAAUJ,EAAa,cAAC,MAAOK,EAAS,UAAE,KAAS,QAAU,EAE7D,aAAcA,EAAAA,UAAW,KAAS,aAClC,eAAgBA,EAAAA,UAAW,KAAS,eAEpC,SAAU,EAEb,CAAK,EAEH,KAAK,eAAiB,GAEtB,KAAK,UAAWD,CAAY,CAE9B,CAEC,IAAI,OAAQ,CAEX,OAAO,KAAK,SAAS,QAAQ,KAE/B,CAEC,IAAI,MAAOE,EAAQ,CAElB,KAAK,SAAS,QAAQ,MAAQA,CAEhC,CAEC,IAAI,YAAa,CAEhB,MAAO,gBAAiB,KAAK,OAE/B,CAEC,IAAI,WAAYA,EAAQ,CAElBA,IAAU,GAEd,KAAK,QAAQ,YAAc,GAI3B,OAAO,KAAK,QAAQ,WAIvB,CAEC,IAAI,WAAY,CAEf,OAAO,KAAK,SAAS,UAAU,KAEjC,CAEC,IAAI,UAAWA,EAAQ,CAEf,KAAK,SAAS,YACrB,KAAK,SAAS,UAAU,MAAQA,EAElC,CAEC,IAAI,QAAS,CAEZ,MAAO,aAAc,KAAK,OAE5B,CAEC,IAAI,OAAQA,EAAQ,CAEZA,IAAU,KAAW,KAAK,SAEhC,KAAK,YAAc,IAIfA,IAAU,GAEd,KAAK,QAAQ,SAAW,GAIxB,OAAO,KAAK,QAAQ,QAIvB,CAEC,IAAI,WAAY,CAEf,OAAO,KAAK,SAAS,UAAU,KAEjC,CAEC,IAAI,UAAWA,EAAQ,CAEtB,KAAK,SAAS,UAAU,MAAQA,CAElC,CAEC,IAAI,UAAW,CAEd,OAAO,KAAK,SAAS,SAAS,KAEhC,CAEC,IAAI,SAAUA,EAAQ,CAErB,KAAK,SAAS,SAAS,MAAQA,CAEjC,CAEC,IAAI,YAAa,CAEhB,OAAO,KAAK,SAAS,WAAW,KAElC,CAEC,IAAI,WAAYA,EAAQ,CAEvB,KAAK,SAAS,WAAW,MAAQA,CAEnC,CAEC,IAAI,SAAU,CAEb,OAAO,KAAK,SAAS,QAAQ,KAE/B,CAEC,IAAI,QAASA,EAAQ,CAEpB,KAAK,SAAS,QAAQ,MAAQA,CAEhC,CAEC,IAAI,SAAU,CAEb,OAAO,KAAK,SAAS,QAAQ,KAE/B,CAEC,IAAI,QAASA,EAAQ,CAEb,KAAK,WACZ,KAAK,SAAS,QAAQ,MAAQA,EAEhC,CAEC,IAAI,YAAa,CAEhB,OAAO,KAAK,SAAS,WAAW,KAElC,CAEC,IAAI,WAAYA,EAAQ,CAEvB,KAAK,SAAS,WAAW,MAAM,KAAMA,CAAO,CAE9C,CAEC,IAAI,iBAAkB,CAErB,MAAO,0BAA2B,KAAK,OAEzC,CAEC,IAAI,gBAAiBA,EAAQ,CAErB,KAAK,UAELA,IAAU,KAAW,KAAK,kBAEhC,KAAK,YAAc,IAIfA,IAAU,IAEd,KAAK,QAAQ,sBAAwB,GACrC,KAAK,WAAW,YAAc,KAI9B,OAAO,KAAK,QAAQ,sBACpB,KAAK,WAAW,YAAc,IAIjC,CAEA,CCzlBA,MAAMC,EAAS,IAAIlC,EAAAA,QACbmC,EAAO,IAAInC,EAAAA,QAEXoC,EAAU,IAAIC,EAAAA,QACdC,EAAQ,IAAID,EAAAA,QAEZE,EAAY,IAAIF,EAAAA,QAChBG,EAAa,IAAIxC,EAAAA,QACjByC,EAAY,IAAIC,EAAAA,QAChBC,EAAQ,IAAIC,EAAAA,MACZC,EAAgB,IAAI7C,EAAAA,QAEpBH,EAAO,IAAIC,EAAAA,KACXgD,EAAU,IAAI1B,EAAAA,OACd2B,EAAqB,IAAIV,EAAAA,QAE/B,IAAIW,EAAMC,EAIV,SAASC,EAAwBC,EAAQC,EAAUC,EAAa,CAK/D,OAAAN,EAAmB,IAAK,EAAG,EAAG,CAAEK,EAAU,GAAM,aAAcD,EAAO,gBAAkB,EACvFJ,EAAmB,eAAgB,EAAMA,EAAmB,CAAG,EAC/DA,EAAmB,EAAIE,EAAaI,EAAW,MAC/CN,EAAmB,EAAIE,EAAaI,EAAW,OAC/CN,EAAmB,aAAcI,EAAO,uBAAyB,EACjEJ,EAAmB,eAAgB,EAAMA,EAAmB,CAAG,EAExD,KAAK,IAAK,KAAK,IAAKA,EAAmB,EAAGA,EAAmB,EAAK,CAE1E,CAEA,SAASO,GAAmB3C,EAAc4C,EAAa,CAEtD,MAAMC,EAAc7C,EAAa,YAC3BM,EAAWN,EAAa,SACxB8C,EAAgBxC,EAAS,WAAW,cACpCyC,EAAczC,EAAS,WAAW,YAClC0C,EAAe,KAAK,IAAK1C,EAAS,cAAewC,EAAc,KAAO,EAE5E,QAAUlC,EAAI,EAAGqC,EAAID,EAAcpC,EAAIqC,EAAGrC,IAAO,CAEhDoB,EAAM,MAAM,oBAAqBc,EAAelC,CAAG,EACnDoB,EAAM,IAAI,oBAAqBe,EAAanC,CAAG,EAE/CoB,EAAM,aAAca,CAAa,EAEjC,MAAMK,EAAc,IAAI7D,UAClB8D,EAAQ,IAAI9D,UAElBgD,EAAK,oBAAqBL,EAAM,MAAOA,EAAM,IAAKmB,EAAOD,CAAa,EACrDC,EAAM,WAAYD,CAAa,EAAGZ,EAAa,IAI/DM,EAAW,KAAM,CAChB,MAAAO,EACA,YAAAD,EACA,SAAUb,EAAK,OAAO,WAAYc,CAAO,EACzC,OAAQnD,EACR,KAAM,KACN,UAAWY,EACX,GAAI,KACJ,IAAK,IACT,CAAM,CAIN,CAEA,CAEA,SAASwC,GAAoBpD,EAAcwC,EAAQI,EAAa,CAE/D,MAAMS,EAAmBb,EAAO,iBAE1BE,EADW1C,EAAa,SACF,WACtB6C,EAAc7C,EAAa,YAE3BM,EAAWN,EAAa,SACxB8C,EAAgBxC,EAAS,WAAW,cACpCyC,EAAczC,EAAS,WAAW,YAClC0C,EAAe,KAAK,IAAK1C,EAAS,cAAewC,EAAc,KAAO,EAEtEQ,EAAO,CAAEd,EAAO,KAOtBH,EAAK,GAAI,EAAGT,CAAW,EAGvBA,EAAU,EAAI,EACdA,EAAU,aAAcY,EAAO,kBAAoB,EACnDZ,EAAU,aAAcyB,CAAkB,EAC1CzB,EAAU,eAAgB,EAAIA,EAAU,CAAG,EAG3CA,EAAU,GAAKc,EAAW,EAAI,EAC9Bd,EAAU,GAAKc,EAAW,EAAI,EAC9Bd,EAAU,EAAI,EAEdC,EAAW,KAAMD,CAAW,EAE5BE,EAAU,iBAAkBU,EAAO,mBAAoBK,CAAa,EAEpE,QAAUjC,EAAI,EAAGqC,EAAID,EAAcpC,EAAIqC,EAAGrC,IAAO,CAchD,GAZAa,EAAQ,oBAAqBqB,EAAelC,CAAG,EAC/Ce,EAAM,oBAAqBoB,EAAanC,CAAG,EAE3Ca,EAAQ,EAAI,EACZE,EAAM,EAAI,EAGVF,EAAQ,aAAcK,CAAW,EACjCH,EAAM,aAAcG,CAAW,EAGJL,EAAQ,EAAI6B,GAAQ3B,EAAM,EAAI2B,EAGxD,SAKD,GAAK7B,EAAQ,EAAI6B,EAAO,CAEvB,MAAMC,EAAY9B,EAAQ,EAAIE,EAAM,EAC9B6B,GAAM/B,EAAQ,EAAI6B,GAASC,EACjC9B,EAAQ,KAAME,EAAO6B,CAAG,CAE3B,SAAc7B,EAAM,EAAI2B,EAAO,CAE5B,MAAMC,EAAY5B,EAAM,EAAIF,EAAQ,EAC9B+B,GAAM7B,EAAM,EAAI2B,GAASC,EAC/B5B,EAAM,KAAMF,EAAS+B,CAAG,CAE3B,CAGE/B,EAAQ,aAAc4B,CAAkB,EACxC1B,EAAM,aAAc0B,CAAkB,EAGtC5B,EAAQ,eAAgB,EAAIA,EAAQ,CAAG,EACvCE,EAAM,eAAgB,EAAIA,EAAM,CAAG,EAGnCF,EAAQ,GAAKiB,EAAW,EAAI,EAC5BjB,EAAQ,GAAKiB,EAAW,EAAI,EAE5Bf,EAAM,GAAKe,EAAW,EAAI,EAC1Bf,EAAM,GAAKe,EAAW,EAAI,EAG1BV,EAAM,MAAM,KAAMP,CAAS,EAC3BO,EAAM,MAAM,EAAI,EAEhBA,EAAM,IAAI,KAAML,CAAO,EACvBK,EAAM,IAAI,EAAI,EAGd,MAAMyB,EAAQzB,EAAM,6BAA8BH,EAAY,EAAM,EACpEG,EAAM,GAAIyB,EAAOvB,CAAe,EAGhC,MAAMwB,EAAOC,EAAS,UAAC,KAAMlC,EAAQ,EAAGE,EAAM,EAAG8B,CAAO,EAClDG,EAAgBF,GAAQ,IAAOA,GAAQ,EAEvCG,EAAWhC,EAAW,WAAYK,CAAe,EAAGI,EAAa,GAEvE,GAAKsB,GAAiBC,EAAW,CAEhC7B,EAAM,MAAM,oBAAqBc,EAAelC,CAAG,EACnDoB,EAAM,IAAI,oBAAqBe,EAAanC,CAAG,EAE/CoB,EAAM,MAAM,aAAca,CAAa,EACvCb,EAAM,IAAI,aAAca,CAAa,EAErC,MAAMK,EAAc,IAAI7D,UAClB8D,EAAQ,IAAI9D,UAElBgD,EAAK,oBAAqBL,EAAM,MAAOA,EAAM,IAAKmB,EAAOD,CAAa,EAEtEN,EAAW,KAAM,CAChB,MAAOO,EACP,YAAaD,EACb,SAAUb,EAAK,OAAO,WAAYc,CAAO,EACzC,OAAQnD,EACR,KAAM,KACN,UAAWY,EACX,GAAI,KACJ,IAAK,IACT,CAAM,CAEN,CAEA,CAEA,CAEA,MAAMkD,WAAsBC,EAAAA,IAAK,CAEhC,YAAazD,EAAW,IAAIhB,EAAwB0E,EAAW,IAAI9C,EAAc,CAAE,MAAO,KAAK,SAAW,QAAU,CAAA,EAAK,CAExH,MAAOZ,EAAU0D,CAAU,EAE3B,KAAK,gBAAkB,GAEvB,KAAK,KAAO,eAEd,CAIC,sBAAuB,CAEtB,MAAM1D,EAAW,KAAK,SAEhBwC,EAAgBxC,EAAS,WAAW,cACpCyC,EAAczC,EAAS,WAAW,YAClC2D,EAAgB,IAAI,aAAc,EAAInB,EAAc,KAAO,EAEjE,QAAUlC,EAAI,EAAGsD,EAAI,EAAGjB,EAAIH,EAAc,MAAOlC,EAAIqC,EAAGrC,IAAMsD,GAAK,EAElE3C,EAAO,oBAAqBuB,EAAelC,CAAG,EAC9CY,EAAK,oBAAqBuB,EAAanC,CAAG,EAE1CqD,EAAeC,CAAG,EAAKA,IAAM,EAAM,EAAID,EAAeC,EAAI,CAAG,EAC7DD,EAAeC,EAAI,GAAMD,EAAeC,GAAM3C,EAAO,WAAYC,CAAM,EAIxE,MAAM2C,EAAyB,IAAIjE,EAA0B,2BAAE+D,EAAe,EAAG,CAAC,EAElF,OAAA3D,EAAS,aAAc,wBAAyB,IAAIH,EAAAA,2BAA4BgE,EAAwB,EAAG,CAAC,GAC5G7D,EAAS,aAAc,sBAAuB,IAAIH,EAAAA,2BAA4BgE,EAAwB,EAAG,CAAC,GAEnG,IAET,CAEC,QAASC,EAAWxB,EAAa,CAEhC,MAAMyB,EAAa,KAAK,SAAS,WAC3B7B,EAAS4B,EAAU,OAEpB5B,IAAW,MAAQ,CAAE6B,GAEzB,QAAQ,MAAO,+HAAiI,EAIjJ,MAAMC,EAAcF,EAAU,OAAO,QAAU,QAAcA,EAAU,OAAO,MAAM,WAAa,EAEjG/B,EAAO+B,EAAU,IAEjB,MAAMvB,EAAc,KAAK,YACnBvC,EAAW,KAAK,SAChB0D,EAAW,KAAK,SAEtB1B,EAAa0B,EAAS,UAAYM,EAG7BhE,EAAS,iBAAmB,MAEhCA,EAAS,sBAAuB,EAIjC6B,EAAQ,KAAM7B,EAAS,cAAc,EAAG,aAAcuC,CAAa,EAGnE,IAAI0B,EACJ,GAAKF,EAEJE,EAAejC,EAAa,OAEtB,CAEN,MAAMkC,EAAmB,KAAK,IAAKhC,EAAO,KAAML,EAAQ,gBAAiBE,EAAK,OAAU,EACxFkC,EAAehC,EAAwBC,EAAQgC,EAAkBR,EAAS,UAAY,CAEzF,CAIE,GAFA7B,EAAQ,QAAUoC,EAEblC,EAAK,iBAAkBF,CAAO,IAAO,GAEzC,OAKI7B,EAAS,cAAgB,MAE7BA,EAAS,mBAAoB,EAI9BpB,EAAK,KAAMoB,EAAS,WAAW,EAAG,aAAcuC,CAAa,EAG7D,IAAI4B,EACJ,GAAKJ,EAEJI,EAAYnC,EAAa,OAEnB,CAEN,MAAMoC,EAAgB,KAAK,IAAKlC,EAAO,KAAMtD,EAAK,gBAAiBmD,EAAK,OAAU,EAClFoC,EAAYlC,EAAwBC,EAAQkC,EAAeV,EAAS,UAAY,CAEnF,CAEE9E,EAAK,eAAgBuF,CAAW,EAE3BpC,EAAK,cAAenD,CAAI,IAAO,KAM/BmF,EAEJ1B,GAAmB,KAAMC,CAAY,EAIrCQ,GAAoB,KAAMZ,EAAQI,CAAY,EAIjD,CAEA,CCpWA,MAAM+B,UAAqBrF,CAAqB,CAE/C,aAAc,CAEb,MAAO,EAEP,KAAK,eAAiB,GAEtB,KAAK,KAAO,cAEd,CAEC,aAAcS,EAAQ,CAIrB,MAAM6E,EAAS7E,EAAM,OAAS,EACxB8E,EAAS,IAAI,aAAc,EAAID,CAAQ,EAE7C,QAAUhE,EAAI,EAAGA,EAAIgE,EAAQhE,GAAK,EAEjCiE,EAAQ,EAAIjE,GAAMb,EAAOa,CAAG,EAC5BiE,EAAQ,EAAIjE,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EACpCiE,EAAQ,EAAIjE,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EAEpCiE,EAAQ,EAAIjE,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EACpCiE,EAAQ,EAAIjE,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EACpCiE,EAAQ,EAAIjE,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EAIrC,aAAM,aAAciE,CAAQ,EAErB,IAET,CAEC,UAAW9E,EAAQ,CAIlB,MAAM6E,EAAS7E,EAAM,OAAS,EACxBK,EAAS,IAAI,aAAc,EAAIwE,CAAQ,EAE7C,QAAUhE,EAAI,EAAGA,EAAIgE,EAAQhE,GAAK,EAEjCR,EAAQ,EAAIQ,GAAMb,EAAOa,CAAG,EAC5BR,EAAQ,EAAIQ,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EACpCR,EAAQ,EAAIQ,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EAEpCR,EAAQ,EAAIQ,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EACpCR,EAAQ,EAAIQ,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EACpCR,EAAQ,EAAIQ,EAAI,CAAG,EAAGb,EAAOa,EAAI,CAAG,EAIrC,aAAM,UAAWR,CAAQ,EAElB,IAET,CAEC,SAAU0E,EAAO,CAEhB,MAAMxE,EAAWwE,EAAK,SAEtB,YAAK,aAAcxE,EAAS,WAAW,SAAS,KAAK,EAI9C,IAET,CAEA,CCxEA,MAAMyE,WAAcjB,EAAc,CAEjC,YAAaxD,EAAW,IAAIqE,EAAgBX,EAAW,IAAI9C,EAAc,CAAE,MAAO,KAAK,SAAW,QAAU,CAAA,EAAK,CAEhH,MAAOZ,EAAU0D,CAAU,EAE3B,KAAK,QAAU,GAEf,KAAK,KAAO,OAEd,CAEA,CCba,MAAAgB,GAAkB,EAAI,KAAK,GAE3BC,GAAsC,CACjD,UAAW,SAAS,KACpB,UAAW,YACX,KAAM,IACN,UAAW,GACX,SAAU,GACV,MAAO,EACP,OAAQ,CACN,IAAK,GACL,KAAM,GACN,MAAO,GACP,OAAQ,EACV,EACA,KAAM,CACJ,OAAQ,YACR,OAAQ,GACV,EACA,WAAY,GACZ,OAAQ,CACN,QAAS,GACT,MAAO,SACP,QAAS,EACT,WAAY,SACZ,aAAc,EAChB,EACA,EAAG,CACD,KAAM,IACN,OAAQ,CACN,KAAM,SAAA,CAEV,EACA,EAAG,CACD,KAAM,IACN,OAAQ,CACN,KAAM,SAAA,CAEV,EACA,EAAG,CACD,KAAM,IACN,OAAQ,CACN,KAAM,SAAA,CAEV,EACA,GAAI,CACF,KAAM,GACN,OAAQ,CACN,KAAM,SAAA,CAEV,EACA,GAAI,CACF,KAAM,GACN,OAAQ,CACN,KAAM,SAAA,CAEV,EACA,GAAI,CACF,KAAM,GACN,OAAQ,CACN,KAAM,SAAA,CACR,CAEJ,EAEaC,EAAa,CAAC,IAAK,IAAK,IAAK,KAAM,KAAM,IAAI,EAE7CC,GAGT,CACF,EAAG,CACD,CAAC,EAAG,EAAG,CAAC,EACR,CAAC,EAAG,KAAK,GAAK,GAAK,CAAC,CACtB,EAEA,EAAG,CACD,CAAC,EAAG,EAAG,CAAC,EACR,CAAC,CAAC,KAAK,GAAK,GAAK,EAAG,CAAC,CACvB,EAEA,EAAG,CACD,CAAC,EAAG,EAAG,CAAC,EACR,CAAC,EAAG,EAAG,CAAC,CACV,EAEA,GAAI,CACF,CAAC,GAAI,EAAG,CAAC,EACT,CAAC,EAAG,CAAC,KAAK,GAAK,GAAK,CAAC,CACvB,EAEA,GAAI,CACF,CAAC,EAAG,GAAI,CAAC,EACT,CAAC,KAAK,GAAK,GAAK,EAAG,CAAC,CACtB,EAEA,GAAI,CACF,CAAC,EAAG,EAAG,EAAE,EACT,CAAC,EAAG,KAAK,GAAI,CAAC,CAAA,CAElB,EChGaC,GAAgBC,GAA0B,CAC/C,MAAAC,EAAe,IAAIC,QACnB/F,EAAsB,CAAC,EACvBY,EAAmB,CAAC,EA4BtB,GA1BO8E,EAAA,QAAQ,CAACM,EAAK5E,IAAM,CACvB,MAAA6E,EAAOJ,EAAQG,CAAG,EAEpB,GAAAC,EAAK,OAAS,GAAO,OAEnB,MAAAC,EAAW9E,EAAI,EAAI,IAAM,KACzB6B,EAAW7B,EAAI,EAAI,EAAI,MAEnBpB,EAAA,KACRgG,EAAI,SAAS,GAAG,EAAI/C,EAAWiD,EAAW,EAC1CF,EAAI,SAAS,GAAG,EAAI/C,EAAWiD,EAAW,EAC1CF,EAAI,SAAS,GAAG,EAAI/C,EAAWiD,EAAW,EAC1C,EACA,EACA,CACF,EAEM,MAAAC,EAAOF,EAAK,OAAQ,KAEpB,CAACG,EAAQC,CAAM,EAAI,MAAM,QAAQF,CAAI,EAAIA,EAAO,CAACA,EAAMA,CAAI,EAC1DvF,EAAA,KACL,GAAGkF,EAAa,IAAIO,CAAM,EAAE,QAAQ,EACpC,GAAGP,EAAa,IAAIM,CAAM,EAAE,QAAQ,CACtC,CAAA,CACD,EAEG,CAACpG,EAAU,OAAe,OAAA,KAExB,MAAAc,EAAW,IAAIqE,EACrBrE,EAAS,aAAad,CAAS,EAC/Bc,EAAS,UAAUF,CAAM,EAEnB,MAAA4D,EAAW,IAAI9C,EAAa,CAChC,UAAWmE,EAAQ,WAAa,GAChC,aAAc,GACd,WAAY,IAAItE,EAAA,QAAQ,OAAO,WAAY,OAAO,WAAW,CAAA,CAC9D,EAGK+D,EAAO,IAAIC,GAAMzE,EAAU0D,CAAQ,EACzC,OAAAc,EAAK,qBAAqB,EAC1BA,EAAK,MAAM,IAAI,EAAG,EAAG,CAAC,EACtBA,EAAK,YAAc,EAEZA,CACT,ECzDagB,GACXC,GACgB,CAChB,MAAMC,EACJ,OAAOD,GAAe,SAClB,SAAS,cAA2BA,CAAU,EAC9CA,EAEN,GAAI,CAACC,EAAe,MAAA,MAAM,qBAAqB,EAExC,OAAAA,CACT,ECFO,SAASC,GAAoB,CAClC,MAAAC,EACA,QAAAC,CACF,EAAuD,GAAI,CACzD,MAAM7F,EAAW,IAAI8F,EAAAA,eAAe,IAAK,GAAI,EAAE,EACzCC,EAAS,IAAItC,EAAA,KACjBzD,EACA,IAAIgG,oBAAkB,CACpB,MAAAJ,EACA,KAAMK,EAAA,SACN,YAAa,GACb,QAASJ,GAAW,EACrB,CAAA,CACH,EAEA,OAAAE,EAAO,YAAc,EAEdA,CACT,CCnBgB,SAAAG,GACdC,EACA/D,EACAwD,EACAQ,EACAC,EACAC,EACAC,EACAC,EAAkB,GAClBC,EAAkB,GAClB,CACM,MAAAC,EAAS,SAAS,cAAc,QAAQ,EAC9CtE,EAAaA,GAAc,GAE3B,MAAMlE,EAAS,IAEfwI,EAAO,MAAQtE,EAAa,EAAIA,GAAclE,EAAS,GAChDwI,EAAA,OAAStE,EAAaA,GAAclE,EAAS,GAEpD,MAAMyI,EAASvE,EAAa,EACtBwE,EAAUxE,EAAa,EAAIA,EAAalE,EACxC2I,EAAWD,EAAU,EAErBE,EAAUJ,EAAO,WAAW,IAAI,EAatC,GAXAK,EAAWD,EAASH,EAAQC,EAASA,EAAShB,EAAOY,EAAQC,CAAM,EACnEM,EACED,EACAH,EACAE,EACAD,EACAN,GAAS,OACTE,EACAC,CACF,EAEIL,GAAQ,KAAM,CACV,MAAAY,EAASb,EAAK,QAAU,aACxBc,EAASd,EAAK,QAAU,IAExBe,EAAOC,GAAWL,EAASV,EAAMY,EAAQC,EAAQ7E,CAAU,EAEjE0E,EAAQ,UAAY,SACpBA,EAAQ,aAAe,SACvBA,EAAQ,UAAYT,GAAa,OACjCS,EAAQ,SAASV,EAAMQ,EAASA,EAAUM,CAAI,EACtCJ,EAAA,UAAYP,GAAaF,GAAa,OAC9CS,EAAQ,SAASV,EAAMS,EAAUD,EAAUM,CAAI,CAAA,CAG3C,MAAAE,EAAU,IAAIC,EAAA,cAAcX,CAAM,EACxC,OAAAU,EAAQ,WAAaE,EAAA,eACbF,EAAA,MAAQA,EAAQ,MAAQG,EAAA,eAChCH,EAAQ,OAAO,EAAI,GAEZ,IAAII,EAAAA,eAAe,CACxB,IAAKJ,EACL,WAAY,GACZ,YAAa,EAAA,CACd,CACH,CAEA,SAASL,EACPD,EACAH,EACAhI,EACAD,EACAkH,EACAY,EACAC,EAAkB,GAClB,CACA,MAAMgB,EAAa/I,EAAI,GACdiI,EAAAF,EAASE,EAASc,EAAad,EAEpCF,MAAgB,YAAc,IAE9BD,IACFM,EAAQ,UAAU,EAClBA,EAAQ,IAAInI,EAAGD,EAAGiI,EAAQ,EAAG,EAAI,KAAK,EAAE,EACxCG,EAAQ,UAAU,EAClBA,EAAQ,UAAYlB,EACpBkB,EAAQ,KAAK,GAGXL,IACFK,EAAQ,YAAc,EACtBA,EAAQ,YAAclB,EACtBkB,EAAQ,UAAYW,EACpBX,EAAQ,OAAO,EAEnB,CAEA,SAASK,GACPO,EACAtB,EACAD,EACAc,EACAhJ,EACA,CACM,MAAA0J,EAAS,KAAK,KAAK,KAAK,IAAI1J,EAAO,GAAK,CAAC,EAAI,CAAC,EACpD,IAAI2J,EAAWD,EACXE,EAAY,EACZC,EAAa,EAEd,EAAA,CACDJ,EAAI,KAAO,GAAGT,CAAM,IAAIW,CAAQ,MAAMzB,CAAI,GACpC,MAAA4B,EAAUL,EAAI,YAAYtB,CAAI,EACpCyB,EAAYE,EAAQ,MACpBD,EAAaC,EAAQ,uBACrBH,GAAA,OACOC,EAAYF,GAAUC,EAAW,GAE1C,MAAMI,EAAc,KAAK,IAAIL,EAASE,EAAWF,EAASG,CAAU,EAE9DG,EAAgB,KAAK,MAAML,EAAWI,CAAW,EAEvD,OAAAN,EAAI,KAAO,GAAGT,CAAM,IAAIgB,CAAa,MAAM9B,CAAI,GAExCwB,EAASG,CAClB,CC1HO,SAASI,GAAoBnD,EAAuB,CACnD,MAAAC,EAAe,IAAIC,QACnB,CAAE,KAAAkB,EAAM,WAAYgC,CAAqB,EAAApD,EAE/C,OAAOH,EAAW,IAAI,CAACM,EAAK5E,IAAM,CAChC,KAAM,CAAE,KAAA8F,EAAM,OAAAtG,EAAQ,OAAA0G,EAAQ,OAAAC,CAAO,EAAI1B,EAAQG,CAAG,EAC9CkD,EAAa9H,EAAI,EACjB6E,EAAQiD,EAAalD,EAAMA,EAAI,CAAC,EAEhC,CAAE,KAAMmB,EAAW,KAAAhB,EAAM,MAAAiB,EAAO,UAAAC,GAAczG,EAC9C8F,EAAQ,MAAM,QAAQP,CAAI,EAAIA,EAAK,CAAC,EAAIA,EACxCgD,EAAa5B,GAAUL,EAEvBkC,EAAS,IAAIC,EAAA,OACjBrC,GACEC,EACAgC,EACAnD,EAAa,IAAIY,CAAK,EAAE,SAAS,EACjCQ,EACAC,GAAa,KAAOrB,EAAa,IAAIqB,CAAS,EAAE,WAAa,KAC7DC,GAAS,KAAOtB,EAAa,IAAIsB,CAAK,EAAE,WAAa,KACrDC,GAAa,KAAOvB,EAAa,IAAIuB,CAAS,EAAE,WAAa,KAC7DC,GAAU,GACVC,CAAA,CAEJ,EAEA,OAAA6B,EAAO,SAAS,KAAOpD,EACvBoD,EAAO,SAAS,WAAaD,EAC7BC,EAAO,MAAM,UAAUD,GAAcD,EAAa,GAAM,EAAG,EAC3DE,EAAO,SAASnD,CAAI,EAAIiD,EAAa,IAAM,KAC3CE,EAAO,YAAc,IAEdA,CAAA,CACR,CACH,CCtCA,MAAME,GAIA,CACJ,CAAC,IAAK,EAAG,CAAC,EACV,CAAC,IAAK,EAAG,CAAC,EACV,CAAC,IAAK,EAAG,CAAC,CACZ,EACMC,EAAiB,EACjBC,EAAmB,GAEnB7F,MAA0B9D,EAAAA,QAChB,SAAA4J,GAAqBC,EAAmB1G,EAAsB,CAC5EW,EAAM,IAAI,EAAG,EAAG,CAAC,EAAE,gBAAgBX,EAAO,UAAU,EAEpDsG,GAAQ,QAAQ,CAAC,CAACrD,EAAM0D,EAAeC,CAAa,IAAM,CAClD,MAAA9H,EAAQ6B,EAAMsC,CAAI,EAExByD,EAAQC,CAAa,EAAE,SAAS,QAC9B7H,GAAS,EAAIyH,EAAiBC,EAChCE,EAAQE,CAAa,EAAE,SAAS,QAC9B9H,GAAS,EAAI0H,EAAmBD,CAAA,CACnC,CACH,CCxBa,MAAAM,GAAU,CACrBC,EACAC,EACAjF,EAAoB,KAEpB,KAAK,IAAIgF,EAAE,QAAUC,EAAY,CAAC,EAAIjF,GACtC,KAAK,IAAIgF,EAAE,QAAUC,EAAY,CAAC,EAAIjF,ECNjC,SAASkF,EAAaN,EAAmB,CAC9C,QAAStI,EAAI,EAAGqC,EAAIiG,EAAQ,OAAQtI,EAAIqC,EAAGrC,IACjCsI,EAAAtI,CAAC,EAAE,MAAM,UACfA,EAAI,GAAKsI,EAAQtI,CAAC,EAAE,SAAS,WAAa,GAAM,EAClD,EACAsI,EAAQtI,CAAC,EAAE,SAAS,IAAK,OAAO,EAAI,CAExC,CCPA,MAAM6I,MAA+BC,EAAAA,UAC/BC,MAA2B5I,EAAAA,QAE1B,SAAS6I,GACdC,EACAC,EACAC,EACAC,EACA,CACAL,EAAO,GAAME,EAAM,QAAUC,EAAQ,MAAQA,EAAQ,MAAS,EAAI,EAC3DH,EAAA,EAAI,GAAGE,EAAM,QAAUC,EAAQ,KAAOA,EAAQ,QAAU,EAAI,EAExDL,EAAA,cAAcE,EAAQI,CAAW,EAEtC,MAAAnH,EAAa6G,EAAW,iBAAiBO,CAAmB,EAE9D,OAACpH,EAAW,OAEKA,EAAW,CAAC,EACb,OAHW,IAIjC,CCtBO,MAAMqH,GAAQ,CAACC,EAAaC,EAAaC,IAC9C,KAAK,IAAI,KAAK,IAAIF,EAAKC,CAAG,EAAGC,CAAG,ECErBC,GAAiB,CAC5BhE,EACA,CAAE,MAAAH,EAAO,QAAAC,EAAS,WAAAmE,EAAY,aAAAC,GAAyC,CAAA,EACvE3D,EAAiB,KACd,CACH,MAAM5C,EAAWqC,EAAO,SAExBrC,EAAS,MAAM,IAAK4C,GAAS0D,GAAepE,GAAS,QAAQ,EAC7DlC,EAAS,QAAU4C,EAAQ2D,GAAgB,GAAMpE,GAAW,CAC9D,ECyCMqE,MAA4BzI,EAAAA,QAC5B0I,OAA2BC,EAAAA,MAa1B,MAAMC,WAAsBC,EAAAA,QAAgC,CA8GjE,YACEpI,EACAqI,EACAxF,EACA,CACM,MAAA,EAjHRyF,EAAA,eAAmB,IAGnBA,EAAA,eAGAA,EAAA,cAAS,IAAIzL,EAAAA,SAGbyL,EAAA,gBAAoB,IAGpBA,EAAA,aAAgB,GAQhBA,EAAA,iBAAY,IAEJA,EAAA,gBACAA,EAAA,sBACAA,EAAA,sBACAA,EAAA,iBAAqB,IAAIpJ,EAAAA,SACzBoJ,EAAA,yBAA6B,IAAIpJ,EAAAA,SACjCoJ,EAAA,wBAA4B,IAAIpJ,EAAAA,SAChCoJ,EAAA,kBACAA,EAAA,oBAAe,IAAIC,qBAAmB,KAAM,IAAK,IAAK,KAAM,EAAG,CAAC,GAChED,EAAA,mBACAA,EAAA,oBACAA,EAAA,iBACAA,EAAA,iBAAqB,IACrBA,EAAA,iBAAoB,GACpBA,EAAA,cAAgB,IAAIE,EAAAA,OACpBF,EAAA,uBAAkB,IAAIzL,EAAAA,SACtByL,EAAA,yBAAoB,IAAIG,EAAAA,YACxBH,EAAA,wBAAmB,IAAIG,EAAAA,YACvBH,EAAA,sBAAiB,IAAIG,EAAAA,YACrBH,EAAA,mBAAc,IAAI/J,EAAAA,SAClB+J,EAAA,mBAAc,IAAI/J,EAAAA,SAClB+J,EAAA,kBACAA,EAAA,2BAwEN,KAAK,UAAYD,EACjB,KAAK,OAASrI,EAEd,KAAK,aAAa,SAAS,IAAI,EAAG,EAAG,CAAC,EAEtC6C,EAAU,CAAE,GAAGJ,GAAuB,GAAII,GAAW,CAAA,CAAI,EAEnD,KAAA,CACJ,UAAA6F,EACA,UAAA5M,EACA,KAAAC,EACA,SAAA4M,EACA,MAAAC,EACA,OAAA5M,EACA,OAAA6H,EACA,GAAA5H,EACA,UAAAC,CAAA,EACE2G,EAEJ,KAAK,SAAW8F,EAChB,KAAK,MAAQC,EAEP,MAAAC,EAAYjG,GAAaC,CAAO,EAClCgG,GAAgB,KAAA,IAAIA,CAAS,EAE5B,KAAA,cAAgB7C,GAAoBnD,CAAO,EAC3C,KAAA,IAAI,GAAG,KAAK,aAAa,EAE1BgB,EAAO,UACJ,KAAA,QAAUJ,GAAoBI,CAAM,EACzC,KAAK,cAAgBA,EAChB,KAAA,IAAI,KAAK,OAAO,GAGvB,KAAK,WAAa6E,EAAYpF,GAAcoF,CAAS,EAAI,SAAS,KAClE,KAAK,YAAc7M,EAAiBC,EAAWC,EAAMC,EAAQC,EAAIC,CAAS,EACrE,KAAA,WAAW,YAAY,KAAK,WAAW,EAE5C,KAAK,gBAAgB,EACrB,KAAK,OAAO,CAAA,CAUd,QAAS,CACH,KAAK,WAAW,KAAK,SAAS,EAE5B,KAAA,CAAE,UAAA4M,EAAW,UAAAC,CAAA,EAAc,KAG3BC,EAAcF,EAAU,eAAe,EACvCG,EAAYH,EAAU,UAG5B,OAAAA,EAAU,UAAY,GACtBA,EAAU,YAAYC,CAAS,EAC3BC,GAAuBF,EAAA,WAAWC,CAAS,EAErCD,EAAA,MAAM,GAAO,GAAM,EAAK,EACxBA,EAAA,OAAO,KAAM,KAAK,YAAY,EAG9BA,EAAA,YAAY,KAAK,iBAAiB,EACxCE,GAAaF,EAAU,WAAW,KAAK,gBAAgB,EAE3DA,EAAU,UAAYG,EAEf,IAAA,CAST,WAAY,CACL,KAAA,SAAW,KAAK,YAAY,sBAAsB,EAEvD,MAAMZ,EAAW,KAAK,UAChBf,EAAU,KAAK,SACf4B,EAAgBb,EAAS,WAAW,sBAAsB,EAEhE,YAAK,UAAU,IACbf,EAAQ,KAAO4B,EAAc,KAC7Bb,EAAS,WAAW,cACjBf,EAAQ,IAAM4B,EAAc,IAAM5B,EAAQ,QAC7CA,EAAQ,MACRA,EAAQ,MACV,EAESe,EAAA,YAAY,KAAK,iBAAiB,EACvCA,EAAS,eAAe,GAAYA,EAAA,WAAW,KAAK,gBAAgB,EAEjE,IAAA,CAQT,cAAe,CACb,YAAK,mBAAmB,EACjB,IAAA,CAUT,OAAOc,EAAoB,GAAM,CAC/B,OAAIA,GAAY,KAAK,WAAW,KAAK,UAAU,OAAO,EAC/C,KAAK,UAAU,EAAE,aAAa,CAAA,CASvC,eAAeA,EAAyB,CACtC,KAAK,eAAe,EAEpB,KAAK,OAASA,EAAS,OAEvB,KAAK,mBAAqB,CACxB,MAAO,IAAOA,EAAS,QAAU,GACjC,IAAK,IAAOA,EAAS,QAAU,GAC/B,OAAQ,IAAM,KAAK,OAAO,EAAK,CACjC,EAEA,KAAK,iBAAiB,QAAS,KAAK,mBAAmB,KAAK,EAC5D,KAAK,iBAAiB,MAAO,KAAK,mBAAmB,GAAG,EACxDA,EAAS,iBAAiB,SAAU,KAAK,mBAAmB,MAAM,EAElE,KAAK,UAAYA,CAAA,CAInB,gBAAiB,CACX,CAAC,KAAK,oBAAsB,CAAC,KAAK,YAEtC,KAAK,OAAS,IAAItM,EAAA,QAAA,EAAU,KAAK,KAAK,UAAU,MAAM,EAEtD,KAAK,oBAAoB,QAAS,KAAK,mBAAmB,KAAK,EAC/D,KAAK,oBAAoB,MAAO,KAAK,mBAAmB,GAAG,EAE3D,KAAK,UAAU,oBACb,SACA,KAAK,mBAAmB,MAC1B,EAEA,KAAK,mBAAqB,OAC1B,KAAK,UAAY,OAAA,CAInB,SAAU,CACR,KAAK,eAAe,EAEf,KAAA,SAAS,QAASuM,GAAU,aAC/B,MAAMrL,EAAOqL,GACbC,EAAAtL,EAAK,WAAL,MAAAsL,EAAe,WACVC,GAAAC,EAAAxL,EAAA,WAAA,YAAAwL,EAAU,MAAV,MAAAD,EAAe,WACpBE,EAAAzL,EAAK,WAAL,MAAAyL,EAAe,SAAQ,CACxB,EAED,KAAK,YAAY,OAAO,CAAA,CASlB,mBAAmBC,EAAsB,GAAM,CACjDA,IACF,KAAK,WAAW,KAAK,KAAK,OAAO,UAAU,EAAE,OAAO,EACpD,KAAK,kBAAkB,GAGJhD,GAAA,KAAK,cAAe,KAAK,MAAM,CAAA,CAQ9C,UAAW,CACjB,KAAM,CAAE,SAAAiD,EAAU,WAAAC,CAAW,EAAI,KAAK,OAIlC,GAFKD,EAAA,IAAI,EAAG,EAAG,CAAC,EAEhB,CAAC,KAAK,SAAU,CAEfA,EAAA,gBAAgB,KAAK,cAAc,EACnC,eAAe,KAAK,SAAS,EAC7B,IAAI,KAAK,MAAM,EAEPC,EAAA,KAAK,KAAK,iBAAiB,EAEtC,KAAK,mBAAmB,EAExB,KAAK,UAAY,GACjB,KAAK,cAAc,CAAE,KAAM,QAAA,CAAU,EACrC,KAAK,cAAc,CAAE,KAAM,KAAA,CAAO,EAClC,MAAA,CAKI,MAAAC,EAFQ,KAAK,OAAO,SAAS,EAEdpH,GAAkB,KAAK,MAE5C,KAAK,iBAAiB,cAAc,KAAK,eAAgBoH,CAAI,EAE1DF,EAAA,gBAAgB,KAAK,gBAAgB,EACrC,eAAe,KAAK,SAAS,EAC7B,IAAI,KAAK,MAAM,EAEPC,EAAA,cAAc,KAAK,kBAAmBC,CAAI,EAErD,KAAK,mBAAmB,EACxB,sBAAsB,IAAM,KAAK,cAAc,CAAE,KAAM,QAAA,CAAU,CAAC,EAE9D,KAAK,iBAAiB,QAAQ,KAAK,cAAc,IAAM,IACzD,KAAK,UAAY,GACjB,KAAK,cAAc,CAAE,KAAM,KAAA,CAAO,EACpC,CASM,gBAAgB3G,EAAmC,CACzD,MAAMjD,EAAS,KAAK,OACd6J,EAAa,KAAK,OAElB,CAACH,EAAUI,CAAW,EAAInH,GAAwBM,CAAI,EACvD,KAAA,gBAAgB,UAAUyG,CAAQ,EACvC,KAAK,kBAAkB,aAAazB,GAAO,UAAU6B,CAAW,CAAC,EAEjE,KAAK,gBAAgB,eAAe,KAAK,SAAS,EAAE,IAAID,CAAU,EAE1D7B,EAAA,YAAYhI,EAAO,QAAQ,EACnCgI,EAAQ,OAAOhI,EAAO,SAAU6J,EAAY,KAAK,EAAE,EAC9C,KAAA,iBAAiB,sBAAsB7B,CAAO,EAE3CA,EAAA,YAAY,KAAK,eAAe,EACxCA,EAAQ,OAAO,KAAK,gBAAiB6B,EAAY,KAAK,EAAE,EACnD,KAAA,eAAe,sBAAsB7B,CAAO,EAEjD,KAAK,UAAY,GACjB,KAAK,OAAO,MAAM,EAClB,KAAK,cAAc,CAAE,KAAM,OAAA,CAAS,CAAA,CAQ9B,iBAAkB,CACxB,KAAK,YAAY,cAAiB,GAAM,KAAK,eAAe,CAAC,EAC7D,KAAK,YAAY,cAAiB,GAAM,KAAK,eAAe,CAAC,EAC7D,KAAK,YAAY,eAAiB,IAAM,KAAK,gBAAgB,CAAA,CASvD,eAAe,EAAiB,CAClC,GAAA,CAAC,KAAK,QAAS,OAEb,MAAA+B,EAAQjD,GAAoB,CAC5B,GAAA,CAAC,KAAK,UAAW,CACnB,GAAID,GAAQC,EAAG,KAAK,WAAW,EAAG,OAElCE,EAAa,KAAK,aAAa,EAC/B,KAAK,UAAY,EAAA,CAGnB,KAAK,YACF,IAAIF,EAAE,QAASA,EAAE,OAAO,EACxB,IAAI,KAAK,WAAW,EACpB,eAAgB,EAAI,KAAK,SAAS,MAAS,KAAK,EAAE,EAErD,KAAK,SAAS,EAAIW,GAChBuC,EAAc,EAAI,KAAK,YAAY,EACnC,KAAK,GAAK,GAAK,KACf,KAAK,GAAK,EAAI,IAChB,EACA,KAAK,SAAS,EAAIA,EAAc,EAAI,KAAK,YAAY,EACrD,KAAK,kBAAkB,EAEvB,KAAK,iBAAiB,KAAK,KAAK,UAAU,EAAE,OAAO,EAEnD,KAAK,OAAO,SACT,IAAI,EAAG,EAAG,CAAC,EACX,gBAAgB,KAAK,gBAAgB,EACrC,eAAe,KAAK,SAAS,EAC7B,IAAI,KAAK,MAAM,EAElB,KAAK,OAAO,SAAS,kBAAkB,KAAK,gBAAgB,EAE5D,KAAK,mBAAmB,EAAK,EAE7B,KAAK,cAAc,CAAE,KAAM,QAAA,CAAU,CACvC,EACMC,EAAU,IAAM,CAIpB,GAHS,SAAA,oBAAoB,cAAeF,EAAM,EAAK,EAC9C,SAAA,oBAAoB,YAAaE,EAAS,EAAK,EAEpD,CAAC,KAAK,UAAkB,OAAA,KAAK,aAAa,CAAC,EAE/C,KAAK,UAAY,GACjB,KAAK,cAAc,CAAE,KAAM,KAAA,CAAO,CACpC,EAEA,GAAI,KAAK,UAAW,OAEpB,EAAE,eAAe,EAEjB,KAAK,YAAY,IAAI,EAAE,QAAS,EAAE,OAAO,EAEzC,MAAMD,EAAgB/B,GAAO,KAAK,KAAK,QAAQ,EAE/C,KAAK,UAAY,KAAK,OAAO,SAAS,WAAW,KAAK,MAAM,EAEnD,SAAA,iBAAiB,cAAe8B,EAAM,EAAK,EAC3C,SAAA,iBAAiB,YAAaE,EAAS,EAAK,EAErD,KAAK,cAAc,CAAE,KAAM,OAAA,CAAS,CAAA,CAS9B,eAAe,EAAiB,CAClC,CAAC,KAAK,SAAW,KAAK,YAEtB,KAAK,SAASpC,GAAe,KAAK,QAAS,KAAK,aAAa,EAEjE,KAAK,aAAa,CAAC,EAAA,CAQb,iBAAkB,CACpB,CAAC,KAAK,SAAW,KAAK,YAEtB,KAAK,SAASA,GAAe,KAAK,QAAS,KAAK,cAAe,EAAK,EAExEb,EAAa,KAAK,aAAa,EAC1B,KAAA,YAAY,MAAM,OAAS,GAAA,CAS1B,aAAa,EAAiB,CACpC,MAAMkD,EAAS9C,GACb,EACA,KAAK,SACL,KAAK,aACL,KAAK,aACP,EAEK8C,IAEA,KAAA,gBAAgBA,EAAO,SAAS,IAAI,EACzC,KAAK,cAAc,CAAE,KAAM,QAAA,CAAU,EAAA,CAS/B,aAAa,EAAiB,CACpC,MAAMA,EAAS9C,GACb,EACA,KAAK,SACL,KAAK,aACL,KAAK,aACP,EAEAJ,EAAa,KAAK,aAAa,EAE1BkD,GAGIA,EAAA,SAAS,IAAK,OAAO,EAAI,GACzBA,EAAA,MAAM,eAAe,GAAG,EAC1B,KAAA,YAAY,MAAM,OAAS,WAJ3B,KAAA,YAAY,MAAM,OAAS,EAKlC,CAEJ","x_google_ignoreList":[1,2,3,4,5]}