{"version":3,"file":"three-viewport-gizmo.umd.cjs","sources":["../lib/utils/gizmoDomElement.ts","../lib/utils/getDomElement.ts","../node_modules/three/src/math/MathUtils.js","../lib/utils/updateAxis.ts","../lib/utils/isClick.ts","../lib/utils/intersectedObjects.ts","../lib/utils/constants.ts","../lib/utils/updateBackground.ts","../lib/utils/deepClone.ts","../lib/utils/optionsFallback.ts","../lib/utils/axesMap.ts","../lib/utils/roundedRectangleGeometry.ts","../lib/utils/axesFaces.ts","../lib/utils/axesCorners.ts","../lib/utils/axesEdges.ts","../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","../lib/utils/gizmoBackground.ts","../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../node_modules/three/examples/jsm/lines/LineMaterial.js","../node_modules/three/examples/jsm/lines/LineSegments2.js","../node_modules/three/examples/jsm/lines/LineGeometry.js","../node_modules/three/examples/jsm/lines/Line2.js","../lib/utils/axesLines.ts","../lib/utils/axesObjects.ts","../lib/utils/axisHover.ts","../lib/ViewportGizmo.ts"],"sourcesContent":["import { GizmoOptionsFallback } from \"../types\";\n\nexport const setDomPlacement = (\n  domElement: HTMLElement,\n  placement: GizmoOptionsFallback[\"placement\"]\n) => {\n  const [y, x] = placement.split(\"-\");\n  Object.assign(domElement.style, {\n    left: x === \"left\" ? \"0\" : x === \"center\" ? `50%` : \"\",\n    right: x === \"right\" ? \"0\" : \"\",\n    top: y === \"top\" ? \"0\" : y === \"bottom\" ? \"\" : \"50%\",\n    bottom: y === \"bottom\" ? \"0\" : \"\",\n    transform: `${x === \"center\" ? \"translateX(-50%)\" : \"\"} ${\n      y === \"center\" ? \"translateY(-50%)\" : \"\"\n    }`,\n  });\n\n  return placement;\n};\n\nexport const gizmoDomElement = ({\n  placement,\n  size,\n  offset,\n  id,\n  className,\n}: GizmoOptionsFallback) => {\n  const div = document.createElement(\"div\");\n\n  const { top, left, right, bottom } = offset;\n  Object.assign(div.style, {\n    id,\n    position: \"absolute\",\n    zIndex: \"1000\",\n    height: `${size}px`,\n    width: `${size}px`,\n    margin: `${top}px ${right}px ${bottom}px ${left}px`,\n    borderRadius: \"100%\",\n  });\n\n  setDomPlacement(div, placement);\n\n  if (id) div.id = id;\n  if (className) div.className = className;\n\n  return div;\n};\n","export const getDomElement = (\n  domElement: string | HTMLElement\n): HTMLElement => {\n  const element =\n    typeof domElement === \"string\"\n      ? document.querySelector<HTMLElement>(domElement)\n      : domElement;\n\n  if (!element) throw Error(`Invalid DOM element`);\n\n  return element;\n};\n","const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport { Camera, Vector3 } from \"three\";\nimport { clamp } from \"three/src/math/MathUtils.js\";\n\nconst axisMap: [\n  axis: \"x\" | \"y\" | \"z\",\n  positiveIndex: number,\n  negativeIndex: number\n][] = [\n  [\"x\", 0, 3],\n  [\"y\", 1, 4],\n  [\"z\", 2, 5],\n];\n\nconst point = /*@__PURE__*/ new Vector3();\nexport function updateAxis(\n  { isSphere }: GizmoOptionsFallback,\n  axes: GizmoAxisObject[],\n  camera: Camera\n): void {\n  if (!isSphere) return;\n\n  point.set(0, 0, 1).applyQuaternion(camera.quaternion);\n\n  axisMap.forEach(([axis, positiveIndex, negativeIndex]) => {\n    const value = point[axis];\n\n    let object = axes[positiveIndex];\n    let opacity = object.userData.opacity;\n\n    object.material.opacity = clamp(value >= 0 ? opacity : opacity / 2, 0, 1);\n\n    object = axes[negativeIndex];\n    opacity = object.userData.opacity;\n\n    object.material.opacity = clamp(value >= 0 ? opacity / 2 : opacity, 0, 1);\n  });\n}\n","import { Vector2 } from \"three\";\n\nexport const isClick = (\n  e: PointerEvent,\n  startCoords: Vector2,\n  threshold: number = 10\n) =>\n  Math.abs(e.clientX - startCoords.x) < threshold &&\n  Math.abs(e.clientY - startCoords.y) < threshold;\n","import { GizmoAxisObject } from \"@lib/types\";\nimport {\n  Vector2,\n  Raycaster,\n  type Object3D,\n  type Camera,\n  Intersection,\n} from \"three\";\n\nconst _raycaster = /*@__PURE__*/ new Raycaster();\nconst _mouse = /*@__PURE__*/ new Vector2();\n\nexport const intersectedObjects = (\n  event: PointerEvent,\n  domRect: DOMRect,\n  camera: Camera,\n  intersections: Object3D[]\n): Intersection<GizmoAxisObject> | null => {\n  _mouse.set(\n    ((event.clientX - domRect.left) / domRect.width) * 2 - 1,\n    -((event.clientY - domRect.top) / domRect.height) * 2 + 1\n  );\n\n  _raycaster.setFromCamera(_mouse, camera);\n\n  const intersects = _raycaster.intersectObjects<GizmoAxisObject>(\n    intersections,\n    false\n  );\n\n  const intersection = intersects.length ? intersects[0] : null;\n\n  return !intersection || !intersection.object.visible ? null : intersection;\n};\n","export const EPSILON = 1e-6;\nexport const GIZMO_TURN_RATE = 2 * Math.PI;\nexport const AXES = [\"x\", \"y\", \"z\"] as const;\nexport const GIZMO_AXES = [...AXES, \"nx\", \"ny\", \"nz\"] as const;\nexport const GIZMO_FACES = [\n  \"right\",\n  \"top\",\n  \"front\",\n  \"left\",\n  \"bottom\",\n  \"back\",\n] as const;\nexport const GIZMO_SPHERE_AXES_DISTANCE = 1.3;\n","import { BufferGeometry, Mesh, MeshBasicMaterial } from \"three\";\n\nexport const updateBackground = (\n  background: Mesh<BufferGeometry, MeshBasicMaterial>,\n  hovered: boolean = true\n) => {\n  const { material, userData } = background;\n  const { color, opacity } = hovered ? userData.hover : userData;\n\n  material.color.set(color);\n  material.opacity = opacity;\n};\n","export const deepClone = <T>(obj: T) => JSON.parse(JSON.stringify(obj));\n","import {\n  GizmoAxisOptions,\n  GizmoOptions,\n  GizmoOptionsFallback,\n} from \"@lib/types\";\nimport { AXES, GIZMO_AXES, GIZMO_FACES } from \"./constants\";\n\nimport { deepClone } from \"./deepClone\";\n\nexport const optionsFallback = (\n  options: GizmoOptions\n): GizmoOptionsFallback => {\n  const type = options.type || \"sphere\";\n  const isSphere = type === \"sphere\";\n  const resolution = options.resolution || isSphere ? 64 : 128;\n\n  const { container } = options;\n  options.container = undefined;\n  options = JSON.parse(JSON.stringify(options));\n  options.container = container;\n\n  // Convert face axis to regular axis\n  GIZMO_FACES.forEach((face, index) => {\n    if (options[face]) options[GIZMO_AXES[index]] = options[face];\n  });\n\n  // Positive Axes fallback options\n  const axesFallback: GizmoAxisOptions = {\n    enabled: true,\n    color: 0xffffff,\n    opacity: 1,\n    scale: isSphere ? 0.7 : 0.7,\n    labelColor: 0x222222,\n    line: false,\n    border: {\n      size: 0,\n      color: 0xdddddd,\n    },\n    hover: {\n      color: isSphere ? 0xffffff : 0x93d3eb,\n      labelColor: 0x222222,\n      opacity: 1,\n      scale: isSphere ? 0.7 : 0.7,\n      border: {\n        size: 0,\n        color: 0xdddddd,\n      },\n    },\n  };\n\n  // Negative Axes fallback options\n  const negativeAxesFallback = {\n    line: false,\n    scale: isSphere ? 0.45 : 0.7,\n    hover: {\n      scale: isSphere ? 0.5 : 0.7,\n    },\n  };\n\n  const optionsFallback: GizmoOptions = {\n    type,\n    container: document.body,\n    size: 128,\n    placement: \"top-right\",\n    resolution,\n    lineWidth: 20,\n    radius: isSphere ? 1 : 0.2,\n    smoothness: 18,\n    animated: true,\n    speed: 1,\n    background: {\n      enabled: true,\n      color: isSphere ? 0xffffff : 0xe0e6ec,\n      opacity: isSphere ? 0 : 1,\n      hover: {\n        color: isSphere ? 0xffffff : 0xe0e6ec,\n        opacity: isSphere ? 0.2 : 1,\n      },\n    },\n    font: {\n      family: \"sans-serif\",\n      weight: 900,\n    },\n    offset: {\n      top: 10,\n      left: 10,\n      bottom: 10,\n      right: 10,\n    },\n    corners: {\n      enabled: !isSphere,\n      color: isSphere ? 0xf2d962 : 0xffffff,\n      opacity: 1,\n      scale: isSphere ? 0.15 : 0.2,\n      radius: 1,\n      smoothness: 18,\n      hover: {\n        color: isSphere ? 0xffffff : 0x93d3eb,\n        opacity: 1,\n        scale: isSphere ? 0.2 : 0.225,\n      },\n    },\n    edges: {\n      enabled: !isSphere,\n      color: isSphere ? 0xf2d962 : 0xffffff,\n      opacity: isSphere ? 1 : 0,\n      radius: isSphere ? 1 : 0.125,\n      smoothness: 18,\n      scale: isSphere ? 0.15 : 1,\n      hover: {\n        color: isSphere ? 0xffffff : 0x93d3eb,\n        opacity: 1,\n        scale: isSphere ? 0.2 : 1,\n      },\n    },\n    x: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? {\n            label: \"X\",\n            color: 0xff3653,\n            line: true,\n          }\n        : {\n            label: \"Right\",\n          }),\n    },\n    y: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? {\n            label: \"Y\",\n            color: 0x8adb00,\n            line: true,\n          }\n        : {\n            label: \"Top\",\n          }),\n    },\n    z: {\n      ...deepClone(axesFallback),\n      ...(isSphere\n        ? {\n            label: \"Z\",\n            color: 0x2c8fff,\n            line: true,\n          }\n        : {\n            label: \"Front\",\n          }),\n    },\n    nx: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere ? \"\" : \"Left\",\n    },\n    ny: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere ? \"\" : \"Bottom\",\n    },\n    nz: {\n      ...deepClone(negativeAxesFallback),\n      label: isSphere ? \"\" : \"Back\",\n    },\n  };\n\n  assignNestedDefaults(options, optionsFallback);\n\n  // Negative axis fallback to positive axis\n  AXES.forEach((axis) =>\n    assignNestedDefaults(\n      (options as any)[`n${axis}`],\n      deepClone((options as any)[axis])\n    )\n  );\n\n  return { ...options, isSphere } as GizmoOptionsFallback;\n};\n\nfunction assignNestedDefaults<T>(target: T, ...defaultObjects: T[]) {\n  if (\n    target instanceof HTMLElement ||\n    typeof target !== \"object\" ||\n    target === null\n  )\n    return target;\n\n  for (const defaults of defaultObjects) {\n    for (const key in defaults) {\n      if (key === \"container\") continue;\n\n      if (key in (defaults as any)) {\n        if (target[key] === undefined) {\n          (target as any)[key] = defaults[key];\n        } else if (\n          typeof defaults[key] === \"object\" &&\n          !Array.isArray(defaults[key])\n        ) {\n          (target as any)[key] = assignNestedDefaults(\n            (target as any)[key] || {},\n            defaults[key]\n          );\n        }\n      }\n    }\n  }\n\n  return target as T;\n}\n","import {\n  CanvasTexture,\n  Color,\n  ColorRepresentation,\n  RepeatWrapping,\n  SRGBColorSpace,\n  Texture,\n} from \"three\";\nimport { GizmoAxisOptions, GizmoOptionsFallback } from \"@lib/types\";\nimport { GIZMO_AXES } from \"./constants\";\n\nexport const axesMap = (options: GizmoOptionsFallback, offset: number = 2) => {\n  const colorManager = new Color();\n  const doubleOffset = offset * 2;\n  const { isSphere, resolution, radius, font, corners, edges } = options;\n\n  const axes: (Required<GizmoAxisOptions> & { radius: number })[] =\n    GIZMO_AXES.map((axis) => ({ ...options[axis], radius }));\n\n  if (isSphere && corners.enabled) axes.push(corners as any);\n  if (isSphere && edges.enabled) axes.push(edges as any);\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n  canvas.width = resolution * 2 + doubleOffset * 2;\n  canvas.height = resolution * axes.length + doubleOffset * axes.length;\n\n  const [fontStyle, fontYFix] = getFontStyle(axes, resolution, font);\n\n  axes.forEach(\n    (\n      {\n        radius,\n        label,\n        color,\n        labelColor,\n        border,\n        hover: {\n          color: hoverColor,\n          labelColor: hoverLabel,\n          border: hoverBorder,\n        },\n      },\n      index\n    ) => {\n      const y = resolution * index + index * doubleOffset + offset;\n      drawAxis(\n        offset,\n        y,\n        offset,\n        resolution,\n        radius,\n        label,\n        border,\n        color,\n        labelColor\n      );\n      drawAxis(\n        resolution + offset * 3,\n        y,\n        offset,\n        resolution,\n        radius,\n        label,\n        hoverBorder ?? border,\n        hoverColor ?? color,\n        hoverLabel ?? labelColor\n      );\n    }\n  );\n\n  /* \n  // Debug\n  document.body.appendChild(canvas);\n  Object.assign(canvas.style, {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    zIndex: 100000,\n  }); */\n\n  const colsCount = axes.length;\n  const offsetX = offset / (resolution * 2);\n  const offsetY = offset / (resolution * 6);\n  const cellHeight = 1 / colsCount;\n\n  const map = new CanvasTexture(canvas);\n  map.repeat.set(0.5 - 2 * offsetX, cellHeight - 2 * offsetY);\n  map.offset.set(offsetX, 1 - offsetY);\n\n  Object.assign(map, {\n    colorSpace: SRGBColorSpace,\n    wrapS: RepeatWrapping,\n    wrapT: RepeatWrapping,\n    userData: {\n      offsetX,\n      offsetY,\n      cellHeight,\n    },\n  });\n\n  return map;\n\n  function drawAxis(\n    x: number,\n    y: number,\n    offset: number,\n    size: number,\n    radius: number,\n    label: string,\n    border: GizmoAxisOptions[\"border\"],\n    color: ColorRepresentation,\n    labelColor: ColorRepresentation\n  ) {\n    radius = radius * (size / 2);\n\n    if (color != null && color !== \"\") {\n      drawRoundRectPath();\n      ctx.fillStyle = colorManager.set(color!).getStyle();\n      ctx.fill();\n    }\n\n    if (border && border.size) {\n      const halfBorderWidth = (border.size * size) / 2;\n      x += halfBorderWidth;\n      y += halfBorderWidth;\n      size -= border.size * size;\n      radius = Math.max(0, radius - halfBorderWidth);\n\n      drawRoundRectPath();\n      ctx.strokeStyle = colorManager.set(border.color).getStyle();\n      ctx.lineWidth = border.size * size;\n      ctx.stroke();\n    }\n\n    if (label)\n      drawText(\n        ctx,\n        x + size / 2,\n        y + (size + offset) / 2,\n        label,\n        colorManager.set(labelColor!).getStyle()\n      );\n\n    function drawRoundRectPath() {\n      ctx.beginPath();\n      ctx.moveTo(x + radius, y);\n      ctx.lineTo(x + size - radius, y);\n      ctx.arcTo(x + size, y, x + size, y + radius, radius);\n      ctx.lineTo(x + size, y + size - radius);\n      ctx.arcTo(x + size, y + size, x + size - radius, y + size, radius);\n      ctx.lineTo(x + radius, y + size);\n      ctx.arcTo(x, y + size, x, y + size - radius, radius);\n      ctx.lineTo(x, y + radius);\n      ctx.arcTo(x, y, x + radius, y, radius);\n      ctx.closePath();\n    }\n  }\n\n  function getFontStyle(\n    axis: GizmoAxisOptions[],\n    resolution: number,\n    font: GizmoOptionsFallback[\"font\"]\n  ) {\n    const longestLabel = [...axis]\n      .sort((a, b) => (a.label?.length || 0) - (b.label?.length || 0))\n      .pop()!;\n    const text = longestLabel.label!;\n\n    const { family, weight } = font;\n\n    const square = isSphere\n      ? Math.sqrt(Math.pow(resolution * 0.7, 2) / 2)\n      : resolution;\n    let fontSize = square;\n    let textWidth = 0;\n    let textHeight = 0;\n\n    do {\n      ctx.font = `${weight} ${fontSize}px ${family}`;\n      const measure = ctx.measureText(text);\n      textWidth = measure.width;\n      textHeight = measure.fontBoundingBoxDescent;\n      fontSize--;\n    } while (textWidth > square && fontSize > 0);\n\n    const yFix = square / textHeight;\n    const scaleFactor = Math.min(square / textWidth, yFix);\n    const finalFontSize = Math.floor(fontSize * scaleFactor);\n\n    return [`${weight} ${finalFontSize}px ${family}`, yFix] as const;\n  }\n\n  function drawText(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    text: string,\n    color: string\n  ) {\n    ctx.font = fontStyle;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = color;\n    ctx.fillText(text, x, y + (isSphere ? fontYFix : 0));\n  }\n};\n\nexport const setMapHoverOffset = (map: Texture, hover: boolean) =>\n  (map.offset.x = (hover ? 0.5 : 0) + map.userData.offsetX);\n\nexport const setMapColumnOffset = (map: Texture, col: number) => {\n  const {\n    offset,\n    userData: { offsetY, cellHeight },\n  } = map;\n  offset.y = 1 - (col + 1) * cellHeight + offsetY;\n};\n","import { BufferGeometry, BufferAttribute } from \"three\";\n\n/**\n * Generate a Rounded Rectangle geometry\n *\n * @param radius      - The edges radius\n * @param smoothness  - The edges smoothness\n *\n * @ThanksTo `@hofk` for the {@link https://discourse.threejs.org/t/roundedrectangle-squircle/28645 RoundedRectangle + Squircle } Geometry\n *\n * @returns A round rectangle geometry\n */\nexport function roundedRectangleGeometry(\n  radius: number,\n  smoothness: number,\n  width: number = 2,\n  height: number = 2\n) {\n  // helper const's\n  const wi = width / 2 - radius; // inner width\n  const hi = height / 2 - radius; // inner height\n  const ul = radius / width; // u left\n  const ur = (width - radius) / width; // u right\n  const vl = radius / height; // v low\n  const vh = (height - radius) / height; // v high\n\n  const positions = [wi, hi, 0, -wi, hi, 0, -wi, -hi, 0, wi, -hi, 0];\n  const uvs = [ur, vh, ul, vh, ul, vl, ur, vl];\n  const n = [\n    3 * (smoothness + 1) + 3,\n    3 * (smoothness + 1) + 4,\n    smoothness + 4,\n    smoothness + 5,\n    2 * (smoothness + 1) + 4,\n    2,\n    1,\n    2 * (smoothness + 1) + 3,\n    3,\n    4 * (smoothness + 1) + 3,\n    4,\n    0,\n  ];\n  const indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(\n    (i) => n[i]\n  );\n\n  let phi, cos, sin, xc, yc, uc, vc, idx;\n\n  for (let i = 0; i < 4; i++) {\n    xc = i < 1 || i > 2 ? wi : -wi;\n    yc = i < 2 ? hi : -hi;\n\n    uc = i < 1 || i > 2 ? ur : ul;\n    vc = i < 2 ? vh : vl;\n\n    for (let j = 0; j <= smoothness; j++) {\n      phi = (Math.PI / 2) * (i + j / smoothness);\n      cos = Math.cos(phi);\n      sin = Math.sin(phi);\n\n      positions.push(xc + radius * cos, yc + radius * sin, 0);\n\n      uvs.push(uc + ul * cos, vc + vl * sin);\n\n      if (j < smoothness) {\n        idx = (smoothness + 1) * i + j + 4;\n        indices.push(i, idx, idx + 1);\n      }\n    }\n  }\n\n  return new BufferGeometry()\n    .setIndex(new BufferAttribute(new Uint32Array(indices), 1))\n    .setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(positions), 3)\n    )\n    .setAttribute(\"uv\", new BufferAttribute(new Float32Array(uvs), 2));\n}\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n} from \"three\";\nimport { GIZMO_AXES, GIZMO_SPHERE_AXES_DISTANCE } from \"./constants\";\n\nimport { setMapColumnOffset } from \"./axesMap\";\n\nexport const axesFaces = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture\n): GizmoAxisObject[] => {\n  const target = new Vector3();\n  const { isSphere, radius, smoothness } = options;\n  const geometry = roundedRectangleGeometry(radius, smoothness);\n\n  return GIZMO_AXES.map((_, i) => {\n    const isPositive = i < 3;\n\n    const axis = GIZMO_AXES[i];\n    const map = i ? texture.clone() : texture;\n\n    setMapColumnOffset(map, i);\n\n    const { enabled, scale, opacity, hover } = options[axis];\n\n    const materialConfig: MeshBasicMaterialParameters = {\n      map,\n      opacity,\n      transparent: true,\n    };\n\n    const face = isSphere\n      ? new Sprite(new SpriteMaterial(materialConfig))\n      : new Mesh(geometry, new MeshBasicMaterial(materialConfig));\n\n    const direction = (isPositive ? axis : axis[1]) as \"x\" | \"y\" | \"z\";\n    face.position[direction] =\n      (isPositive ? 1 : -1) * (isSphere ? GIZMO_SPHERE_AXES_DISTANCE : 1);\n\n    if (!isSphere) face.lookAt(target.copy(face.position).multiplyScalar(1.7));\n\n    face.scale.setScalar(scale);\n    face.renderOrder = 1;\n    face.visible = enabled;\n    face.userData = {\n      scale,\n      opacity,\n      hover,\n    };\n\n    return face;\n  });\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n} from \"three\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\nimport { setMapColumnOffset } from \"./axesMap\";\n\nexport const axesCorners = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture\n) => {\n  const { isSphere, corners } = options;\n\n  if (!corners.enabled) return [];\n\n  const { color, opacity, scale, radius, smoothness, hover } = corners;\n\n  const geometry = isSphere\n    ? null\n    : roundedRectangleGeometry(radius, smoothness);\n\n  const materialConfig: MeshBasicMaterialParameters = {\n    transparent: true,\n    opacity,\n  };\n\n  const positions = [\n    1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, -1, -1, -1,\n    -1, -1,\n  ].map((val) => val * 0.85);\n\n  const target = new Vector3();\n  return Array(positions.length / 3)\n    .fill(0)\n    .map<GizmoAxisObject>((_, i) => {\n      if (isSphere) {\n        const map = texture.clone();\n        setMapColumnOffset(map, 6);\n        materialConfig.map = map;\n      } else {\n        materialConfig.color = color;\n      }\n\n      const corner = isSphere\n        ? new Sprite(new SpriteMaterial(materialConfig))\n        : new Mesh(geometry!, new MeshBasicMaterial(materialConfig));\n\n      const i3 = i * 3;\n      corner.position.set(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n\n      if (isSphere) corner.position.normalize().multiplyScalar(1.7);\n\n      corner.scale.setScalar(scale);\n      corner.lookAt(target.copy(corner.position).multiplyScalar(2));\n      corner.renderOrder = 1;\n\n      corner.userData = {\n        color,\n        opacity,\n        scale,\n        hover,\n      };\n\n      return corner;\n    });\n};\n","import { GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  CanvasTexture,\n  Mesh,\n  MeshBasicMaterial,\n  MeshBasicMaterialParameters,\n  Sprite,\n  SpriteMaterial,\n  Vector3,\n} from \"three\";\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\nimport { setMapColumnOffset } from \"./axesMap\";\n\nexport const axesEdges = (\n  options: GizmoOptionsFallback,\n  texture: CanvasTexture,\n  textureColumn: number\n) => {\n  const { isSphere, edges } = options;\n\n  if (!edges.enabled) return [];\n\n  const { color, opacity, scale, hover, radius, smoothness } = edges;\n\n  const geometry = isSphere\n    ? null\n    : roundedRectangleGeometry(radius, smoothness, 1.2, 0.25);\n\n  const materialConfig: MeshBasicMaterialParameters = {\n    transparent: true,\n    opacity,\n  };\n\n  const positions = [\n    0, 1, 1, 0, -1, 1, 1, 0, 1, -1, 0, 1, 0, 1, -1, 0, -1, -1, 1, 0, -1, -1, 0,\n    -1, 1, 1, 0, 1, -1, 0, -1, 1, 0, -1, -1, 0,\n  ].map((val) => val * 0.925);\n\n  const target = new Vector3();\n  return Array(positions.length / 3)\n    .fill(0)\n    .map<Mesh<any, MeshBasicMaterial> | Sprite>((_, i) => {\n      if (isSphere) {\n        const map = texture.clone();\n        setMapColumnOffset(map, textureColumn);\n        materialConfig.map = map;\n      } else {\n        materialConfig.color = color;\n      }\n\n      const edge = isSphere\n        ? new Sprite(new SpriteMaterial(materialConfig))\n        : new Mesh(geometry!, new MeshBasicMaterial(materialConfig));\n\n      const i3 = i * 3;\n      edge.position.set(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n      if (isSphere) edge.position.normalize().multiplyScalar(1.7);\n      edge.scale.setScalar(scale);\n\n      edge.lookAt(target.copy(edge.position).multiplyScalar(2));\n\n      if (!isSphere && !edge.position.y) edge.rotation.z = Math.PI / 2;\n\n      edge.renderOrder = 1;\n\n      edge.userData = {\n        color,\n        opacity,\n        scale,\n        hover,\n      };\n\n      return edge;\n    });\n};\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\nimport {\n  BackSide,\n  BufferGeometry,\n  Mesh,\n  MeshBasicMaterial,\n  SphereGeometry,\n} from \"three\";\nimport { mergeGeometries } from \"three/examples/jsm/utils/BufferGeometryUtils.js\";\n\nexport const gizmoBackground = (\n  faces: GizmoAxisObject[],\n  options: GizmoOptionsFallback\n) => {\n  const {\n    isSphere,\n    background: { enabled, color, opacity, hover },\n  } = options;\n\n  let background: Mesh<any, MeshBasicMaterial>;\n\n  const material = new MeshBasicMaterial({\n    color,\n    side: BackSide,\n    opacity: opacity,\n    transparent: true,\n    depthWrite: false,\n  });\n\n  if (!enabled) return null;\n\n  if (isSphere) {\n    background = new Mesh<BufferGeometry, MeshBasicMaterial>(\n      new SphereGeometry(1.8, 64, 64),\n      material\n    );\n  } else {\n    let geometry!: BufferGeometry;\n\n    faces.forEach((plane) => {\n      const originalScale = plane.scale.x;\n      plane.scale.setScalar(0.9);\n      plane.updateMatrix();\n\n      const planeGeometry = plane.geometry.clone();\n      planeGeometry.applyMatrix4(plane.matrix);\n\n      geometry = !!geometry\n        ? mergeGeometries([geometry, planeGeometry])\n        : planeGeometry;\n\n      plane.scale.setScalar(originalScale);\n    });\n\n    background = new Mesh(geometry, material);\n  }\n\n  background.userData = {\n    color,\n    opacity,\n    hover,\n  };\n\n  return background;\n};\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n","/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nimport {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2\n} from 'three';\n\n\nUniformsLib.line = {\n\n\tworldUnits: { value: 1 },\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashOffset: { value: 0 },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t/* glsl */`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t/* glsl */`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttype: 'LineMaterial',\n\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tthis.isLineMaterial = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget color() {\n\n\t\treturn this.uniforms.diffuse.value;\n\n\t}\n\n\tset color( value ) {\n\n\t\tthis.uniforms.diffuse.value = value;\n\n\t}\n\n\tget worldUnits() {\n\n\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t}\n\n\t}\n\n\tget linewidth() {\n\n\t\treturn this.uniforms.linewidth.value;\n\n\t}\n\n\tset linewidth( value ) {\n\n\t\tif ( ! this.uniforms.linewidth ) return;\n\t\tthis.uniforms.linewidth.value = value;\n\n\t}\n\n\tget dashed() {\n\n\t\treturn 'USE_DASH' in this.defines;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( ( value === true ) !== this.dashed ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_DASH = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_DASH;\n\n\t\t}\n\n\t}\n\n\tget dashScale() {\n\n\t\treturn this.uniforms.dashScale.value;\n\n\t}\n\n\tset dashScale( value ) {\n\n\t\tthis.uniforms.dashScale.value = value;\n\n\t}\n\n\tget dashSize() {\n\n\t\treturn this.uniforms.dashSize.value;\n\n\t}\n\n\tset dashSize( value ) {\n\n\t\tthis.uniforms.dashSize.value = value;\n\n\t}\n\n\tget dashOffset() {\n\n\t\treturn this.uniforms.dashOffset.value;\n\n\t}\n\n\tset dashOffset( value ) {\n\n\t\tthis.uniforms.dashOffset.value = value;\n\n\t}\n\n\tget gapSize() {\n\n\t\treturn this.uniforms.gapSize.value;\n\n\t}\n\n\tset gapSize( value ) {\n\n\t\tthis.uniforms.gapSize.value = value;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( value ) {\n\n\t\tif ( ! this.uniforms ) return;\n\t\tthis.uniforms.opacity.value = value;\n\n\t}\n\n\tget resolution() {\n\n\t\treturn this.uniforms.resolution.value;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tthis.uniforms.resolution.value.copy( value );\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( ! this.defines ) return;\n\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\t\t\tthis.extensions.derivatives = true;\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\t\t\tthis.extensions.derivatives = false;\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nclass LineGeometry extends LineSegmentsGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineGeometry = true;\n\n\t\tthis.type = 'LineGeometry';\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst points = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setPositions( points );\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst colors = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setColors( colors );\n\n\t\treturn this;\n\n\t}\n\n\tfromLine( line ) {\n\n\t\tconst geometry = line.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { LineGeometry };\n","import { LineSegments2 } from '../lines/LineSegments2.js';\nimport { LineGeometry } from '../lines/LineGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n\n\tconstructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLine2 = true;\n\n\t\tthis.type = 'Line2';\n\n\t}\n\n}\n\nexport { Line2 };\n","import { Color, Vector2 } from \"three\";\nimport { Line2 } from \"three/addons/lines/Line2.js\";\nimport { LineGeometry } from \"three/addons/lines/LineGeometry.js\";\nimport { LineMaterial } from \"three/addons/lines/LineMaterial.js\";\nimport { GizmoOptionsFallback } from \"../types\";\nimport { GIZMO_AXES, GIZMO_SPHERE_AXES_DISTANCE } from \"./constants\";\n\nexport const axesLines = (options: GizmoOptionsFallback) => {\n  const colorManager = new Color();\n  const positions: number[] = [];\n  const colors: number[] = [];\n  const { isSphere } = options;\n\n  GIZMO_AXES.forEach((axisName, i) => {\n    const { enabled, line, scale, color } = options[axisName];\n\n    if (!enabled || !line) return;\n\n    const negative = i < 3 ? 1 : -1;\n    const distance = isSphere ? GIZMO_SPHERE_AXES_DISTANCE - scale / 2 : 0.975;\n    const point = distance * negative;\n\n    positions.push(\n      axisName.includes(\"x\") ? point : 0,\n      axisName.includes(\"y\") ? point : 0,\n      axisName.includes(\"z\") ? point : 0,\n      0,\n      0,\n      0\n    );\n\n    const colorArray = colorManager.set(color).toArray();\n    colors.push(...colorArray, ...colorArray);\n  });\n\n  if (!positions.length) return null;\n\n  const geometry = new LineGeometry().setPositions(positions).setColors(colors);\n\n  const material = new LineMaterial({\n    linewidth: options.lineWidth,\n    vertexColors: true,\n    resolution: new Vector2(window.innerWidth, window.innerHeight),\n  });\n\n  return new Line2(geometry, material).computeLineDistances();\n};\n","import { GizmoOptionsFallback, GizmoAxisObject } from \"../types\";\nimport { axesMap } from \"./axesMap\";\nimport { axesFaces } from \"./axesFaces\";\nimport { axesCorners } from \"./axesCorners\";\nimport { axesEdges } from \"./axesEdges\";\nimport { gizmoBackground } from \"./gizmoBackground\";\nimport { axesLines } from \"./axesLines\";\n\nexport const axesObjects = (options: GizmoOptionsFallback) => {\n  const { corners, edges } = options;\n\n  const axes: GizmoAxisObject[] = [];\n  const map = axesMap(options);\n\n  const faces = axesFaces(options, map);\n\n  axes.push(...faces);\n  if (corners.enabled) axes.push(...axesCorners(options, map));\n  if (edges.enabled)\n    axes.push(...axesEdges(options, map, corners.enabled ? 7 : 6));\n\n  const background = gizmoBackground(faces, options);\n\n  const lines = axesLines(options);\n\n  return [axes, background, lines] as const;\n};\n","import { GizmoAxisObject } from \"@lib/types\";\nimport { setMapHoverOffset } from \"./axesMap\";\n\nexport const axisHover = (axis: GizmoAxisObject, hovered: boolean = true) => {\n  const { material, userData } = axis;\n\n  const { opacity, color, scale } = hovered ? userData.hover : userData;\n\n  axis.scale.setScalar(scale);\n  material.opacity = opacity;\n\n  if (material.map) setMapHoverOffset(material.map, hovered);\n  else material.color.set(color);\n};\n","import {\n  Camera,\n  Clock,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  Vector2,\n  Vector3,\n  Vector4,\n  WebGLRenderer,\n} from \"three\";\n\nimport { gizmoDomElement, setDomPlacement } from \"./utils/gizmoDomElement\";\nimport { getDomElement } from \"./utils/getDomElement\";\nimport { updateAxis } from \"./utils/updateAxis\";\nimport { isClick } from \"./utils/isClick\";\nimport { intersectedObjects } from \"./utils/intersectedObjects\";\n\nimport {\n  GizmoOptions,\n  ViewportGizmoEventMap,\n  GizmoAxisOptions,\n  GizmoOptionsFallback,\n  GizmoAxisObject,\n} from \"./types\";\nimport { EPSILON, GIZMO_TURN_RATE } from \"./utils/constants\";\nimport { updateBackground } from \"./utils/updateBackground\";\nimport type { OrbitControls } from \"three/examples/jsm/Addons.js\";\nimport { optionsFallback } from \"./utils/optionsFallback\";\nimport { clamp } from \"three/src/math/MathUtils.js\";\nimport { axesObjects } from \"./utils/axesObjects\";\nimport { axisHover } from \"./utils/axisHover\";\n\nexport type { GizmoOptions, ViewportGizmoEventMap, GizmoAxisOptions };\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _spherical = /*@__PURE__*/ new Spherical();\nconst _vec3 = /*@__PURE__*/ new Vector3();\nconst _vec2 = /*@__PURE__*/ new Vector2();\n\n/**\n * ViewportGizmo is a 3D camera orientation controller that provides a visual interface\n * for changing the camera's viewing angle. It creates a widget that shows the current\n * camera orientation and allows direct manipulation of the view through clicking or dragging.\n *\n * @fires ViewportGizmo#start - Fired when a view change interaction begins\n * @fires ViewportGizmo#change - Fired during view changes\n * @fires ViewportGizmo#end - Fired when a view change interaction ends\n *\n * @extends Object3D\n */\nexport class ViewportGizmo extends Object3D<ViewportGizmoEventMap> {\n  type = \"ViewportGizmo\";\n\n  /** Whether the gizmo is currently active and responding to user input */\n  enabled: boolean = true;\n\n  /** The camera being controlled by this gizmo */\n  camera: OrthographicCamera | PerspectiveCamera;\n\n  /** The WebGLRenderer rendering the gizmo */\n  renderer: WebGLRenderer;\n\n  /** The configuration options */\n  options!: GizmoOptions;\n\n  /** The point around which the camera rotates */\n  target = new Vector3();\n\n  /** Whether view changes should be animated */\n  animated: boolean = true;\n\n  /** The speed of view change animations. Higher values result in faster animations */\n  speed: number = 1;\n\n  /**\n   * Indicates whether the gizmo is currently being animated or not,\n   * Useful when interacting with other camera controllers\n   *\n   * @readonly This value is set internally.\n   **/\n  animating = false;\n\n  private _options!: GizmoOptionsFallback;\n  private _intersections!: GizmoAxisObject[];\n  private _background: Mesh<any, MeshBasicMaterial> | null = null;\n  private _viewport: Vector4 = new Vector4();\n  private _originalViewport: Vector4 = new Vector4();\n  private _originalScissor: Vector4 = new Vector4();\n  private _camera!: Camera;\n  private _container!: HTMLElement;\n  private _domElement!: HTMLElement;\n  private _domRect!: DOMRect;\n  private _dragging: boolean = false;\n  private _distance: number = 0;\n  private _clock: Clock = new Clock();\n  private _targetPosition = new Vector3();\n  private _targetQuaternion = new Quaternion();\n  private _quaternionStart = new Quaternion();\n  private _quaternionEnd = new Quaternion();\n  private _pointerStart = new Vector2();\n  private _focus: GizmoAxisObject | null = null;\n  private _placement!: GizmoOptionsFallback[\"placement\"];\n  private _controls?: OrbitControls;\n  private _controlsListeners?: {\n    start: () => void;\n    end: () => void;\n    change: () => void;\n  };\n\n  /**\n   * Creates a new ViewportGizmo instance.\n   *\n   * @param camera - The camera to be controlled by this gizmo\n   * @param renderer - The WebGL renderer used to render the scene\n   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.\n   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string\n   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'\n   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128\n   * @param options.placement - Position of the gizmo in the viewport\n   *    Options include:\n   *    - `\"top-left\"`\n   *    - `\"top-center\"`\n   *    - `\"top-right\"`\n   *    - `\"center-left\"`\n   *    - `\"center-center\"`\n   *    - `\"center-right\"`\n   *    - `\"bottom-left\"`\n   *    - `\"bottom-center\"`\n   *    - `\"bottom-right\"`\n   * @param options.offset - Offset of the gizmo from container edges in pixels\n   * @param options.offset.left - Offset from the left edge\n   * @param options.offset.top - Offset from the top edge\n   * @param options.offset.right - Offset from the right edge\n   * @param options.offset.bottom - Offset from the bottom edge\n   * @param options.animated - Whether view changes should be animated. Defaults to true\n   * @param options.speed - Animation speed multiplier. Defaults to 1\n   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube\n   * @param options.lineWidth - Width of the axes lines in pixels\n   * @param options.id - HTML `id` attribute for the gizmo container\n   * @param options.className - HTML `class` attribute for the gizmo container\n   * @param options.font - Font configuration for axis labels\n   * @param options.font.family - Font family for axis labels\n   * @param options.font.weight - Font weight for axis labels\n   * @param options.background - Configuration for the background sphere/cube\n   * @param options.background.enabled - Whether to display the background\n   * @param options.background.color - Color of the background in normal state\n   * @param options.background.opacity - Opacity of the background in normal state\n   * @param options.background.hover.color - Color of the background when hovered\n   * @param options.background.hover.opacity - Opacity of the background when hovered\n   * @param options.corners - Configuration for corner indicators\n   * @param options.corners.enabled - Whether to display corner indicators\n   * @param options.corners.color - Base color of corner indicators\n   * @param options.corners.opacity - Opacity of corner indicators\n   * @param options.corners.scale - Scale multiplier for corner indicators\n   * @param options.corners.radius - Radius of corner indicators\n   * @param options.corners.smoothness - Smoothness of corner indicators\n   * @param options.corners.hover.color - Color of corner indicators when hovered\n   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered\n   * @param options.corners.hover.scale - Scale of corner indicators when hovered\n   * @param options.edges - Configuration for edge indicators\n   * @param options.edges.enabled - Whether to display edge indicators\n   * @param options.edges.color - Base color of edge indicators\n   * @param options.edges.opacity - Opacity of edge indicators\n   * @param options.edges.scale - Scale multiplier for edge indicators\n   * @param options.edges.radius - Radius of edge indicators\n   * @param options.edges.smoothness - Smoothness of edge indicators\n   * @param options.edges.hover.color - Color of edge indicators when hovered\n   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered\n   * @param options.edges.hover.scale - Scale of edge indicators when hovered\n   * @param options.x - Configuration for positive X axis/face\n   * @param options.y - Configuration for positive Y axis/face\n   * @param options.z - Configuration for positive Z axis/face\n   * @param options.nx - Configuration for negative X axis/face\n   * @param options.ny - Configuration for negative Y axis/face\n   * @param options.nz - Configuration for negative Z axis/face\n   *\n   * @remarks Axis-specific configuration can also use alias names for cube mode:\n   * - `right` (same as `x`)\n   * - `left` (same as `nx`)\n   * - `top` (same as `y`)\n   * - `bottom` (same as `ny`)\n   * - `front` (same as `z`)\n   * - `back` (same as `nz`)\n   *\n   * For each axis/face configuration, the following options are available:\n   * @param options.AXIS.enabled - Whether to draw the axis\n   * @param options.AXIS.label - Custom text label for the axis\n   * @param options.AXIS.opacity - Axis opacity\n   * @param options.AXIS.scale - Scale multiplier for indicator size\n   * @param options.AXIS.line - Whether to draw the axis line\n   * @param options.AXIS.color - Axis indicator background color\n   * @param options.AXIS.labelColor - Axis label color\n   * @param options.AXIS.border.size - Border size around the axis indicator\n   * @param options.AXIS.border.color - Border color around the axis indicator\n   * @param options.AXIS.hover.color - Fill color on hover\n   * @param options.AXIS.hover.labelColor - Label text color on hover\n   * @param options.AXIS.hover.opacity - Opacity when hovered\n   * @param options.AXIS.hover.scale - Indicator scale when hovered\n   * @param options.AXIS.hover.border.size - Hover border size\n   * @param options.AXIS.hover.border.color - Hover border color\n   */\n  constructor(\n    camera: PerspectiveCamera | OrthographicCamera,\n    renderer: WebGLRenderer,\n    options: GizmoOptions = {}\n  ) {\n    super();\n\n    this.camera = camera;\n    this.renderer = renderer;\n    this.set(options);\n  }\n\n  /** Gets the current placement of the gizmo relative to its container. */\n  get placement(): GizmoOptionsFallback[\"placement\"] {\n    return this._placement;\n  }\n\n  /**\n   * Sets and update the placement of the gizmo relative to its container.\n   *\n   * @param placement - The new placement position\n   */\n  set placement(placement: GizmoOptionsFallback[\"placement\"]) {\n    this._placement = setDomPlacement(this._domElement, placement);\n    this.domUpdate();\n  }\n\n  /**\n   * Regenerates the gizmo with the new options.\n   *\n   * @remarks\n   * - Not recommended for use in real-time rendering or animation loops\n   * - Provides a way to completely rebuild the gizmo with new options\n   * - Can be computationally expensive, so use sparingly\n   */\n  set(options: GizmoOptions = {}) {\n    this.dispose();\n\n    this.options = options;\n    this._options = optionsFallback(options);\n\n    this._camera = this._options.isSphere\n      ? new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 5, 10)\n      : new PerspectiveCamera(26, 1, 5, 10);\n\n    this._camera.position.set(0, 0, 7);\n\n    const [axes, background, lines] = axesObjects(this._options);\n\n    if (background) this.add(background);\n    if (lines) this.add(lines);\n    this.add(...axes);\n\n    this._background = background;\n    this._intersections = axes;\n\n    const { container, animated, speed } = this._options;\n\n    this.animated = animated;\n    this.speed = speed;\n\n    this._container = container\n      ? getDomElement(container as string)\n      : document.body;\n\n    this._domElement = gizmoDomElement(this._options);\n    this._domElement.onpointerdown = (e) => this._onPointerDown(e);\n    this._domElement.onpointermove = (e) => this._onPointerMove(e);\n    this._domElement.onpointerleave = () => this._onPointerLeave();\n\n    this._container.appendChild(this._domElement);\n\n    if (this._controls) this.attachControls(this._controls);\n\n    this.update();\n\n    return this;\n  }\n\n  /**\n   * Renders the gizmo to the screen.\n   * This method handles viewport and scissor management to ensure the gizmo\n   * renders correctly without affecting the main scene rendering.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  render() {\n    if (this.animating) this._animate();\n\n    const { renderer, _viewport } = this;\n\n    const _prevScissorTest = renderer.getScissorTest();\n    const _prevAutoClear = renderer.autoClear;\n\n    renderer.autoClear = false;\n    renderer.setViewport(_viewport);\n    if (_prevScissorTest) renderer.setScissor(_viewport);\n\n    renderer.clear(false, true, false);\n    renderer.render(this, this._camera);\n\n    renderer.setViewport(this._originalViewport);\n    if (_prevScissorTest) renderer.setScissor(this._originalScissor);\n\n    renderer.autoClear = _prevAutoClear;\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's DOM-related properties based on its current position\n   * and size in the document.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  domUpdate() {\n    this._domRect = this._domElement.getBoundingClientRect();\n\n    const renderer = this.renderer;\n    const domRect = this._domRect;\n    const containerRect = renderer.domElement.getBoundingClientRect();\n\n    this._viewport.set(\n      domRect.left - containerRect.left,\n      renderer.domElement.clientHeight -\n        (domRect.top - containerRect.top + domRect.height),\n      domRect.width,\n      domRect.height\n    );\n\n    renderer.getViewport(this._originalViewport);\n    if (renderer.getScissorTest()) renderer.getScissor(this._originalScissor);\n\n    return this;\n  }\n\n  /**\n   * Updates the gizmo's orientation to match the current camera orientation.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  cameraUpdate() {\n    this._updateOrientation();\n    return this;\n  }\n\n  /**\n   * Performs a complete update of the gizmo, including both DOM and camera-related updates.\n   *\n   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  update(controls: boolean = true) {\n    if (controls && this._controls) this._controls.update();\n    return this.domUpdate().cameraUpdate();\n  }\n\n  /**\n   * Connects OrbitControls with the gizmo, handling interaction states and updates.\n   * Automatically detaches any previously attached controls.\n   *\n   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}\n   */\n  attachControls(controls: OrbitControls) {\n    this.detachControls();\n\n    this.target = controls.target;\n\n    this._controlsListeners = {\n      start: () => (controls.enabled = false),\n      end: () => (controls.enabled = true),\n      change: () => this.update(false),\n    };\n\n    this.addEventListener(\"start\", this._controlsListeners.start);\n    this.addEventListener(\"end\", this._controlsListeners.end);\n    controls.addEventListener(\"change\", this._controlsListeners.change);\n\n    this._controls = controls;\n\n    return this;\n  }\n\n  /** Removes all control event listeners and references. Safe to call multiple times. */\n  detachControls() {\n    if (!this._controlsListeners || !this._controls) return;\n\n    this.target = new Vector3().copy(this._controls.target);\n\n    this.removeEventListener(\"start\", this._controlsListeners.start);\n    this.removeEventListener(\"end\", this._controlsListeners.end);\n\n    this._controls.removeEventListener(\n      \"change\",\n      this._controlsListeners.change\n    );\n\n    this._controlsListeners = undefined;\n    this._controls = undefined;\n\n    return this;\n  }\n\n  /** Cleans up all resources including geometries, materials, textures, and event listeners. */\n  dispose() {\n    this.detachControls();\n\n    this.children.forEach((child) => {\n      this.remove(child);\n      const mesh = child as Mesh<any, MeshBasicMaterial>;\n      mesh.material?.dispose();\n      mesh.material?.map?.dispose();\n      mesh.geometry?.dispose();\n    });\n\n    this._domElement?.remove();\n  }\n\n  /**\n   * Updates the gizmo's orientation either based on the camera or internal state.\n   *\n   * @private\n   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)\n   */\n  private _updateOrientation(fromCamera: boolean = true) {\n    if (fromCamera) {\n      this.quaternion.copy(this.camera.quaternion).invert();\n      this.updateMatrixWorld();\n    }\n\n    updateAxis(this._options, this._intersections, this.camera);\n  }\n\n  /**\n   * Handles the animation of camera position and orientation changes.\n   *\n   * @private\n   */\n  private _animate() {\n    const { position, quaternion } = this.camera;\n\n    position.set(0, 0, 1);\n\n    if (!this.animated) {\n      position\n        .applyQuaternion(this._quaternionEnd)\n        .multiplyScalar(this._distance)\n        .add(this.target);\n\n      quaternion.copy(this._targetQuaternion);\n\n      this._updateOrientation();\n\n      this.animating = false;\n      this.dispatchEvent({ type: \"change\" });\n      this.dispatchEvent({ type: \"end\" });\n      return;\n    }\n\n    const delta = this._clock.getDelta();\n\n    const step = delta * GIZMO_TURN_RATE * this.speed;\n\n    this._quaternionStart.rotateTowards(this._quaternionEnd, step);\n\n    position\n      .applyQuaternion(this._quaternionStart)\n      .multiplyScalar(this._distance)\n      .add(this.target);\n\n    quaternion.rotateTowards(this._targetQuaternion, step);\n\n    this._updateOrientation();\n    requestAnimationFrame(() => this.dispatchEvent({ type: \"change\" }));\n\n    if (this._quaternionStart.angleTo(this._quaternionEnd) < EPSILON) {\n      this.animating = false;\n      this.dispatchEvent({ type: \"end\" });\n    }\n  }\n\n  /**\n   * Sets the camera orientation to look at the target from a specific axis.\n   *\n   * @private\n   * @param position - The axis point position\n   */\n  private _setOrientation(position: Vector3) {\n    const camera = this.camera;\n    const focusPoint = this.target;\n\n    this._targetPosition.copy(position).multiplyScalar(this._distance);\n\n    _matrix\n      .setPosition(this._targetPosition)\n      .lookAt(this._targetPosition, this.position, this.up);\n    this._targetQuaternion.setFromRotationMatrix(_matrix);\n\n    this._targetPosition.add(focusPoint);\n\n    _matrix.lookAt(this._targetPosition, focusPoint, this.up);\n    this._quaternionEnd.setFromRotationMatrix(_matrix);\n\n    _matrix\n      .setPosition(camera.position)\n      .lookAt(camera.position, focusPoint, this.up);\n    this._quaternionStart.setFromRotationMatrix(_matrix);\n\n    this.animating = true;\n    this._clock.start();\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Handles the pointer down event for starting drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerDown(e: PointerEvent) {\n    if (!this.enabled) return;\n\n    const drag = (e: PointerEvent) => {\n      if (!this._dragging) {\n        if (isClick(e, this._pointerStart)) return;\n        this._dragging = true;\n      }\n\n      const pointerAngle = _vec2\n        .set(e.clientX, e.clientY)\n        .sub(this._pointerStart)\n        .multiplyScalar((1 / this._domRect.width) * Math.PI);\n\n      const spherical = _spherical.setFromVector3(\n        _vec3.subVectors(this.camera.position, this.target)\n      );\n\n      spherical.theta = initialTheta - pointerAngle.x;\n      spherical.phi = clamp(\n        initialPhi - pointerAngle.y,\n        EPSILON,\n        Math.PI - EPSILON\n      );\n\n      this.camera.position.setFromSpherical(spherical).add(this.target);\n      this.camera.lookAt(this.target);\n\n      this.quaternion.copy(this.camera.quaternion).invert();\n\n      this._updateOrientation(false);\n      this.dispatchEvent({ type: \"change\" });\n    };\n\n    const endDrag = () => {\n      document.removeEventListener(\"pointermove\", drag, false);\n      document.removeEventListener(\"pointerup\", endDrag, false);\n\n      if (!this._dragging) return this._handleClick(e);\n\n      if (this._focus) {\n        axisHover(this._focus, false);\n        this._focus = null;\n      }\n\n      this._dragging = false;\n      this.dispatchEvent({ type: \"end\" });\n    };\n\n    if (this.animating) return;\n\n    e.preventDefault();\n    this._pointerStart.set(e.clientX, e.clientY);\n\n    const initialSpherical = new Spherical().setFromVector3(\n      _vec3.subVectors(this.camera.position, this.target)\n    );\n    const initialTheta = initialSpherical.theta;\n    const initialPhi = initialSpherical.phi;\n    this._distance = initialSpherical.radius;\n\n    document.addEventListener(\"pointermove\", drag, false);\n    document.addEventListener(\"pointerup\", endDrag, false);\n\n    this.dispatchEvent({ type: \"start\" });\n  }\n\n  /**\n   * Handles pointer move events for hover effects and drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _onPointerMove(e: PointerEvent) {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._background) updateBackground(this._background, true);\n\n    this._handleHover(e);\n  }\n\n  /**\n   * Handles pointer leave events to reset hover states.\n   *\n   * @private\n   */\n  private _onPointerLeave() {\n    if (!this.enabled || this._dragging) return;\n\n    if (this._background) updateBackground(this._background, false);\n    if (this._focus) axisHover(this._focus, false);\n\n    this._domElement.style.cursor = \"\";\n  }\n\n  /**\n   * Handles click events for axis selection.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleClick(e: PointerEvent) {\n    const intersection = intersectedObjects(\n      e,\n      this._domRect,\n      this._camera,\n      this._intersections\n    );\n\n    if (this._focus) {\n      axisHover(this._focus, false);\n      this._focus = null;\n    }\n\n    if (!intersection) return;\n\n    this._setOrientation(intersection.object.position);\n\n    this.dispatchEvent({ type: \"change\" });\n  }\n\n  /**\n   * Handles hover effects for interactive elements.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  private _handleHover(e: PointerEvent) {\n    const intersection = intersectedObjects(\n      e,\n      this._domRect,\n      this._camera,\n      this._intersections\n    );\n\n    const object = intersection?.object || null;\n\n    if (this._focus === object) return;\n\n    this._domElement.style.cursor = object ? \"pointer\" : \"\";\n\n    if (this._focus) axisHover(this._focus, false);\n\n    if ((this._focus = object)) axisHover(object, true);\n    else updateAxis(this._options, this._intersections, this.camera);\n  }\n}\n"],"names":["setDomPlacement","domElement","placement","y","x","gizmoDomElement","size","offset","id","className","div","top","left","right","bottom","getDomElement","element","clamp","value","min","max","axisMap","point","Vector3","updateAxis","isSphere","axes","camera","axis","positiveIndex","negativeIndex","object","opacity","isClick","e","startCoords","threshold","_raycaster","Raycaster","_mouse","Vector2","intersectedObjects","event","domRect","intersections","intersects","intersection","EPSILON","GIZMO_TURN_RATE","AXES","GIZMO_AXES","GIZMO_FACES","GIZMO_SPHERE_AXES_DISTANCE","updateBackground","background","hovered","material","userData","color","deepClone","obj","optionsFallback","options","type","resolution","container","face","index","axesFallback","negativeAxesFallback","assignNestedDefaults","target","defaultObjects","defaults","key","axesMap","colorManager","Color","doubleOffset","radius","font","corners","edges","canvas","ctx","fontStyle","fontYFix","getFontStyle","label","labelColor","border","hoverColor","hoverLabel","hoverBorder","drawAxis","colsCount","offsetX","offsetY","cellHeight","map","CanvasTexture","SRGBColorSpace","RepeatWrapping","drawRoundRectPath","halfBorderWidth","drawText","text","a","b","_a","_b","family","weight","square","fontSize","textWidth","textHeight","measure","yFix","scaleFactor","finalFontSize","setMapHoverOffset","hover","setMapColumnOffset","col","roundedRectangleGeometry","smoothness","width","height","wi","hi","ul","ur","vl","vh","positions","uvs","n","indices","i","phi","cos","sin","xc","yc","uc","vc","idx","j","BufferGeometry","BufferAttribute","axesFaces","texture","geometry","_","isPositive","enabled","scale","materialConfig","Sprite","SpriteMaterial","Mesh","MeshBasicMaterial","direction","axesCorners","val","corner","i3","axesEdges","textureColumn","edge","mergeGeometries","geometries","useGroups","isIndexed","attributesUsed","morphAttributesUsed","attributes","morphAttributes","morphTargetsRelative","mergedGeometry","attributesCount","name","count","indexOffset","mergedIndex","mergedAttribute","mergeAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","gpuType","arrayLength","attribute","array","result","tupleOffset","l","c","gizmoBackground","faces","BackSide","SphereGeometry","plane","originalScale","planeGeometry","_box","Box3","_vector","LineSegmentsGeometry","InstancedBufferGeometry","Float32BufferAttribute","matrix","start","end","lineSegments","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","mesh","WireframeGeometry","Sphere","center","maxRadiusSq","il","three","UniformsUtils","UniformsLib","LineMaterial","ShaderMaterial","parameters","ShaderLib","_start","_end","_start4","Vector4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","distance","raycastWorldUnits","matrixWorld","instanceStart","instanceEnd","segmentCount","pointOnLine","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","lineDistances","instanceDistanceBuffer","raycaster","worldUnits","sphereMargin","distanceToSphere","boxMargin","distanceToBox","LineGeometry","length","points","line","Line2","axesLines","axisName","negative","colorArray","axesObjects","lines","axisHover","_matrix","_spherical","Spherical","_vec3","_vec2","ViewportGizmo","Object3D","renderer","__publicField","Clock","Quaternion","OrthographicCamera","PerspectiveCamera","animated","speed","_viewport","_prevScissorTest","_prevAutoClear","containerRect","controls","child","_c","_d","fromCamera","position","quaternion","step","focusPoint","drag","pointerAngle","spherical","initialTheta","initialPhi","endDrag","initialSpherical"],"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAqNV,eACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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","x_google_ignoreList":[2,15,17,18,19,20,21]}