{"version":3,"file":"three-viewport-gizmo.umd.cjs","sources":["../lib/utils/gizmoDomElement.ts","../lib/utils/getDomElement.ts","../node_modules/three/src/math/MathUtils.js","../lib/utils/updateAxis.ts","../lib/utils/isClick.ts","../lib/utils/intersectedObjects.ts","../lib/utils/constants.ts","../lib/utils/updateBackground.ts","../lib/utils/deepClone.ts","../lib/utils/optionsFallback.ts","../lib/utils/axesMap.ts","../lib/utils/roundedRectangleGeometry.ts","../lib/utils/axesFaces.ts","../lib/utils/axesCorners.ts","../lib/utils/axesEdges.ts","../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","../lib/utils/gizmoBackground.ts","../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../node_modules/three/examples/jsm/lines/LineMaterial.js","../node_modules/three/examples/jsm/lines/LineSegments2.js","../node_modules/three/examples/jsm/lines/LineGeometry.js","../node_modules/three/examples/jsm/lines/Line2.js","../lib/utils/axesLines.ts","../lib/utils/axesObjects.ts","../lib/utils/axisHover.ts","../lib/ViewportGizmo.ts"],"sourcesContent":["import { GizmoOptionsFallback } from \"../types\";\r\n\r\nexport const setDomPlacement = (\r\n  domElement: HTMLElement,\r\n  placement: GizmoOptionsFallback[\"placement\"]\r\n) => {\r\n  const [y, x] = placement.split(\"-\");\r\n  Object.assign(domElement.style, {\r\n    left: x === \"left\" ? \"0\" : x === \"center\" ? `50%` : \"\",\r\n    right: x === \"right\" ? \"0\" : \"\",\r\n    top: y === \"top\" ? \"0\" : y === \"bottom\" ? \"\" : \"50%\",\r\n    bottom: y === \"bottom\" ? \"0\" : \"\",\r\n    transform: `${x === \"center\" ? \"translateX(-50%)\" : \"\"} ${\r\n      y === \"center\" ? \"translateY(-50%)\" : \"\"\r\n    }`,\r\n  });\r\n\r\n  return placement;\r\n};\r\n\r\nexport const gizmoDomElement = ({\r\n  placement,\r\n  size,\r\n  offset,\r\n  id,\r\n  className,\r\n}: GizmoOptionsFallback) => {\r\n  const div = document.createElement(\"div\");\r\n\r\n  const { top, left, right, bottom } = offset;\r\n  Object.assign(div.style, {\r\n    id,\r\n    position: \"absolute\",\r\n    zIndex: \"1000\",\r\n    height: `${size}px`,\r\n    width: `${size}px`,\r\n    margin: `${top}px ${right}px ${bottom}px ${left}px`,\r\n    borderRadius: \"100%\",\r\n  });\r\n\r\n  setDomPlacement(div, placement);\r\n\r\n  if (id) div.id = id;\r\n  if (className) div.className = className;\r\n\r\n  return div;\r\n};\r\n","export const getDomElement = (\r\n  domElement: string | HTMLElement\r\n): HTMLElement => {\r\n  const element =\r\n    typeof domElement === \"string\"\r\n      ? document.querySelector<HTMLElement>(domElement)\r\n      : domElement;\r\n\r\n  if (!element) throw Error(`Invalid DOM element`);\r\n\r\n  return element;\r\n};\r\n","const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\r\nimport { Camera, Vector3 } from \"three\";\r\nimport { clamp } from \"three/src/math/MathUtils.js\";\r\n\r\nconst axisMap: [\r\n  axis: \"x\" | \"y\" | \"z\",\r\n  positiveIndex: number,\r\n  negativeIndex: number\r\n][] = [\r\n  [\"x\", 0, 3],\r\n  [\"y\", 1, 4],\r\n  [\"z\", 2, 5],\r\n];\r\n\r\nconst point = /*@__PURE__*/ new Vector3();\r\nexport function updateAxis(\r\n  { isSphere }: GizmoOptionsFallback,\r\n  axes: GizmoAxisObject[],\r\n  camera: Camera\r\n): void {\r\n  if (!isSphere) return;\r\n\r\n  point.set(0, 0, 1).applyQuaternion(camera.quaternion);\r\n\r\n  axisMap.forEach(([axis, positiveIndex, negativeIndex]) => {\r\n    const value = point[axis];\r\n\r\n    let object = axes[positiveIndex];\r\n    let opacity = object.userData.opacity;\r\n\r\n    object.material.opacity = clamp(value >= 0 ? opacity : opacity / 2, 0, 1);\r\n\r\n    object = axes[negativeIndex];\r\n    opacity = object.userData.opacity;\r\n\r\n    object.material.opacity = clamp(value >= 0 ? opacity / 2 : opacity, 0, 1);\r\n  });\r\n}\r\n","import { Vector2 } from \"three\";\r\n\r\nexport const isClick = (\r\n  e: PointerEvent,\r\n  startCoords: Vector2,\r\n  threshold: number = 10\r\n) =>\r\n  Math.abs(e.clientX - startCoords.x) < threshold &&\r\n  Math.abs(e.clientY - startCoords.y) < threshold;\r\n","import { GizmoAxisObject } from \"@lib/types\";\r\nimport {\r\n  Vector2,\r\n  Raycaster,\r\n  type Object3D,\r\n  type Camera,\r\n  Intersection,\r\n} from \"three\";\r\n\r\nconst _raycaster = /*@__PURE__*/ new Raycaster();\r\nconst _mouse = /*@__PURE__*/ new Vector2();\r\n\r\nexport const intersectedObjects = (\r\n  event: PointerEvent,\r\n  domRect: DOMRect,\r\n  camera: Camera,\r\n  intersections: Object3D[]\r\n): Intersection<GizmoAxisObject> | null => {\r\n  _mouse.set(\r\n    ((event.clientX - domRect.left) / domRect.width) * 2 - 1,\r\n    -((event.clientY - domRect.top) / domRect.height) * 2 + 1\r\n  );\r\n\r\n  _raycaster.setFromCamera(_mouse, camera);\r\n\r\n  const intersects = _raycaster.intersectObjects<GizmoAxisObject>(\r\n    intersections,\r\n    false\r\n  );\r\n\r\n  const intersection = intersects.length ? intersects[0] : null;\r\n\r\n  return !intersection || !intersection.object.visible ? null : intersection;\r\n};\r\n","export const EPSILON = 1e-6;\r\nexport const GIZMO_TURN_RATE = 2 * Math.PI;\r\nexport const AXES = [\"x\", \"y\", \"z\"] as const;\r\nexport const GIZMO_AXES = [...AXES, \"nx\", \"ny\", \"nz\"] as const;\r\nexport const GIZMO_FACES = [\r\n  \"right\",\r\n  \"top\",\r\n  \"front\",\r\n  \"left\",\r\n  \"bottom\",\r\n  \"back\",\r\n] as const;\r\nexport const GIZMO_SPHERE_AXES_DISTANCE = 1.3;\r\n","import { BufferGeometry, Mesh, MeshBasicMaterial } from \"three\";\r\n\r\nexport const updateBackground = (\r\n  background: Mesh<BufferGeometry, MeshBasicMaterial>,\r\n  hovered: boolean = true\r\n) => {\r\n  const { material, userData } = background;\r\n  const { color, opacity } = hovered ? userData.hover : userData;\r\n\r\n  material.color.set(color);\r\n  material.opacity = opacity;\r\n};\r\n","export const deepClone = <T>(obj: T) => JSON.parse(JSON.stringify(obj));\r\n","import {\r\n  GizmoAxisOptions,\r\n  GizmoOptions,\r\n  GizmoOptionsFallback,\r\n} from \"@lib/types\";\r\nimport { AXES, GIZMO_AXES, GIZMO_FACES } from \"./constants\";\r\n\r\nimport { deepClone } from \"./deepClone\";\r\n\r\nexport const optionsFallback = (\r\n  options: GizmoOptions\r\n): GizmoOptionsFallback => {\r\n  const type = options.type || \"sphere\";\r\n  const isSphere = type === \"sphere\";\r\n  const resolution = options.resolution || isSphere ? 64 : 128;\r\n\r\n  const { container } = options;\r\n  options.container = undefined;\r\n  options = JSON.parse(JSON.stringify(options));\r\n  options.container = container;\r\n\r\n  // Convert face axis to regular axis\r\n  GIZMO_FACES.forEach((face, index) => {\r\n    if (options[face]) options[GIZMO_AXES[index]] = options[face];\r\n  });\r\n\r\n  // Positive Axes fallback options\r\n  const axesFallback: GizmoAxisOptions = {\r\n    enabled: true,\r\n    color: 0xffffff,\r\n    opacity: 1,\r\n    scale: isSphere ? 0.7 : 0.7,\r\n    labelColor: 0x222222,\r\n    line: false,\r\n    border: {\r\n      size: 0,\r\n      color: 0xdddddd,\r\n    },\r\n    hover: {\r\n      color: isSphere ? 0xffffff : 0x93d3eb,\r\n      labelColor: 0x222222,\r\n      opacity: 1,\r\n      scale: isSphere ? 0.7 : 0.7,\r\n      border: {\r\n        size: 0,\r\n        color: 0xdddddd,\r\n      },\r\n    },\r\n  };\r\n\r\n  // Negative Axes fallback options\r\n  const negativeAxesFallback = {\r\n    line: false,\r\n    scale: isSphere ? 0.45 : 0.7,\r\n    hover: {\r\n      scale: isSphere ? 0.5 : 0.7,\r\n    },\r\n  };\r\n\r\n  const optionsFallback: GizmoOptions = {\r\n    type,\r\n    container: document.body,\r\n    size: 128,\r\n    placement: \"top-right\",\r\n    resolution,\r\n    lineWidth: 20,\r\n    radius: isSphere ? 1 : 0.2,\r\n    smoothness: 18,\r\n    animated: true,\r\n    speed: 1,\r\n    background: {\r\n      enabled: true,\r\n      color: isSphere ? 0xffffff : 0xe0e6ec,\r\n      opacity: isSphere ? 0 : 1,\r\n      hover: {\r\n        color: isSphere ? 0xffffff : 0xe0e6ec,\r\n        opacity: isSphere ? 0.2 : 1,\r\n      },\r\n    },\r\n    font: {\r\n      family: \"sans-serif\",\r\n      weight: 900,\r\n    },\r\n    offset: {\r\n      top: 10,\r\n      left: 10,\r\n      bottom: 10,\r\n      right: 10,\r\n    },\r\n    corners: {\r\n      enabled: !isSphere,\r\n      color: isSphere ? 0xf2d962 : 0xffffff,\r\n      opacity: 1,\r\n      scale: isSphere ? 0.15 : 0.2,\r\n      radius: 1,\r\n      smoothness: 18,\r\n      hover: {\r\n        color: isSphere ? 0xffffff : 0x93d3eb,\r\n        opacity: 1,\r\n        scale: isSphere ? 0.2 : 0.225,\r\n      },\r\n    },\r\n    edges: {\r\n      enabled: !isSphere,\r\n      color: isSphere ? 0xf2d962 : 0xffffff,\r\n      opacity: isSphere ? 1 : 0,\r\n      radius: isSphere ? 1 : 0.125,\r\n      smoothness: 18,\r\n      scale: isSphere ? 0.15 : 1,\r\n      hover: {\r\n        color: isSphere ? 0xffffff : 0x93d3eb,\r\n        opacity: 1,\r\n        scale: isSphere ? 0.2 : 1,\r\n      },\r\n    },\r\n    x: {\r\n      ...deepClone(axesFallback),\r\n      ...(isSphere\r\n        ? {\r\n            label: \"X\",\r\n            color: 0xff3653,\r\n            line: true,\r\n          }\r\n        : {\r\n            label: \"Right\",\r\n          }),\r\n    },\r\n    y: {\r\n      ...deepClone(axesFallback),\r\n      ...(isSphere\r\n        ? {\r\n            label: \"Y\",\r\n            color: 0x8adb00,\r\n            line: true,\r\n          }\r\n        : {\r\n            label: \"Top\",\r\n          }),\r\n    },\r\n    z: {\r\n      ...deepClone(axesFallback),\r\n      ...(isSphere\r\n        ? {\r\n            label: \"Z\",\r\n            color: 0x2c8fff,\r\n            line: true,\r\n          }\r\n        : {\r\n            label: \"Front\",\r\n          }),\r\n    },\r\n    nx: {\r\n      ...deepClone(negativeAxesFallback),\r\n      label: isSphere ? \"\" : \"Left\",\r\n    },\r\n    ny: {\r\n      ...deepClone(negativeAxesFallback),\r\n      label: isSphere ? \"\" : \"Bottom\",\r\n    },\r\n    nz: {\r\n      ...deepClone(negativeAxesFallback),\r\n      label: isSphere ? \"\" : \"Back\",\r\n    },\r\n  };\r\n\r\n  assignNestedDefaults(options, optionsFallback);\r\n\r\n  // Negative axis fallback to positive axis\r\n  AXES.forEach((axis) =>\r\n    assignNestedDefaults(\r\n      (options as any)[`n${axis}`],\r\n      deepClone((options as any)[axis])\r\n    )\r\n  );\r\n\r\n  return { ...options, isSphere } as GizmoOptionsFallback;\r\n};\r\n\r\nfunction assignNestedDefaults<T>(target: T, ...defaultObjects: T[]) {\r\n  if (\r\n    target instanceof HTMLElement ||\r\n    typeof target !== \"object\" ||\r\n    target === null\r\n  )\r\n    return target;\r\n\r\n  for (const defaults of defaultObjects) {\r\n    for (const key in defaults) {\r\n      if (key === \"container\") continue;\r\n\r\n      if (key in (defaults as any)) {\r\n        if (target[key] === undefined) {\r\n          (target as any)[key] = defaults[key];\r\n        } else if (\r\n          typeof defaults[key] === \"object\" &&\r\n          !Array.isArray(defaults[key])\r\n        ) {\r\n          (target as any)[key] = assignNestedDefaults(\r\n            (target as any)[key] || {},\r\n            defaults[key]\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return target as T;\r\n}\r\n","import {\r\n  CanvasTexture,\r\n  Color,\r\n  ColorRepresentation,\r\n  RepeatWrapping,\r\n  SRGBColorSpace,\r\n  Texture,\r\n} from \"three\";\r\nimport { GizmoAxisOptions, GizmoOptionsFallback } from \"@lib/types\";\r\nimport { GIZMO_AXES } from \"./constants\";\r\n\r\nexport const axesMap = (options: GizmoOptionsFallback, offset: number = 2) => {\r\n  const colorManager = new Color();\r\n  const doubleOffset = offset * 2;\r\n  const { isSphere, resolution, radius, font, corners, edges } = options;\r\n\r\n  const axes: (Required<GizmoAxisOptions> & { radius: number })[] =\r\n    GIZMO_AXES.map((axis) => ({ ...options[axis], radius }));\r\n\r\n  if (isSphere && corners.enabled) axes.push(corners as any);\r\n  if (isSphere && edges.enabled) axes.push(edges as any);\r\n\r\n  const canvas = document.createElement(\"canvas\");\r\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n  canvas.width = resolution * 2 + doubleOffset * 2;\r\n  canvas.height = resolution * axes.length + doubleOffset * axes.length;\r\n\r\n  const [fontStyle, fontYFix] = getFontStyle(axes, resolution, font);\r\n\r\n  axes.forEach(\r\n    (\r\n      {\r\n        radius,\r\n        label,\r\n        color,\r\n        labelColor,\r\n        border,\r\n        hover: {\r\n          color: hoverColor,\r\n          labelColor: hoverLabel,\r\n          border: hoverBorder,\r\n        },\r\n      },\r\n      index\r\n    ) => {\r\n      const y = resolution * index + index * doubleOffset + offset;\r\n      drawAxis(\r\n        offset,\r\n        y,\r\n        offset,\r\n        resolution,\r\n        radius,\r\n        label,\r\n        border,\r\n        color,\r\n        labelColor\r\n      );\r\n      drawAxis(\r\n        resolution + offset * 3,\r\n        y,\r\n        offset,\r\n        resolution,\r\n        radius,\r\n        label,\r\n        hoverBorder ?? border,\r\n        hoverColor ?? color,\r\n        hoverLabel ?? labelColor\r\n      );\r\n    }\r\n  );\r\n\r\n  /* \r\n  // Debug\r\n  document.body.appendChild(canvas);\r\n  Object.assign(canvas.style, {\r\n    position: \"fixed\",\r\n    top: 0,\r\n    left: 0,\r\n    zIndex: 100000,\r\n  }); */\r\n\r\n  const colsCount = axes.length;\r\n  const offsetX = offset / (resolution * 2);\r\n  const offsetY = offset / (resolution * 6);\r\n  const cellHeight = 1 / colsCount;\r\n\r\n  const map = new CanvasTexture(canvas);\r\n  map.repeat.set(0.5 - 2 * offsetX, cellHeight - 2 * offsetY);\r\n  map.offset.set(offsetX, 1 - offsetY);\r\n\r\n  Object.assign(map, {\r\n    colorSpace: SRGBColorSpace,\r\n    wrapS: RepeatWrapping,\r\n    wrapT: RepeatWrapping,\r\n    userData: {\r\n      offsetX,\r\n      offsetY,\r\n      cellHeight,\r\n    },\r\n  });\r\n\r\n  return map;\r\n\r\n  function drawAxis(\r\n    x: number,\r\n    y: number,\r\n    offset: number,\r\n    size: number,\r\n    radius: number,\r\n    label: string,\r\n    border: GizmoAxisOptions[\"border\"],\r\n    color: ColorRepresentation,\r\n    labelColor: ColorRepresentation\r\n  ) {\r\n    radius = radius * (size / 2);\r\n\r\n    if (color != null && color !== \"\") {\r\n      drawRoundRectPath();\r\n      ctx.fillStyle = colorManager.set(color!).getStyle();\r\n      ctx.fill();\r\n    }\r\n\r\n    if (border && border.size) {\r\n      const halfBorderWidth = (border.size * size) / 2;\r\n      x += halfBorderWidth;\r\n      y += halfBorderWidth;\r\n      size -= border.size * size;\r\n      radius = Math.max(0, radius - halfBorderWidth);\r\n\r\n      drawRoundRectPath();\r\n      ctx.strokeStyle = colorManager.set(border.color).getStyle();\r\n      ctx.lineWidth = border.size * size;\r\n      ctx.stroke();\r\n    }\r\n\r\n    if (label)\r\n      drawText(\r\n        ctx,\r\n        x + size / 2,\r\n        y + (size + offset) / 2,\r\n        label,\r\n        colorManager.set(labelColor!).getStyle()\r\n      );\r\n\r\n    function drawRoundRectPath() {\r\n      ctx.beginPath();\r\n      ctx.moveTo(x + radius, y);\r\n      ctx.lineTo(x + size - radius, y);\r\n      ctx.arcTo(x + size, y, x + size, y + radius, radius);\r\n      ctx.lineTo(x + size, y + size - radius);\r\n      ctx.arcTo(x + size, y + size, x + size - radius, y + size, radius);\r\n      ctx.lineTo(x + radius, y + size);\r\n      ctx.arcTo(x, y + size, x, y + size - radius, radius);\r\n      ctx.lineTo(x, y + radius);\r\n      ctx.arcTo(x, y, x + radius, y, radius);\r\n      ctx.closePath();\r\n    }\r\n  }\r\n\r\n  function getFontStyle(\r\n    axis: GizmoAxisOptions[],\r\n    resolution: number,\r\n    font: GizmoOptionsFallback[\"font\"]\r\n  ) {\r\n    const longestLabel = [...axis]\r\n      .sort((a, b) => (a.label?.length || 0) - (b.label?.length || 0))\r\n      .pop()!;\r\n    const text = longestLabel.label!;\r\n\r\n    const { family, weight } = font;\r\n\r\n    const square = isSphere\r\n      ? Math.sqrt(Math.pow(resolution * 0.7, 2) / 2)\r\n      : resolution;\r\n    let fontSize = square;\r\n    let textWidth = 0;\r\n    let textHeight = 0;\r\n\r\n    do {\r\n      ctx.font = `${weight} ${fontSize}px ${family}`;\r\n      const measure = ctx.measureText(text);\r\n      textWidth = measure.width;\r\n      textHeight = measure.fontBoundingBoxDescent;\r\n      fontSize--;\r\n    } while (textWidth > square && fontSize > 0);\r\n\r\n    const yFix = square / textHeight;\r\n    const scaleFactor = Math.min(square / textWidth, yFix);\r\n    const finalFontSize = Math.floor(fontSize * scaleFactor);\r\n\r\n    return [`${weight} ${finalFontSize}px ${family}`, yFix] as const;\r\n  }\r\n\r\n  function drawText(\r\n    ctx: CanvasRenderingContext2D,\r\n    x: number,\r\n    y: number,\r\n    text: string,\r\n    color: string\r\n  ) {\r\n    ctx.font = fontStyle;\r\n    ctx.textAlign = \"center\";\r\n    ctx.textBaseline = \"middle\";\r\n    ctx.fillStyle = color;\r\n    ctx.fillText(text, x, y + (isSphere ? fontYFix : 0));\r\n  }\r\n};\r\n\r\nexport const setMapHoverOffset = (map: Texture, hover: boolean) =>\r\n  (map.offset.x = (hover ? 0.5 : 0) + map.userData.offsetX);\r\n\r\nexport const setMapColumnOffset = (map: Texture, col: number) => {\r\n  const {\r\n    offset,\r\n    userData: { offsetY, cellHeight },\r\n  } = map;\r\n  offset.y = 1 - (col + 1) * cellHeight + offsetY;\r\n};\r\n","import { BufferGeometry, BufferAttribute } from \"three\";\r\n\r\n/**\r\n * Generate a Rounded Rectangle geometry\r\n *\r\n * @param radius      - The edges radius\r\n * @param smoothness  - The edges smoothness\r\n *\r\n * @ThanksTo `@hofk` for the {@link https://discourse.threejs.org/t/roundedrectangle-squircle/28645 RoundedRectangle + Squircle } Geometry\r\n *\r\n * @returns A round rectangle geometry\r\n */\r\nexport function roundedRectangleGeometry(\r\n  radius: number,\r\n  smoothness: number,\r\n  width: number = 2,\r\n  height: number = 2\r\n) {\r\n  // helper const's\r\n  const wi = width / 2 - radius; // inner width\r\n  const hi = height / 2 - radius; // inner height\r\n  const ul = radius / width; // u left\r\n  const ur = (width - radius) / width; // u right\r\n  const vl = radius / height; // v low\r\n  const vh = (height - radius) / height; // v high\r\n\r\n  const positions = [wi, hi, 0, -wi, hi, 0, -wi, -hi, 0, wi, -hi, 0];\r\n  const uvs = [ur, vh, ul, vh, ul, vl, ur, vl];\r\n  const n = [\r\n    3 * (smoothness + 1) + 3,\r\n    3 * (smoothness + 1) + 4,\r\n    smoothness + 4,\r\n    smoothness + 5,\r\n    2 * (smoothness + 1) + 4,\r\n    2,\r\n    1,\r\n    2 * (smoothness + 1) + 3,\r\n    3,\r\n    4 * (smoothness + 1) + 3,\r\n    4,\r\n    0,\r\n  ];\r\n  const indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(\r\n    (i) => n[i]\r\n  );\r\n\r\n  let phi, cos, sin, xc, yc, uc, vc, idx;\r\n\r\n  for (let i = 0; i < 4; i++) {\r\n    xc = i < 1 || i > 2 ? wi : -wi;\r\n    yc = i < 2 ? hi : -hi;\r\n\r\n    uc = i < 1 || i > 2 ? ur : ul;\r\n    vc = i < 2 ? vh : vl;\r\n\r\n    for (let j = 0; j <= smoothness; j++) {\r\n      phi = (Math.PI / 2) * (i + j / smoothness);\r\n      cos = Math.cos(phi);\r\n      sin = Math.sin(phi);\r\n\r\n      positions.push(xc + radius * cos, yc + radius * sin, 0);\r\n\r\n      uvs.push(uc + ul * cos, vc + vl * sin);\r\n\r\n      if (j < smoothness) {\r\n        idx = (smoothness + 1) * i + j + 4;\r\n        indices.push(i, idx, idx + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  return new BufferGeometry()\r\n    .setIndex(new BufferAttribute(new Uint32Array(indices), 1))\r\n    .setAttribute(\r\n      \"position\",\r\n      new BufferAttribute(new Float32Array(positions), 3)\r\n    )\r\n    .setAttribute(\"uv\", new BufferAttribute(new Float32Array(uvs), 2));\r\n}\r\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\r\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\r\nimport {\r\n  CanvasTexture,\r\n  Mesh,\r\n  MeshBasicMaterial,\r\n  MeshBasicMaterialParameters,\r\n  Sprite,\r\n  SpriteMaterial,\r\n  Vector3,\r\n} from \"three\";\r\nimport { GIZMO_AXES, GIZMO_SPHERE_AXES_DISTANCE } from \"./constants\";\r\n\r\nimport { setMapColumnOffset } from \"./axesMap\";\r\n\r\nexport const axesFaces = (\r\n  options: GizmoOptionsFallback,\r\n  texture: CanvasTexture\r\n): GizmoAxisObject[] => {\r\n  const target = new Vector3();\r\n  const { isSphere, radius, smoothness } = options;\r\n  const geometry = roundedRectangleGeometry(radius, smoothness);\r\n\r\n  return GIZMO_AXES.map((_, i) => {\r\n    const isPositive = i < 3;\r\n\r\n    const axis = GIZMO_AXES[i];\r\n    const map = i ? texture.clone() : texture;\r\n\r\n    setMapColumnOffset(map, i);\r\n\r\n    const { enabled, scale, opacity, hover } = options[axis];\r\n\r\n    const materialConfig: MeshBasicMaterialParameters = {\r\n      map,\r\n      opacity,\r\n      transparent: true,\r\n    };\r\n\r\n    const face = isSphere\r\n      ? new Sprite(new SpriteMaterial(materialConfig))\r\n      : new Mesh(geometry, new MeshBasicMaterial(materialConfig));\r\n\r\n    const direction = (isPositive ? axis : axis[1]) as \"x\" | \"y\" | \"z\";\r\n    face.position[direction] =\r\n      (isPositive ? 1 : -1) * (isSphere ? GIZMO_SPHERE_AXES_DISTANCE : 1);\r\n\r\n    if (!isSphere) face.lookAt(target.copy(face.position).multiplyScalar(1.7));\r\n\r\n    face.scale.setScalar(scale);\r\n    face.renderOrder = 1;\r\n    face.visible = enabled;\r\n    face.userData = {\r\n      scale,\r\n      opacity,\r\n      hover,\r\n    };\r\n\r\n    return face;\r\n  });\r\n};\r\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\r\nimport {\r\n  CanvasTexture,\r\n  Mesh,\r\n  MeshBasicMaterial,\r\n  MeshBasicMaterialParameters,\r\n  Sprite,\r\n  SpriteMaterial,\r\n  Vector3,\r\n} from \"three\";\r\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\r\nimport { setMapColumnOffset } from \"./axesMap\";\r\n\r\nexport const axesCorners = (\r\n  options: GizmoOptionsFallback,\r\n  texture: CanvasTexture\r\n) => {\r\n  const { isSphere, corners } = options;\r\n\r\n  if (!corners.enabled) return [];\r\n\r\n  const { color, opacity, scale, radius, smoothness, hover } = corners;\r\n\r\n  const geometry = isSphere\r\n    ? null\r\n    : roundedRectangleGeometry(radius, smoothness);\r\n\r\n  const materialConfig: MeshBasicMaterialParameters = {\r\n    transparent: true,\r\n    opacity,\r\n  };\r\n\r\n  const positions = [\r\n    1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, -1, -1, -1,\r\n    -1, -1,\r\n  ].map((val) => val * 0.85);\r\n\r\n  const target = new Vector3();\r\n  return Array(positions.length / 3)\r\n    .fill(0)\r\n    .map<GizmoAxisObject>((_, i) => {\r\n      if (isSphere) {\r\n        const map = texture.clone();\r\n        setMapColumnOffset(map, 6);\r\n        materialConfig.map = map;\r\n      } else {\r\n        materialConfig.color = color;\r\n      }\r\n\r\n      const corner = isSphere\r\n        ? new Sprite(new SpriteMaterial(materialConfig))\r\n        : new Mesh(geometry!, new MeshBasicMaterial(materialConfig));\r\n\r\n      const i3 = i * 3;\r\n      corner.position.set(positions[i3], positions[i3 + 1], positions[i3 + 2]);\r\n\r\n      if (isSphere) corner.position.normalize().multiplyScalar(1.7);\r\n\r\n      corner.scale.setScalar(scale);\r\n      corner.lookAt(target.copy(corner.position).multiplyScalar(2));\r\n      corner.renderOrder = 1;\r\n\r\n      corner.userData = {\r\n        color,\r\n        opacity,\r\n        scale,\r\n        hover,\r\n      };\r\n\r\n      return corner;\r\n    });\r\n};\r\n","import { GizmoOptionsFallback } from \"@lib/types\";\r\nimport {\r\n  CanvasTexture,\r\n  Mesh,\r\n  MeshBasicMaterial,\r\n  MeshBasicMaterialParameters,\r\n  Sprite,\r\n  SpriteMaterial,\r\n  Vector3,\r\n} from \"three\";\r\nimport { roundedRectangleGeometry } from \"./roundedRectangleGeometry\";\r\nimport { setMapColumnOffset } from \"./axesMap\";\r\n\r\nexport const axesEdges = (\r\n  options: GizmoOptionsFallback,\r\n  texture: CanvasTexture,\r\n  textureColumn: number\r\n) => {\r\n  const { isSphere, edges } = options;\r\n\r\n  if (!edges.enabled) return [];\r\n\r\n  const { color, opacity, scale, hover, radius, smoothness } = edges;\r\n\r\n  const geometry = isSphere\r\n    ? null\r\n    : roundedRectangleGeometry(radius, smoothness, 1.2, 0.25);\r\n\r\n  const materialConfig: MeshBasicMaterialParameters = {\r\n    transparent: true,\r\n    opacity,\r\n  };\r\n\r\n  const positions = [\r\n    0, 1, 1, 0, -1, 1, 1, 0, 1, -1, 0, 1, 0, 1, -1, 0, -1, -1, 1, 0, -1, -1, 0,\r\n    -1, 1, 1, 0, 1, -1, 0, -1, 1, 0, -1, -1, 0,\r\n  ].map((val) => val * 0.925);\r\n\r\n  const target = new Vector3();\r\n  const defaultUp = new Vector3(0, 1, 0);\r\n  return Array(positions.length / 3)\r\n    .fill(0)\r\n    .map<Mesh<any, MeshBasicMaterial> | Sprite>((_, i) => {\r\n      if (isSphere) {\r\n        const map = texture.clone();\r\n        setMapColumnOffset(map, textureColumn);\r\n        materialConfig.map = map;\r\n      } else {\r\n        materialConfig.color = color;\r\n      }\r\n\r\n      const edge = isSphere\r\n        ? new Sprite(new SpriteMaterial(materialConfig))\r\n        : new Mesh(geometry!, new MeshBasicMaterial(materialConfig));\r\n\r\n      const i3 = i * 3;\r\n      edge.position.set(positions[i3], positions[i3 + 1], positions[i3 + 2]);\r\n      if (isSphere) edge.position.normalize().multiplyScalar(1.7);\r\n      edge.scale.setScalar(scale);\r\n\r\n      edge.up.copy(defaultUp);\r\n      edge.lookAt(target.copy(edge.position).multiplyScalar(2));\r\n      if (!isSphere && !edge.position.y) edge.rotation.z = Math.PI / 2;\r\n\r\n      edge.renderOrder = 1;\r\n\r\n      edge.userData = {\r\n        color,\r\n        opacity,\r\n        scale,\r\n        hover,\r\n      };\r\n\r\n      return edge;\r\n    });\r\n};\r\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute} attribute\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import { GizmoAxisObject, GizmoOptionsFallback } from \"@lib/types\";\r\nimport {\r\n  BackSide,\r\n  BufferGeometry,\r\n  Mesh,\r\n  MeshBasicMaterial,\r\n  SphereGeometry,\r\n} from \"three\";\r\nimport { mergeGeometries } from \"three/examples/jsm/utils/BufferGeometryUtils.js\";\r\n\r\nexport const gizmoBackground = (\r\n  faces: GizmoAxisObject[],\r\n  options: GizmoOptionsFallback\r\n) => {\r\n  const {\r\n    isSphere,\r\n    background: { enabled, color, opacity, hover },\r\n  } = options;\r\n\r\n  let background: Mesh<any, MeshBasicMaterial>;\r\n\r\n  const material = new MeshBasicMaterial({\r\n    color,\r\n    side: BackSide,\r\n    opacity: opacity,\r\n    transparent: true,\r\n    depthWrite: false,\r\n  });\r\n\r\n  if (!enabled) return null;\r\n\r\n  if (isSphere) {\r\n    background = new Mesh<BufferGeometry, MeshBasicMaterial>(\r\n      new SphereGeometry(1.8, 64, 64),\r\n      material\r\n    );\r\n  } else {\r\n    let geometry!: BufferGeometry;\r\n\r\n    faces.forEach((plane) => {\r\n      const originalScale = plane.scale.x;\r\n      plane.scale.setScalar(0.9);\r\n      plane.updateMatrix();\r\n\r\n      const planeGeometry = plane.geometry.clone();\r\n      planeGeometry.applyMatrix4(plane.matrix);\r\n\r\n      geometry = !!geometry\r\n        ? mergeGeometries([geometry, planeGeometry])\r\n        : planeGeometry;\r\n\r\n      plane.scale.setScalar(originalScale);\r\n    });\r\n\r\n    background = new Mesh(geometry, material);\r\n  }\r\n\r\n  background.userData = {\r\n    color,\r\n    opacity,\r\n    hover,\r\n  };\r\n\r\n  return background;\r\n};\r\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\tthis.instanceCount = this.attributes.instanceStart.count;\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n","import {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2,\n} from 'three';\n\nUniformsLib.line = {\n\n\tworldUnits: { value: 1 },\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashOffset: { value: 0 },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t/* glsl */`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t/* glsl */`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttype: 'LineMaterial',\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tthis.isLineMaterial = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget color() {\n\n\t\treturn this.uniforms.diffuse.value;\n\n\t}\n\n\tset color( value ) {\n\n\t\tthis.uniforms.diffuse.value = value;\n\n\t}\n\n\tget worldUnits() {\n\n\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t}\n\n\t}\n\n\tget linewidth() {\n\n\t\treturn this.uniforms.linewidth.value;\n\n\t}\n\n\tset linewidth( value ) {\n\n\t\tif ( ! this.uniforms.linewidth ) return;\n\t\tthis.uniforms.linewidth.value = value;\n\n\t}\n\n\tget dashed() {\n\n\t\treturn 'USE_DASH' in this.defines;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( ( value === true ) !== this.dashed ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_DASH = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_DASH;\n\n\t\t}\n\n\t}\n\n\tget dashScale() {\n\n\t\treturn this.uniforms.dashScale.value;\n\n\t}\n\n\tset dashScale( value ) {\n\n\t\tthis.uniforms.dashScale.value = value;\n\n\t}\n\n\tget dashSize() {\n\n\t\treturn this.uniforms.dashSize.value;\n\n\t}\n\n\tset dashSize( value ) {\n\n\t\tthis.uniforms.dashSize.value = value;\n\n\t}\n\n\tget dashOffset() {\n\n\t\treturn this.uniforms.dashOffset.value;\n\n\t}\n\n\tset dashOffset( value ) {\n\n\t\tthis.uniforms.dashOffset.value = value;\n\n\t}\n\n\tget gapSize() {\n\n\t\treturn this.uniforms.gapSize.value;\n\n\t}\n\n\tset gapSize( value ) {\n\n\t\tthis.uniforms.gapSize.value = value;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( value ) {\n\n\t\tif ( ! this.uniforms ) return;\n\t\tthis.uniforms.opacity.value = value;\n\n\t}\n\n\tget resolution() {\n\n\t\treturn this.uniforms.resolution.value;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tthis.uniforms.resolution.value.copy( value );\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( ! this.defines ) return;\n\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\n\t\tif ( uniforms && uniforms.resolution ) {\n\n\t\t\trenderer.getViewport( _viewport );\n\t\t\tthis.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nclass LineGeometry extends LineSegmentsGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineGeometry = true;\n\n\t\tthis.type = 'LineGeometry';\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst points = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setPositions( points );\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tconst length = array.length - 3;\n\t\tconst colors = new Float32Array( 2 * length );\n\n\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setColors( colors );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\t// converts a vector3 or vector2 array to pairs format\n\n\t\tconst length = points.length - 1;\n\t\tconst positions = new Float32Array( 6 * length );\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tpositions[ 6 * i ] = points[ i ].x;\n\t\t\tpositions[ 6 * i + 1 ] = points[ i ].y;\n\t\t\tpositions[ 6 * i + 2 ] = points[ i ].z || 0;\n\n\t\t\tpositions[ 6 * i + 3 ] = points[ i + 1 ].x;\n\t\t\tpositions[ 6 * i + 4 ] = points[ i + 1 ].y;\n\t\t\tpositions[ 6 * i + 5 ] = points[ i + 1 ].z || 0;\n\n\t\t}\n\n\t\tsuper.setPositions( positions );\n\n\t\treturn this;\n\n\t}\n\n\tfromLine( line ) {\n\n\t\tconst geometry = line.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { LineGeometry };\n","import { LineSegments2 } from '../lines/LineSegments2.js';\nimport { LineGeometry } from '../lines/LineGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n\n\tconstructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLine2 = true;\n\n\t\tthis.type = 'Line2';\n\n\t}\n\n}\n\nexport { Line2 };\n","import { Color, Vector2 } from \"three\";\r\nimport { Line2 } from \"three/addons/lines/Line2.js\";\r\nimport { LineGeometry } from \"three/addons/lines/LineGeometry.js\";\r\nimport { LineMaterial } from \"three/addons/lines/LineMaterial.js\";\r\nimport { GizmoOptionsFallback } from \"../types\";\r\nimport { GIZMO_AXES, GIZMO_SPHERE_AXES_DISTANCE } from \"./constants\";\r\n\r\nexport const axesLines = (options: GizmoOptionsFallback) => {\r\n  const colorManager = new Color();\r\n  const positions: number[] = [];\r\n  const colors: number[] = [];\r\n  const { isSphere } = options;\r\n\r\n  GIZMO_AXES.forEach((axisName, i) => {\r\n    const { enabled, line, scale, color } = options[axisName];\r\n\r\n    if (!enabled || !line) return;\r\n\r\n    const negative = i < 3 ? 1 : -1;\r\n    const distance = isSphere ? GIZMO_SPHERE_AXES_DISTANCE - scale / 2 : 0.975;\r\n    const point = distance * negative;\r\n\r\n    positions.push(\r\n      axisName.includes(\"x\") ? point : 0,\r\n      axisName.includes(\"y\") ? point : 0,\r\n      axisName.includes(\"z\") ? point : 0,\r\n      0,\r\n      0,\r\n      0\r\n    );\r\n\r\n    const colorArray = colorManager.set(color).toArray();\r\n    colors.push(...colorArray, ...colorArray);\r\n  });\r\n\r\n  if (!positions.length) return null;\r\n\r\n  const geometry = new LineGeometry().setPositions(positions).setColors(colors);\r\n\r\n  const material = new LineMaterial({\r\n    linewidth: options.lineWidth,\r\n    vertexColors: true,\r\n    resolution: new Vector2(window.innerWidth, window.innerHeight),\r\n  });\r\n\r\n  return new Line2(geometry, material).computeLineDistances();\r\n};\r\n","import { GizmoOptionsFallback, GizmoAxisObject } from \"../types\";\r\nimport { axesMap } from \"./axesMap\";\r\nimport { axesFaces } from \"./axesFaces\";\r\nimport { axesCorners } from \"./axesCorners\";\r\nimport { axesEdges } from \"./axesEdges\";\r\nimport { gizmoBackground } from \"./gizmoBackground\";\r\nimport { axesLines } from \"./axesLines\";\r\n\r\nexport const axesObjects = (options: GizmoOptionsFallback) => {\r\n  const { corners, edges } = options;\r\n\r\n  const axes: GizmoAxisObject[] = [];\r\n  const map = axesMap(options);\r\n\r\n  const faces = axesFaces(options, map);\r\n\r\n  axes.push(...faces);\r\n  if (corners.enabled) axes.push(...axesCorners(options, map));\r\n  if (edges.enabled)\r\n    axes.push(...axesEdges(options, map, corners.enabled ? 7 : 6));\r\n\r\n  const background = gizmoBackground(faces, options);\r\n\r\n  const lines = axesLines(options);\r\n\r\n  return [axes, background, lines] as const;\r\n};\r\n","import { GizmoAxisObject } from \"@lib/types\";\r\nimport { setMapHoverOffset } from \"./axesMap\";\r\n\r\nexport const axisHover = (axis: GizmoAxisObject, hovered: boolean = true) => {\r\n  const { material, userData } = axis;\r\n\r\n  const { opacity, color, scale } = hovered ? userData.hover : userData;\r\n\r\n  axis.scale.setScalar(scale);\r\n  material.opacity = opacity;\r\n\r\n  if (material.map) setMapHoverOffset(material.map, hovered);\r\n  else material.color.set(color);\r\n};\r\n","import {\r\n  Camera,\r\n  Clock,\r\n  Matrix4,\r\n  Mesh,\r\n  MeshBasicMaterial,\r\n  Object3D,\r\n  OrthographicCamera,\r\n  PerspectiveCamera,\r\n  Quaternion,\r\n  Scene,\r\n  Spherical,\r\n  Vector2,\r\n  Vector3,\r\n  Vector4,\r\n  type WebGLRenderer,\r\n} from \"three\";\r\n\r\nimport { gizmoDomElement, setDomPlacement } from \"./utils/gizmoDomElement\";\r\nimport { getDomElement } from \"./utils/getDomElement\";\r\nimport { updateAxis } from \"./utils/updateAxis\";\r\nimport { isClick } from \"./utils/isClick\";\r\nimport { intersectedObjects } from \"./utils/intersectedObjects\";\r\n\r\nimport {\r\n  GizmoOptions,\r\n  ViewportGizmoEventMap,\r\n  GizmoAxisOptions,\r\n  GizmoOptionsFallback,\r\n  GizmoAxisObject,\r\n  GizmoViewportArray,\r\n} from \"./types\";\r\nimport { EPSILON, GIZMO_TURN_RATE } from \"./utils/constants\";\r\nimport { updateBackground } from \"./utils/updateBackground\";\r\nimport type { OrbitControls } from \"three/examples/jsm/Addons.js\";\r\nimport { optionsFallback } from \"./utils/optionsFallback\";\r\nimport { clamp } from \"three/src/math/MathUtils.js\";\r\nimport { axesObjects } from \"./utils/axesObjects\";\r\nimport { axisHover } from \"./utils/axisHover\";\r\nimport type { WebGPURenderer } from \"three/webgpu\";\r\n\r\nexport type { GizmoOptions, ViewportGizmoEventMap, GizmoAxisOptions };\r\n\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\nconst _spherical = /*@__PURE__*/ new Spherical();\r\nconst _vec2 = /*@__PURE__*/ new Vector2();\r\nconst _vec3 = /*@__PURE__*/ new Vector3();\r\nconst _vec4 = /*@__PURE__*/ new Vector4();\r\n\r\n/**\r\n * ViewportGizmo is a 3D camera orientation controller that provides a visual interface\r\n * for changing the camera's viewing angle. It creates a widget that shows the current\r\n * camera orientation and allows direct manipulation of the view through clicking or dragging.\r\n *\r\n * @fires ViewportGizmo#start - Fired when a view change interaction begins\r\n * @fires ViewportGizmo#change - Fired during view changes\r\n * @fires ViewportGizmo#end - Fired when a view change interaction ends\r\n *\r\n * @extends Object3D\r\n */\r\nexport class ViewportGizmo extends Object3D<ViewportGizmoEventMap> {\r\n  /** Whether the gizmo is currently active and responding to user input */\r\n  enabled: boolean = true;\r\n\r\n  /** The camera being controlled by this gizmo */\r\n  camera: OrthographicCamera | PerspectiveCamera;\r\n\r\n  /** The WebGLRenderer rendering the gizmo */\r\n  renderer: WebGLRenderer | WebGPURenderer;\r\n\r\n  /** The configuration options */\r\n  options!: GizmoOptions;\r\n\r\n  /** The point around which the camera rotates */\r\n  target = new Vector3();\r\n\r\n  /** Whether view changes should be animated */\r\n  animated: boolean = true;\r\n\r\n  /** The speed of view change animations. Higher values result in faster animations */\r\n  speed: number = 1;\r\n\r\n  /**\r\n   * Indicates whether the gizmo is currently being animated or not,\r\n   * Useful when interacting with other camera controllers\r\n   *\r\n   * @readonly This value is set internally.\r\n   **/\r\n  animating = false;\r\n\r\n  private _options!: GizmoOptionsFallback;\r\n  private _intersections!: GizmoAxisObject[];\r\n  private _background: Mesh<any, MeshBasicMaterial> | null = null;\r\n  private _viewport: GizmoViewportArray = [0, 0, 0, 0];\r\n  private _originalViewport: GizmoViewportArray = [0, 0, 0, 0];\r\n  private _originalScissor: GizmoViewportArray = [0, 0, 0, 0];\r\n  private _scene: Scene;\r\n  private _camera!: Camera;\r\n  private _container!: HTMLElement;\r\n  private _domElement!: HTMLElement;\r\n  private _domRect!: DOMRect;\r\n  private _dragging: boolean = false;\r\n  private _distance: number = 0;\r\n  private _clock: Clock = new Clock();\r\n  private _targetQuaternion = new Quaternion();\r\n  private _quaternionStart = new Quaternion();\r\n  private _quaternionEnd = new Quaternion();\r\n  private _pointerStart = new Vector2();\r\n  private _focus: GizmoAxisObject | null = null;\r\n  private _placement!: GizmoOptionsFallback[\"placement\"];\r\n  private _controls?: OrbitControls;\r\n  private _controlsListeners?: {\r\n    start: () => void;\r\n    end: () => void;\r\n    change: () => void;\r\n  };\r\n\r\n  /**\r\n   * Creates a new ViewportGizmo instance.\r\n   *\r\n   * @param camera - The camera to be controlled by this gizmo\r\n   * @param renderer - The WebGL renderer used to render the scene\r\n   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.\r\n   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string\r\n   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'\r\n   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128\r\n   * @param options.placement - Position of the gizmo in the viewport\r\n   *    Options include:\r\n   *    - `\"top-left\"`\r\n   *    - `\"top-center\"`\r\n   *    - `\"top-right\"`\r\n   *    - `\"center-left\"`\r\n   *    - `\"center-center\"`\r\n   *    - `\"center-right\"`\r\n   *    - `\"bottom-left\"`\r\n   *    - `\"bottom-center\"`\r\n   *    - `\"bottom-right\"`\r\n   * @param options.offset - Offset of the gizmo from container edges in pixels\r\n   * @param options.offset.left - Offset from the left edge\r\n   * @param options.offset.top - Offset from the top edge\r\n   * @param options.offset.right - Offset from the right edge\r\n   * @param options.offset.bottom - Offset from the bottom edge\r\n   * @param options.animated - Whether view changes should be animated. Defaults to true\r\n   * @param options.speed - Animation speed multiplier. Defaults to 1\r\n   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube\r\n   * @param options.lineWidth - Width of the axes lines in pixels\r\n   * @param options.id - HTML `id` attribute for the gizmo container\r\n   * @param options.className - HTML `class` attribute for the gizmo container\r\n   * @param options.font - Font configuration for axis labels\r\n   * @param options.font.family - Font family for axis labels\r\n   * @param options.font.weight - Font weight for axis labels\r\n   * @param options.background - Configuration for the background sphere/cube\r\n   * @param options.background.enabled - Whether to display the background\r\n   * @param options.background.color - Color of the background in normal state\r\n   * @param options.background.opacity - Opacity of the background in normal state\r\n   * @param options.background.hover.color - Color of the background when hovered\r\n   * @param options.background.hover.opacity - Opacity of the background when hovered\r\n   * @param options.corners - Configuration for corner indicators\r\n   * @param options.corners.enabled - Whether to display corner indicators\r\n   * @param options.corners.color - Base color of corner indicators\r\n   * @param options.corners.opacity - Opacity of corner indicators\r\n   * @param options.corners.scale - Scale multiplier for corner indicators\r\n   * @param options.corners.radius - Radius of corner indicators\r\n   * @param options.corners.smoothness - Smoothness of corner indicators\r\n   * @param options.corners.hover.color - Color of corner indicators when hovered\r\n   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered\r\n   * @param options.corners.hover.scale - Scale of corner indicators when hovered\r\n   * @param options.edges - Configuration for edge indicators\r\n   * @param options.edges.enabled - Whether to display edge indicators\r\n   * @param options.edges.color - Base color of edge indicators\r\n   * @param options.edges.opacity - Opacity of edge indicators\r\n   * @param options.edges.scale - Scale multiplier for edge indicators\r\n   * @param options.edges.radius - Radius of edge indicators\r\n   * @param options.edges.smoothness - Smoothness of edge indicators\r\n   * @param options.edges.hover.color - Color of edge indicators when hovered\r\n   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered\r\n   * @param options.edges.hover.scale - Scale of edge indicators when hovered\r\n   * @param options.x - Configuration for positive X axis/face\r\n   * @param options.y - Configuration for positive Y axis/face\r\n   * @param options.z - Configuration for positive Z axis/face\r\n   * @param options.nx - Configuration for negative X axis/face\r\n   * @param options.ny - Configuration for negative Y axis/face\r\n   * @param options.nz - Configuration for negative Z axis/face\r\n   *\r\n   * @remarks Axis-specific configuration can also use alias names for cube mode:\r\n   * - `right` (same as `x`)\r\n   * - `left` (same as `nx`)\r\n   * - `top` (same as `y`)\r\n   * - `bottom` (same as `ny`)\r\n   * - `front` (same as `z`)\r\n   * - `back` (same as `nz`)\r\n   *\r\n   * For each axis/face configuration, the following options are available:\r\n   * @param options.AXIS.enabled - Whether to draw the axis\r\n   * @param options.AXIS.label - Custom text label for the axis\r\n   * @param options.AXIS.opacity - Axis opacity\r\n   * @param options.AXIS.scale - Scale multiplier for indicator size\r\n   * @param options.AXIS.line - Whether to draw the axis line\r\n   * @param options.AXIS.color - Axis indicator background color\r\n   * @param options.AXIS.labelColor - Axis label color\r\n   * @param options.AXIS.border.size - Border size around the axis indicator\r\n   * @param options.AXIS.border.color - Border color around the axis indicator\r\n   * @param options.AXIS.hover.color - Fill color on hover\r\n   * @param options.AXIS.hover.labelColor - Label text color on hover\r\n   * @param options.AXIS.hover.opacity - Opacity when hovered\r\n   * @param options.AXIS.hover.scale - Indicator scale when hovered\r\n   * @param options.AXIS.hover.border.size - Hover border size\r\n   * @param options.AXIS.hover.border.color - Hover border color\r\n   */\r\n  constructor(\r\n    camera: PerspectiveCamera | OrthographicCamera,\r\n    renderer: WebGLRenderer | WebGPURenderer,\r\n    options: GizmoOptions = {}\r\n  ) {\r\n    super();\r\n\r\n    this.camera = camera;\r\n    this.renderer = renderer;\r\n    this._scene = new Scene().add(this);\r\n    this.set(options);\r\n  }\r\n\r\n  /** Gets the current placement of the gizmo relative to its container. */\r\n  get placement(): GizmoOptionsFallback[\"placement\"] {\r\n    return this._placement;\r\n  }\r\n\r\n  /**\r\n   * Sets and update the placement of the gizmo relative to its container.\r\n   *\r\n   * @param placement - The new placement position\r\n   */\r\n  set placement(placement: GizmoOptionsFallback[\"placement\"]) {\r\n    this._placement = setDomPlacement(this._domElement, placement);\r\n    this.domUpdate();\r\n  }\r\n\r\n  /**\r\n   * Regenerates the gizmo with the new options.\r\n   *\r\n   * @remarks\r\n   * - Not recommended for use in real-time rendering or animation loops\r\n   * - Provides a way to completely rebuild the gizmo with new options\r\n   * - Can be computationally expensive, so use sparingly\r\n   */\r\n  set(options: GizmoOptions = {}) {\r\n    this.dispose();\r\n\r\n    this.options = options;\r\n    this._options = optionsFallback(options);\r\n\r\n    this._camera = this._options.isSphere\r\n      ? new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 5, 10)\r\n      : new PerspectiveCamera(26, 1, 5, 10);\r\n\r\n    this._camera.position.set(0, 0, 7);\r\n\r\n    const [axes, background, lines] = axesObjects(this._options);\r\n\r\n    if (background) this.add(background);\r\n    if (lines) this.add(lines);\r\n    this.add(...axes);\r\n\r\n    this._background = background;\r\n    this._intersections = axes;\r\n\r\n    const { container, animated, speed } = this._options;\r\n\r\n    this.animated = animated;\r\n    this.speed = speed;\r\n\r\n    this._container = container\r\n      ? getDomElement(container as string)\r\n      : document.body;\r\n\r\n    this._domElement = gizmoDomElement(this._options);\r\n    this._domElement.onpointerdown = (e) => this._onPointerDown(e);\r\n    this._domElement.onpointermove = (e) => this._onPointerMove(e);\r\n    this._domElement.onpointerleave = () => this._onPointerLeave();\r\n\r\n    this._container.appendChild(this._domElement);\r\n\r\n    if (this._controls) this.attachControls(this._controls);\r\n\r\n    this.update();\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Renders the gizmo to the screen.\r\n   * This method handles viewport and scissor management to ensure the gizmo\r\n   * renders correctly without affecting the main scene rendering.\r\n   *\r\n   * @returns The gizmo instance for method chaining\r\n   */\r\n  render() {\r\n    if (this.animating) this._animate();\r\n\r\n    const { renderer, _viewport } = this;\r\n\r\n    const _prevScissorTest = renderer.getScissorTest();\r\n    const _prevAutoClear = renderer.autoClear;\r\n\r\n    renderer.autoClear = false;\r\n    renderer.setViewport(..._viewport);\r\n    if (_prevScissorTest) renderer.setScissor(..._viewport);\r\n\r\n    renderer.clear(false, true, false);\r\n    renderer.render(this._scene, this._camera);\r\n\r\n    renderer.setViewport(...this._originalViewport);\r\n    if (_prevScissorTest) renderer.setScissor(...this._originalScissor);\r\n\r\n    renderer.autoClear = _prevAutoClear;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates the gizmo's DOM-related properties based on its current position\r\n   * and size in the document.\r\n   *\r\n   * @returns The gizmo instance for method chaining\r\n   */\r\n  domUpdate() {\r\n    this._domRect = this._domElement.getBoundingClientRect();\r\n\r\n    const renderer = this.renderer;\r\n    const domRect = this._domRect;\r\n    const containerRect = renderer.domElement.getBoundingClientRect();\r\n\r\n    this._viewport.splice(\r\n      0,\r\n      4,\r\n      domRect.left - containerRect.left,\r\n      renderer.domElement.clientHeight -\r\n        (domRect.top - containerRect.top + domRect.height),\r\n      domRect.width,\r\n      domRect.height\r\n    );\r\n\r\n    renderer.getViewport(_vec4).toArray(this._originalViewport);\r\n    if (renderer.getScissorTest())\r\n      renderer.getScissor(_vec4).toArray(this._originalScissor);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates the gizmo's orientation to match the current camera orientation.\r\n   *\r\n   * @returns The gizmo instance for method chaining\r\n   */\r\n  cameraUpdate() {\r\n    this._updateOrientation();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Performs a complete update of the gizmo, including both DOM and camera-related updates.\r\n   *\r\n   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.\r\n   *\r\n   * @returns The gizmo instance for method chaining\r\n   */\r\n  update(controls: boolean = true) {\r\n    if (controls && this._controls) this._controls.update();\r\n    return this.domUpdate().cameraUpdate();\r\n  }\r\n\r\n  /**\r\n   * Connects OrbitControls with the gizmo, handling interaction states and updates.\r\n   * Automatically detaches any previously attached controls.\r\n   *\r\n   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}\r\n   */\r\n  attachControls(controls: OrbitControls) {\r\n    this.detachControls();\r\n\r\n    this.target = controls.target;\r\n\r\n    this._controlsListeners = {\r\n      start: () => (controls.enabled = false),\r\n      end: () => (controls.enabled = true),\r\n      change: () => this.update(false),\r\n    };\r\n\r\n    this.addEventListener(\"start\", this._controlsListeners.start);\r\n    this.addEventListener(\"end\", this._controlsListeners.end);\r\n    controls.addEventListener(\"change\", this._controlsListeners.change);\r\n\r\n    this._controls = controls;\r\n\r\n    return this;\r\n  }\r\n\r\n  /** Removes all control event listeners and references. Safe to call multiple times. */\r\n  detachControls() {\r\n    if (!this._controlsListeners || !this._controls) return;\r\n\r\n    this.target = new Vector3().copy(this._controls.target);\r\n\r\n    this.removeEventListener(\"start\", this._controlsListeners.start);\r\n    this.removeEventListener(\"end\", this._controlsListeners.end);\r\n\r\n    this._controls.removeEventListener(\r\n      \"change\",\r\n      this._controlsListeners.change\r\n    );\r\n\r\n    this._controlsListeners = undefined;\r\n    this._controls = undefined;\r\n\r\n    return this;\r\n  }\r\n\r\n  /** Cleans up all resources including geometries, materials, textures, and event listeners. */\r\n  dispose() {\r\n    this.detachControls();\r\n\r\n    this.children.forEach((child) => {\r\n      this.remove(child);\r\n      const mesh = child as Mesh<any, MeshBasicMaterial>;\r\n      mesh.material?.dispose();\r\n      mesh.material?.map?.dispose();\r\n      mesh.geometry?.dispose();\r\n    });\r\n\r\n    this._domElement?.remove();\r\n  }\r\n\r\n  /**\r\n   * Updates the gizmo's orientation either based on the camera or internal state.\r\n   *\r\n   * @private\r\n   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)\r\n   */\r\n  private _updateOrientation(fromCamera: boolean = true) {\r\n    if (fromCamera) {\r\n      this.quaternion.copy(this.camera.quaternion).invert();\r\n      this.updateMatrixWorld();\r\n    }\r\n\r\n    updateAxis(this._options, this._intersections, this.camera);\r\n  }\r\n\r\n  /**\r\n   * Handles the animation of camera position and orientation changes.\r\n   *\r\n   * @private\r\n   */\r\n  private _animate() {\r\n    const { position, quaternion } = this.camera;\r\n\r\n    position.set(0, 0, 1);\r\n\r\n    if (!this.animated) {\r\n      position\r\n        .applyQuaternion(this._quaternionEnd)\r\n        .multiplyScalar(this._distance)\r\n        .add(this.target);\r\n\r\n      quaternion.copy(this._targetQuaternion);\r\n\r\n      this._updateOrientation();\r\n\r\n      this.animating = false;\r\n      this.dispatchEvent({ type: \"change\" });\r\n      this.dispatchEvent({ type: \"end\" });\r\n      return;\r\n    }\r\n\r\n    if (this._controls) this._controls.enabled = false;\r\n\r\n    const delta = this._clock.getDelta();\r\n\r\n    const step = delta * GIZMO_TURN_RATE * this.speed;\r\n\r\n    this._quaternionStart.rotateTowards(this._quaternionEnd, step);\r\n\r\n    position\r\n      .applyQuaternion(this._quaternionStart)\r\n      .multiplyScalar(this._distance)\r\n      .add(this.target);\r\n\r\n    quaternion.rotateTowards(this._targetQuaternion, step);\r\n\r\n    this._updateOrientation();\r\n    // FIXME - Need fix?\r\n    requestAnimationFrame(() => this.dispatchEvent({ type: \"change\" }));\r\n\r\n    if (this._quaternionStart.angleTo(this._quaternionEnd) < EPSILON) {\r\n      if (this._controls) this._controls.enabled = true;\r\n      this.animating = false;\r\n      this.dispatchEvent({ type: \"end\" });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the camera orientation to look at the target from a specific axis.\r\n   *\r\n   * @private\r\n   * @param position - The axis point position\r\n   */\r\n  private _setOrientation(position: Vector3) {\r\n    const camera = this.camera;\r\n    const focusPoint = this.target;\r\n\r\n    _vec3.copy(position).multiplyScalar(this._distance);\r\n\r\n    _matrix.setPosition(_vec3).lookAt(_vec3, this.position, this.up);\r\n    this._targetQuaternion.setFromRotationMatrix(_matrix);\r\n\r\n    _vec3.add(focusPoint);\r\n\r\n    _matrix.lookAt(_vec3, focusPoint, this.up);\r\n    this._quaternionEnd.setFromRotationMatrix(_matrix);\r\n\r\n    _matrix\r\n      .setPosition(camera.position)\r\n      .lookAt(camera.position, focusPoint, this.up);\r\n    this._quaternionStart.setFromRotationMatrix(_matrix);\r\n\r\n    this.animating = true;\r\n    this._clock.start();\r\n    this.dispatchEvent({ type: \"start\" });\r\n  }\r\n\r\n  /**\r\n   * Handles the pointer down event for starting drag operations.\r\n   *\r\n   * @private\r\n   * @param e - The pointer event\r\n   */\r\n  private _onPointerDown(e: PointerEvent) {\r\n    if (!this.enabled) return;\r\n\r\n    const drag = (e: PointerEvent) => {\r\n      if (!this._dragging) {\r\n        if (isClick(e, this._pointerStart)) return;\r\n        this._dragging = true;\r\n      }\r\n\r\n      const pointerAngle = _vec2\r\n        .set(e.clientX, e.clientY)\r\n        .sub(this._pointerStart)\r\n        .multiplyScalar((1 / this._domRect.width) * Math.PI);\r\n\r\n      const direction = _vec3.subVectors(this.camera.position, this.target);\r\n      const {x, y, z} = this.coordinateConversion(direction);\r\n\r\n      const spherical = _spherical.setFromCartesianCoords(x, y, z);\r\n\r\n      spherical.theta = initialTheta - pointerAngle.x;\r\n      spherical.phi = clamp(\r\n        initialPhi - pointerAngle.y,\r\n        EPSILON,\r\n        Math.PI - EPSILON\r\n      );\r\n\r\n      const positions = this.setFromSpherical(spherical);\r\n\r\n      this.camera.position.set(positions.x, positions.y, positions.z).add(this.target);\r\n      this.camera.lookAt(this.target);\r\n\r\n      this.quaternion.copy(this.camera.quaternion).invert();\r\n\r\n      this._updateOrientation(false);\r\n      this.dispatchEvent({ type: \"change\" });\r\n    };\r\n\r\n    const endDrag = () => {\r\n      document.removeEventListener(\"pointermove\", drag, false);\r\n      document.removeEventListener(\"pointerup\", endDrag, false);\r\n\r\n      if (!this._dragging) return this._handleClick(e);\r\n\r\n      if (this._focus) {\r\n        axisHover(this._focus, false);\r\n        this._focus = null;\r\n      }\r\n\r\n      this._dragging = false;\r\n      this.dispatchEvent({ type: \"end\" });\r\n    };\r\n\r\n    if (this.animating) return;\r\n\r\n    e.preventDefault();\r\n    this._pointerStart.set(e.clientX, e.clientY);\r\n\r\n    const direction = _vec3.subVectors(this.camera.position, this.target);\r\n    const {x, y, z} = this.coordinateConversion(direction);\r\n    \r\n    const initialSpherical = new Spherical().setFromCartesianCoords(x, y, z);\r\n    const initialTheta = initialSpherical.theta;\r\n    const initialPhi = initialSpherical.phi;\r\n    this._distance = initialSpherical.radius;\r\n\r\n    document.addEventListener(\"pointermove\", drag, false);\r\n    document.addEventListener(\"pointerup\", endDrag, false);\r\n\r\n    this.dispatchEvent({ type: \"start\" });\r\n  }\r\n\r\n  /**\r\n   * Converts the input-coordinates from the standard Y-axis up to what is set in Object3D.DEFAULT_UP.\r\n   * \r\n   * @private\r\n   * @param input - The coordinates to be converted\r\n   * @param spherical - Whether or not the coordinates are for a sphere\r\n   * @returns The converted coordinates\r\n   */\r\n  private coordinateConversion(input: {x: number, y: number, z: number}, spherical = false) {\r\n    const {x, y, z} = input;\r\n\r\n    if (Object3D.DEFAULT_UP.x === 1)\r\n      return spherical ? {x: y, y: z, z: x} : {x: z, y: x, z: y}\r\n    else if (Object3D.DEFAULT_UP.z === 1)\r\n      return spherical ? {x: z, y: x, z: y} : {x: y, y: z, z: x}\r\n    else\r\n      return {x, y, z}\r\n  }\r\n\r\n  /**\r\n   * Based on the Three.js-function setFromSphericalCoords, with coordinate conversion applied.\r\n   * \r\n   * @private\r\n   * @param s - The spherical coordinates\r\n   * @returns - Vector x, y, z\r\n   */\r\n  private setFromSpherical( s: Spherical ) {\r\n    const radius = s.radius;\r\n    const phi = s.phi;\r\n    const theta = s.theta;\r\n\r\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\r\n\r\n\t\tconst x = sinPhiRadius * Math.sin( theta );\r\n\t\tconst y = radius * Math.cos( phi );\r\n    const z = sinPhiRadius * Math.cos( theta );\r\n\r\n\t\treturn this.coordinateConversion({x, y, z}, true);\r\n\t}\r\n\r\n  /**\r\n   * Handles pointer move events for hover effects and drag operations.\r\n   *\r\n   * @private\r\n   * @param e - The pointer event\r\n   */\r\n  private _onPointerMove(e: PointerEvent) {\r\n    if (!this.enabled || this._dragging) return;\r\n\r\n    if (this._background) updateBackground(this._background, true);\r\n\r\n    this._handleHover(e);\r\n  }\r\n\r\n  /**\r\n   * Handles pointer leave events to reset hover states.\r\n   *\r\n   * @private\r\n   */\r\n  private _onPointerLeave() {\r\n    if (!this.enabled || this._dragging) return;\r\n\r\n    if (this._background) updateBackground(this._background, false);\r\n    if (this._focus) axisHover(this._focus, false);\r\n\r\n    this._domElement.style.cursor = \"\";\r\n  }\r\n\r\n  /**\r\n   * Handles click events for axis selection.\r\n   *\r\n   * @private\r\n   * @param e - The pointer event\r\n   */\r\n  private _handleClick(e: PointerEvent) {\r\n    const intersection = intersectedObjects(\r\n      e,\r\n      this._domRect,\r\n      this._camera,\r\n      this._intersections\r\n    );\r\n\r\n    if (this._focus) {\r\n      axisHover(this._focus, false);\r\n      this._focus = null;\r\n    }\r\n\r\n    if (!intersection) return;\r\n\r\n    this._setOrientation(intersection.object.position);\r\n\r\n    this.dispatchEvent({ type: \"change\" });\r\n  }\r\n\r\n  /**\r\n   * Handles hover effects for interactive elements.\r\n   *\r\n   * @private\r\n   * @param e - The pointer event\r\n   */\r\n  private _handleHover(e: PointerEvent) {\r\n    const intersection = intersectedObjects(\r\n      e,\r\n      this._domRect,\r\n      this._camera,\r\n      this._intersections\r\n    );\r\n\r\n    const object = intersection?.object || null;\r\n\r\n    if (this._focus === object) return;\r\n\r\n    this._domElement.style.cursor = object ? \"pointer\" : \"\";\r\n\r\n    if (this._focus) axisHover(this._focus, false);\r\n\r\n    if ((this._focus = object)) axisHover(object, true);\r\n    else updateAxis(this._options, this._intersections, this.camera);\r\n  }\r\n}\r\n"],"names":["setDomPlacement","domElement","placement","y","x","gizmoDomElement","size","offset","id","className","div","top","left","right","bottom","getDomElement","element","clamp","value","min","max","axisMap","point","Vector3","updateAxis","isSphere","axes","camera","axis","positiveIndex","negativeIndex","object","opacity","isClick","e","startCoords","threshold","_raycaster","Raycaster","_mouse","Vector2","intersectedObjects","event","domRect","intersections","intersects","intersection","EPSILON","GIZMO_TURN_RATE","AXES","GIZMO_AXES","GIZMO_FACES","GIZMO_SPHERE_AXES_DISTANCE","updateBackground","background","hovered","material","userData","color","deepClone","obj","optionsFallback","options","type","resolution","container","face","index","axesFallback","negativeAxesFallback","assignNestedDefaults","target","defaultObjects","defaults","key","axesMap","colorManager","Color","doubleOffset","radius","font","corners","edges","canvas","ctx","fontStyle","fontYFix","getFontStyle","label","labelColor","border","hoverColor","hoverLabel","hoverBorder","drawAxis","colsCount","offsetX","offsetY","cellHeight","map","CanvasTexture","SRGBColorSpace","RepeatWrapping","drawRoundRectPath","halfBorderWidth","drawText","text","a","b","_a","_b","family","weight","square","fontSize","textWidth","textHeight","measure","yFix","scaleFactor","finalFontSize","setMapHoverOffset","hover","setMapColumnOffset","col","roundedRectangleGeometry","smoothness","width","height","wi","hi","ul","ur","vl","vh","positions","uvs","n","indices","i","phi","cos","sin","xc","yc","uc","vc","idx","j","BufferGeometry","BufferAttribute","axesFaces","texture","geometry","_","isPositive","enabled","scale","materialConfig","Sprite","SpriteMaterial","Mesh","MeshBasicMaterial","direction","axesCorners","val","corner","i3","axesEdges","textureColumn","defaultUp","edge","mergeGeometries","geometries","useGroups","isIndexed","attributesUsed","morphAttributesUsed","attributes","morphAttributes","morphTargetsRelative","mergedGeometry","attributesCount","name","count","indexOffset","mergedIndex","mergedAttribute","mergeAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","gpuType","arrayLength","attribute","array","result","tupleOffset","l","c","gizmoBackground","faces","BackSide","SphereGeometry","plane","originalScale","planeGeometry","_box","Box3","_vector","LineSegmentsGeometry","InstancedBufferGeometry","Float32BufferAttribute","matrix","start","end","lineSegments","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","mesh","WireframeGeometry","Sphere","center","maxRadiusSq","il","three","UniformsUtils","UniformsLib","LineMaterial","ShaderMaterial","parameters","ShaderLib","_viewport","Vector4","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","distance","raycastWorldUnits","matrixWorld","instanceStart","instanceEnd","segmentCount","pointOnLine","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","lineDistances","instanceDistanceBuffer","raycaster","worldUnits","sphereMargin","distanceToSphere","boxMargin","distanceToBox","renderer","uniforms","LineGeometry","length","points","line","Line2","axesLines","axisName","negative","colorArray","axesObjects","lines","axisHover","_matrix","_spherical","Spherical","_vec2","_vec3","_vec4","ViewportGizmo","Object3D","__publicField","Clock","Quaternion","Scene","OrthographicCamera","PerspectiveCamera","animated","speed","_prevScissorTest","_prevAutoClear","containerRect","controls","child","_c","_d","fromCamera","position","quaternion","step","focusPoint","drag","pointerAngle","y2","z","spherical","initialTheta","initialPhi","endDrag","initialSpherical","input","s","theta","sinPhiRadius"],"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAqNV,eACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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","x_google_ignoreList":[2,15,17,18,19,20,21]}